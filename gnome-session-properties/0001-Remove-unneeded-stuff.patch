From d61cf23a158ef30cf3e4e684f357d055d10acbdc Mon Sep 17 00:00:00 2001
From: Xiao-Long Chen <chenxiaolong@cxl.epac.to>
Date: Tue, 15 Apr 2014 23:05:36 -0400
Subject: [PATCH 1/2] Remove unneeded stuff

---
 Makefile.am                                        |    2 -
 capplet/Makefile.am                                |    4 +-
 config.h.in                                        |   24 -
 configure.ac                                       |  209 +-
 data/Makefile.am                                   |   57 +-
 data/gnome-custom-session.desktop.in               |    5 -
 data/gnome-dummy.session.desktop.in.in             |    2 -
 data/gnome-session.convert                         |    3 -
 data/gnome-wayland.desktop.in                      |    8 -
 data/gnome-wayland.session.desktop.in.in           |    3 -
 data/gnome.desktop.in                              |    7 -
 data/gnome.session.desktop.in.in                   |    3 -
 data/hardware-compatibility                        |   29 -
 data/org.gnome.SessionManager.gschema.xml.in       |   24 -
 data/session-selector.ui                           |  195 -
 doc/Makefile.am                                    |    4 +-
 doc/dbus/Makefile.am                               |   48 -
 doc/dbus/Makefile.in                               |  607 ---
 doc/dbus/config.xsl                                |    6 -
 doc/dbus/dbus-introspect-docs.dtd                  |   32 -
 doc/dbus/docbook.css                               |   78 -
 doc/dbus/gnome-session.xml.in                      |   52 -
 doc/dbus/spec-to-docbook.xsl                       |  555 ---
 doc/man/Makefile.am                                |   14 +-
 doc/man/gnome-session-inhibit.1                    |   74 -
 doc/man/gnome-session-inhibit.xml                  |   99 -
 doc/man/gnome-session-quit.1                       |   34 -
 doc/man/gnome-session-selector.xml                 |   52 -
 doc/man/gnome-session.1                            |  114 -
 egg/Makefile.am                                    |   52 -
 egg/Makefile.in                                    |  728 ----
 egg/eggdesktopfile.c                               | 1528 --------
 egg/eggdesktopfile.h                               |  163 -
 egg/eggsmclient-private.h                          |   59 -
 egg/eggsmclient-xsmp.c                             | 1375 -------
 egg/eggsmclient.c                                  |  604 ---
 egg/eggsmclient.h                                  |  117 -
 gnome-session/Makefile.am                          |  138 -
 gnome-session/README                               |   69 -
 gnome-session/gdm-log.c                            |  206 --
 gnome-session/gdm-log.h                            |   51 -
 gnome-session/gsm-app.c                            |  516 ---
 gnome-session/gsm-app.h                            |  138 -
 gnome-session/gsm-autostart-app.c                  | 1443 --------
 gnome-session/gsm-autostart-app.h                  |   78 -
 gnome-session/gsm-client.c                         |  543 ---
 gnome-session/gsm-client.h                         |  171 -
 gnome-session/gsm-consolekit.c                     | 1054 ------
 gnome-session/gsm-consolekit.h                     |   61 -
 gnome-session/gsm-dbus-client.c                    |  698 ----
 gnome-session/gsm-dbus-client.h                    |   73 -
 gnome-session/gsm-fail-whale-dialog.c              |  376 --
 gnome-session/gsm-fail-whale-dialog.h              |   58 -
 gnome-session/gsm-fail-whale.c                     |   47 -
 gnome-session/gsm-fail-whale.h                     |   36 -
 gnome-session/gsm-icon-names.h                     |   30 -
 gnome-session/gsm-inhibitor-flag.h                 |   38 -
 gnome-session/gsm-inhibitor.c                      |  605 ---
 gnome-session/gsm-inhibitor.h                      |  111 -
 gnome-session/gsm-manager-logout-mode.h            |   35 -
 gnome-session/gsm-manager.c                        | 3863 --------------------
 gnome-session/gsm-manager.h                        |  206 --
 gnome-session/gsm-presence-flag.h                  |   35 -
 gnome-session/gsm-presence.c                       |  560 ---
 gnome-session/gsm-presence.h                       |   91 -
 gnome-session/gsm-process-helper.c                 |  138 -
 gnome-session/gsm-process-helper.h                 |   34 -
 gnome-session/gsm-session-fill.c                   |  339 --
 gnome-session/gsm-session-fill.h                   |   34 -
 gnome-session/gsm-session-save.c                   |  276 --
 gnome-session/gsm-session-save.h                   |   35 -
 gnome-session/gsm-shell-extensions.c               |  205 --
 gnome-session/gsm-shell-extensions.h               |   63 -
 gnome-session/gsm-shell.c                          |  700 ----
 gnome-session/gsm-shell.h                          |   89 -
 gnome-session/gsm-store.c                          |  409 ---
 gnome-session/gsm-store.h                          |   97 -
 gnome-session/gsm-system.c                         |  213 --
 gnome-session/gsm-system.h                         |  127 -
 gnome-session/gsm-systemd.c                        |  959 -----
 gnome-session/gsm-systemd.h                        |   61 -
 gnome-session/gsm-xsmp-client.c                    | 1352 -------
 gnome-session/gsm-xsmp-client.h                    |   91 -
 gnome-session/gsm-xsmp-server.c                    |  755 ----
 gnome-session/gsm-xsmp-server.h                    |   60 -
 gnome-session/main.c                               |  449 ---
 gnome-session/org.gnome.SessionManager.App.xml     |   43 -
 gnome-session/org.gnome.SessionManager.Client.xml  |   73 -
 .../org.gnome.SessionManager.ClientPrivate.xml     |  123 -
 .../org.gnome.SessionManager.Inhibitor.xml         |   66 -
 .../org.gnome.SessionManager.Presence.xml          |   95 -
 gnome-session/org.gnome.SessionManager.xml         |  453 ---
 gnome-session/test-client-dbus.c                   |  264 --
 gnome-session/test-inhibit.c                       |  196 -
 gnome-session/test-process-helper.c                |   58 -
 po/POTFILES.in                                     |   18 -
 po/POTFILES.skip                                   |    5 -
 tools/Makefile.am                                  |   85 -
 tools/Makefile.in                                  | 1011 -----
 tools/gnome-session-check-accelerated-common.h     |   29 -
 tools/gnome-session-check-accelerated-helper.c     |  463 ---
 tools/gnome-session-check-accelerated.c            |  195 -
 tools/gnome-session-custom-session                 |    4 -
 tools/gnome-session-inhibit.c                      |  261 --
 tools/gnome-session-quit.c                         |  221 --
 tools/gnome-session-selector.c                     |  699 ----
 106 files changed, 10 insertions(+), 29138 deletions(-)
 delete mode 100644 data/gnome-custom-session.desktop.in
 delete mode 100644 data/gnome-dummy.session.desktop.in.in
 delete mode 100644 data/gnome-session.convert
 delete mode 100644 data/gnome-wayland.desktop.in
 delete mode 100644 data/gnome-wayland.session.desktop.in.in
 delete mode 100644 data/gnome.desktop.in
 delete mode 100644 data/gnome.session.desktop.in.in
 delete mode 100644 data/hardware-compatibility
 delete mode 100644 data/org.gnome.SessionManager.gschema.xml.in
 delete mode 100644 data/session-selector.ui
 delete mode 100644 doc/dbus/Makefile.am
 delete mode 100644 doc/dbus/Makefile.in
 delete mode 100644 doc/dbus/config.xsl
 delete mode 100644 doc/dbus/dbus-introspect-docs.dtd
 delete mode 100644 doc/dbus/docbook.css
 delete mode 100644 doc/dbus/gnome-session.xml.in
 delete mode 100644 doc/dbus/spec-to-docbook.xsl
 delete mode 100644 doc/man/gnome-session-inhibit.1
 delete mode 100644 doc/man/gnome-session-inhibit.xml
 delete mode 100644 doc/man/gnome-session-quit.1
 delete mode 100644 doc/man/gnome-session-selector.xml
 delete mode 100644 doc/man/gnome-session.1
 delete mode 100644 egg/Makefile.am
 delete mode 100644 egg/Makefile.in
 delete mode 100644 egg/eggdesktopfile.c
 delete mode 100644 egg/eggdesktopfile.h
 delete mode 100644 egg/eggsmclient-private.h
 delete mode 100644 egg/eggsmclient-xsmp.c
 delete mode 100644 egg/eggsmclient.c
 delete mode 100644 egg/eggsmclient.h
 delete mode 100644 gnome-session/README
 delete mode 100644 gnome-session/gdm-log.c
 delete mode 100644 gnome-session/gdm-log.h
 delete mode 100644 gnome-session/gsm-app.c
 delete mode 100644 gnome-session/gsm-app.h
 delete mode 100644 gnome-session/gsm-autostart-app.c
 delete mode 100644 gnome-session/gsm-autostart-app.h
 delete mode 100644 gnome-session/gsm-client.c
 delete mode 100644 gnome-session/gsm-client.h
 delete mode 100644 gnome-session/gsm-consolekit.c
 delete mode 100644 gnome-session/gsm-consolekit.h
 delete mode 100644 gnome-session/gsm-dbus-client.c
 delete mode 100644 gnome-session/gsm-dbus-client.h
 delete mode 100644 gnome-session/gsm-fail-whale-dialog.c
 delete mode 100644 gnome-session/gsm-fail-whale-dialog.h
 delete mode 100644 gnome-session/gsm-fail-whale.c
 delete mode 100644 gnome-session/gsm-fail-whale.h
 delete mode 100644 gnome-session/gsm-icon-names.h
 delete mode 100644 gnome-session/gsm-inhibitor-flag.h
 delete mode 100644 gnome-session/gsm-inhibitor.c
 delete mode 100644 gnome-session/gsm-inhibitor.h
 delete mode 100644 gnome-session/gsm-manager-logout-mode.h
 delete mode 100644 gnome-session/gsm-manager.c
 delete mode 100644 gnome-session/gsm-manager.h
 delete mode 100644 gnome-session/gsm-presence-flag.h
 delete mode 100644 gnome-session/gsm-presence.c
 delete mode 100644 gnome-session/gsm-presence.h
 delete mode 100644 gnome-session/gsm-process-helper.c
 delete mode 100644 gnome-session/gsm-process-helper.h
 delete mode 100644 gnome-session/gsm-session-fill.c
 delete mode 100644 gnome-session/gsm-session-fill.h
 delete mode 100644 gnome-session/gsm-session-save.c
 delete mode 100644 gnome-session/gsm-session-save.h
 delete mode 100644 gnome-session/gsm-shell-extensions.c
 delete mode 100644 gnome-session/gsm-shell-extensions.h
 delete mode 100644 gnome-session/gsm-shell.c
 delete mode 100644 gnome-session/gsm-shell.h
 delete mode 100644 gnome-session/gsm-store.c
 delete mode 100644 gnome-session/gsm-store.h
 delete mode 100644 gnome-session/gsm-system.c
 delete mode 100644 gnome-session/gsm-system.h
 delete mode 100644 gnome-session/gsm-systemd.c
 delete mode 100644 gnome-session/gsm-systemd.h
 delete mode 100644 gnome-session/gsm-xsmp-client.c
 delete mode 100644 gnome-session/gsm-xsmp-client.h
 delete mode 100644 gnome-session/gsm-xsmp-server.c
 delete mode 100644 gnome-session/gsm-xsmp-server.h
 delete mode 100644 gnome-session/main.c
 delete mode 100644 gnome-session/org.gnome.SessionManager.App.xml
 delete mode 100644 gnome-session/org.gnome.SessionManager.Client.xml
 delete mode 100644 gnome-session/org.gnome.SessionManager.ClientPrivate.xml
 delete mode 100644 gnome-session/org.gnome.SessionManager.Inhibitor.xml
 delete mode 100644 gnome-session/org.gnome.SessionManager.Presence.xml
 delete mode 100644 gnome-session/org.gnome.SessionManager.xml
 delete mode 100644 gnome-session/test-client-dbus.c
 delete mode 100644 gnome-session/test-inhibit.c
 delete mode 100644 gnome-session/test-process-helper.c
 delete mode 100644 tools/Makefile.am
 delete mode 100644 tools/Makefile.in
 delete mode 100644 tools/gnome-session-check-accelerated-common.h
 delete mode 100644 tools/gnome-session-check-accelerated-helper.c
 delete mode 100644 tools/gnome-session-check-accelerated.c
 delete mode 100644 tools/gnome-session-custom-session
 delete mode 100644 tools/gnome-session-inhibit.c
 delete mode 100644 tools/gnome-session-quit.c
 delete mode 100644 tools/gnome-session-selector.c

diff --git a/Makefile.am b/Makefile.am
index 640aa58..db30a08 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,8 +1,6 @@
 SUBDIRS =			\
-	egg			\
 	gnome-session		\
 	capplet			\
-	tools			\
 	data			\
 	doc			\
 	po
diff --git a/capplet/Makefile.am b/capplet/Makefile.am
index c2e563c..943e4c4 100644
--- a/capplet/Makefile.am
+++ b/capplet/Makefile.am
@@ -2,7 +2,6 @@ bin_PROGRAMS = gnome-session-properties
 
 AM_CPPFLAGS =						\
 	$(SESSION_PROPERTIES_CFLAGS)			\
-	$(GCONF_CFLAGS)					\
 	-I$(top_srcdir)/gnome-session			\
 	-DLOCALE_DIR=\""$(datadir)/locale"\"		\
 	-DGTKBUILDER_DIR=\""$(pkgdatadir)"\"		\
@@ -25,7 +24,6 @@ gnome_session_properties_SOURCES =			\
 
 gnome_session_properties_LDADD =			\
 	$(SESSION_PROPERTIES_LIBS)			\
-	$(top_builddir)/gnome-session/libgsmutil.la 	\
-	$(GCONF_LIBS)
+	$(top_builddir)/gnome-session/libgsmutil.la
 
 -include $(top_srcdir)/git.mk
diff --git a/config.h.in b/config.h.in
index 18306f6..a846bd4 100644
--- a/config.h.in
+++ b/config.h.in
@@ -1,8 +1,5 @@
 /* config.h.in.  Generated from configure.ac by autoheader.  */
 
-/* Define if IPV6 is supported */
-#undef ENABLE_IPV6
-
 /* always defined to indicate that i18n is enabled */
 #undef ENABLE_NLS
 
@@ -18,12 +15,6 @@
 /* Define to 1 if you have the <dlfcn.h> header file. */
 #undef HAVE_DLFCN_H
 
-/* Define to 1 if you have the <execinfo.h> header file. */
-#undef HAVE_EXECINFO_H
-
-/* Define if we support gconf-based autostart */
-#undef HAVE_GCONF
-
 /* Define if the GNU gettext() function is already present or preinstalled. */
 #undef HAVE_GETTEXT
 
@@ -54,9 +45,6 @@
 /* Define to 1 if you have the <syslog.h> header file. */
 #undef HAVE_SYSLOG_H
 
-/* Define if systemd is used for session tracking */
-#undef HAVE_SYSTEMD
-
 /* Define to 1 if you have the <sys/param.h> header file. */
 #undef HAVE_SYS_PARAM_H
 
@@ -72,18 +60,6 @@
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
-/* Define to 1 if you have the <X11/Xtrans/Xtrans.h> header file. */
-#undef HAVE_X11_XTRANS_XTRANS_H
-
-/* Have the Render X extension */
-#undef HAVE_XRENDER
-
-/* Have the SYNC extension library */
-#undef HAVE_XSYNC
-
-/* Have the XTest extension library */
-#undef HAVE_XTEST
-
 /* Define to the sub-directory in which libtool stores uninstalled libraries.
    */
 #undef LT_OBJDIR
diff --git a/configure.ac b/configure.ac
index c95e960..6458301 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,4 +1,4 @@
-AC_INIT([gnome-session],
+AC_INIT([gnome-session-properties],
         [3.10.0],
         [http://bugzilla.gnome.org/enter_bug.cgi?product=gnome-session])
 
@@ -36,20 +36,6 @@ fi
 GLIB_REQUIRED=2.35.0
 GTK3_REQUIRED=2.90.7
 DBUS_GLIB_REQUIRED=0.76
-UPOWER_REQUIRED=0.9.0
-JSON_GLIB_REQUIRED=0.10
-GNOME_DESKTOP_REQUIRED=3.9.91
-
-AC_ARG_ENABLE(session-selector, AS_HELP_STRING([--enable-session-selector],
-                                               [enable building a custom session selector dialog]),
-                                                enable_session_selector=$enableval,enable_session_selector=no)
-
-AM_CONDITIONAL(BUILD_SESSION_SELECTOR,
-               [test "$enable_session_selector" = yes])
-
-if test "$enable_session_selector" = yes; then
-        PKG_CHECK_MODULES(SESSION_SELECTOR, gtk+-3.0 gio-2.0)
-fi
 
 dnl ====================================================================
 dnl Dependency Checks
@@ -57,16 +43,12 @@ dnl ====================================================================
 
 dnl Standard vertical stacks
 PKG_CHECK_MODULES(GIO, gio-2.0)
-PKG_CHECK_MODULES(GIOUNIX, gio-unix-2.0 >= $GLIB_REQUIRED)
 PKG_CHECK_MODULES(GTK3, gtk+-3.0 >= $GTK3_REQUIRED)
 
 PKG_CHECK_MODULES(GNOME_SESSION,
         glib-2.0 >= $GLIB_REQUIRED
         gio-2.0 >= $GLIB_REQUIRED
         dbus-glib-1 >= $DBUS_GLIB_REQUIRED
-        upower-glib >= $UPOWER_REQUIRED
-        json-glib-1.0 >= $JSON_GLIB_REQUIRED
-        gnome-desktop-3.0 >= $GNOME_DESKTOP_REQUIRED
 )
 
 PKG_CHECK_MODULES(SESSION_PROPERTIES,
@@ -74,113 +56,8 @@ PKG_CHECK_MODULES(SESSION_PROPERTIES,
         gtk+-3.0 >= $GTK3_REQUIRED
 )
 
-PKG_CHECK_MODULES(X11, x11)
-PKG_CHECK_MODULES(SM, sm)
-PKG_CHECK_MODULES(ICE, ice)
-PKG_CHECK_MODULES(XEXT, xext xau)
-
 PKG_CHECK_MODULES(DBUS_GLIB, dbus-glib-1 >= $DBUS_GLIB_REQUIRED)
 
-PKG_CHECK_MODULES(EGG_SMCLIENT, gtk+-3.0)
-
-PKG_CHECK_MODULES(GL_TEST, xcomposite gl glib-2.0)
-
-dnl ====================================================================
-dnl Check for gconf
-dnl ====================================================================
-AC_ARG_ENABLE([gconf],
-              AS_HELP_STRING([--enable-gconf], [Support gconf-based autostart]),
-              [enable_gconf=$enableval],
-              [enable_gconf=auto])
-
-PKG_CHECK_MODULES(GCONF, gconf-2.0, [have_gconf=yes], [have_gconf=no])
-
-if test x$enable_gconf = xauto ; then
-        enable_gconf=$have_gconf
-elif test x$enable_gconf = xyes -a x$have_gconf = xno ; then
-        AC_MSG_ERROR([GConf support explicitly required, but gconf not found])
-fi
-
-if test x$enable_gconf = xyes ; then
-        AC_DEFINE([HAVE_GCONF], [1], [Define if we support gconf-based autostart])
-fi
-
-dnl ====================================================================
-dnl Check for systemd
-dnl ====================================================================
-AC_ARG_ENABLE([systemd],
-              AS_HELP_STRING([--enable-systemd], [Use systemd]),
-              [enable_systemd=$enableval],
-              [enable_systemd=auto])
-
-PKG_CHECK_MODULES(SYSTEMD,
-                  [gio-unix-2.0 libsystemd-login >= 183 libsystemd-daemon libsystemd-journal],
-                  [have_systemd=yes], [have_systemd=no])
-
-AC_MSG_CHECKING([whether to use systemd])
-
-if test x$enable_systemd = xauto ; then
-        if test x$have_systemd = xno ; then
-                enable_systemd=no
-        else
-                enable_systemd=yes
-        fi
-fi
-
-AC_MSG_RESULT($enable_systemd)
-
-if test x$enable_systemd = xyes; then
-        if test x$have_systemd = xno; then
-                AC_MSG_ERROR([Systemd support explicitly required, but systemd not found])
-        fi
-        AC_DEFINE(HAVE_SYSTEMD, 1, [Define if systemd is used for session tracking])
-        session_tracking="systemd (with fallback to ConsoleKit)"
-else
-        session_tracking=ConsoleKit
-fi
-
-AC_SUBST(SYSTEMD_CFLAGS)
-AC_SUBST(SYSTEMD_LIBS)
-
-AM_CONDITIONAL(HAVE_SYSTEMD, [test "$enable_systemd" = "yes"], [Using systemd])
-
-dnl ====================================================================
-dnl Check for XSync extension
-dnl ====================================================================
-
-have_xsync=no
-AC_CHECK_HEADER(X11/extensions/sync.h, [have_xsync=yes],,
-                    [#include <X11/Xlib.h>])
-if test "$have_xsync" = yes; then
-  AC_DEFINE(HAVE_XSYNC, 1, [Have the SYNC extension library])
-fi
-
-dnl ====================================================================
-dnl Check for XTest extension
-dnl ====================================================================
-
-have_xtest=no
-PKG_CHECK_MODULES(XTEST, xtst, have_xtest=yes, have_xtest=no)
-if test "$have_xtest" = yes; then
-    AC_DEFINE(HAVE_XTEST, 1, [Have the XTest extension library])
-fi
-AC_SUBST(HAVE_XTEST)
-AC_SUBST(XTEST_CFLAGS)
-AC_SUBST(XTEST_LIBS)
-
-dnl ====================================================================
-dnl XRender checks
-dnl ====================================================================
-
-PKG_CHECK_MODULES(XRENDER, xrender, have_xrender=yes, have_xrender=no)
-AM_CONDITIONAL(HAVE_XRENDER, test x$have_xrender = xyes)
-if test $have_xrender=yes; then
-    AC_DEFINE(HAVE_XRENDER, 1, [Have the Render X extension])
-fi
-AC_SUBST(HAVE_XRENDER)
-AC_SUBST(XRENDER_CFLAGS)
-AC_SUBST(XRENDER_LIBS)
-
 dnl ====================================================================
 dnl - DocBook Documentation
 dnl ====================================================================
@@ -233,7 +110,7 @@ dnl Language Support
 dnl ====================================================================
 IT_PROG_INTLTOOL([0.40.6])
 
-GETTEXT_PACKAGE=gnome-session-3.0
+GETTEXT_PACKAGE=gnome-session-properties-3.0
 AC_DEFINE_UNQUOTED(GETTEXT_PACKAGE, "$GETTEXT_PACKAGE",
                    [The gettext translation domain])
 AC_SUBST(GETTEXT_PACKAGE)
@@ -247,82 +124,13 @@ dnl ====================================================================
 AC_HEADER_STDC
 AC_CHECK_HEADERS(syslog.h tcpd.h sys/param.h)
 
-dnl ====================================================================
-dnl check for backtrace support
-dnl ====================================================================
-
-AC_CHECK_HEADERS(execinfo.h)
-AC_CHECK_LIB(execinfo, backtrace, [have_backtrace="yes"], [have_backtrace="no"])
-EXECINFO_LIBS=""
-if test "x$have_backtrace" = "xyes"; then
-        EXECINFO_LIBS="-lexecinfo"
-fi
-AC_SUBST(EXECINFO_LIBS)
-
-dnl ====================================================================
-dnl Check for newish X interface
-dnl ====================================================================
-oCFLAGS="$CFLAGS"
-CFLAGS="$CFLAGS $X_CFLAGS"
-AC_CHECK_HEADERS(X11/Xtrans/Xtrans.h)
-CFLAGS="$oCFLAGS"
-
-dnl ====================================================================
-dnl Code for checking whether IPv6 is enabled on the system....
-dnl ====================================================================
-AC_MSG_CHECKING([whether to enable ipv6])
-AC_ARG_ENABLE(ipv6,
-              [AS_HELP_STRING([--enable-ipv6],
-                              [enable IPv6 extensions])],,
-              [enable_ipv6=yes])
-have_full_ipv6=no
-if test $enable_ipv6 = yes; then
-
-  dnl ====================================================================
-  dnl Code for checking presence of AF_INET6 on the system....
-  dnl ====================================================================
-  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-    #include <sys/types.h>
-    #include <sys/socket.h>]], [[
-    socket(AF_INET6, SOCK_STREAM, 0)
-    ]])],
-    [have_ipv6=yes],
-    [have_ipv6=no]
-  )
-  AC_MSG_RESULT($have_ipv6)
-
-  dnl =================================================================
-  dnl Now we would check for specific function like getaddrinfo.
-  dnl =================================================================
-  have_getaddrinfo=no
-  if test $have_ipv6=yes; then
-    AC_CHECK_FUNC(getaddrinfo, have_getaddrinfo=yes)
-    if test $have_getaddrinfo != yes; then
-      # getaddrinfo is not in the default libraries.  See if it's in some other.
-      for lib in bsd socket inet; do
-        AC_CHECK_LIB($lib, getaddrinfo, [LIBS="$LIBS -l$lib";have_getaddrinfo=yes; break])
-      done
-    fi
-    if test $have_getaddrinfo=yes; then
-      AC_DEFINE(ENABLE_IPV6, 1, [Define if IPV6 is supported])
-      have_full_ipv6=yes
-    fi
-  fi
-fi
-dnl ==============================================================================
-dnl End of IPv6 checks
-dnl ==============================================================================
-
 AC_CONFIG_FILES([
 Makefile
 capplet/Makefile
 doc/Makefile
-doc/dbus/Makefile
-doc/dbus/gnome-session.xml
 doc/man/Makefile
 data/Makefile
 data/gnome-session-properties.desktop.in
-data/org.gnome.SessionManager.gschema.xml
 data/icons/Makefile
 data/icons/16x16/Makefile
 data/icons/22x22/Makefile
@@ -330,9 +138,7 @@ data/icons/24x24/Makefile
 data/icons/32x32/Makefile
 data/icons/48x48/Makefile
 data/icons/scalable/Makefile
-egg/Makefile
 gnome-session/Makefile
-tools/Makefile
 po/Makefile.in
 ])
 AC_OUTPUT
@@ -342,8 +148,8 @@ dnl - Show summary
 dnl ---------------------------------------------------------------------------
 
 echo "
-              gnome-session $VERSION
-              `echo gnome-session $VERSION | sed "s/./=/g"`
+              gnome-session-properties $VERSION
+              `echo gnome-session-properties $VERSION | sed "s/./=/g"`
 
         prefix:                   ${prefix}
         exec_prefix:              ${exec_prefix}
@@ -359,13 +165,6 @@ echo "
         Maintainer mode:          ${USE_MAINTAINER_MODE}
         Use *_DISABLE_DEPRECATED: ${enable_deprecation_flags}
 
-        GConf support:            ${enable_gconf}
-        Session tracking:         ${session_tracking}
-        IPv6 support:             ${have_full_ipv6}
-        Backtrace support:        ${have_backtrace}
-        XRender support:          ${have_xrender}
-        XSync support:            ${have_xsync}
-        XTest support:            ${have_xtest}
         Build Docbook:            ${enable_docbook_docs}
         Build manpages:           ${enable_man}
 
diff --git a/data/Makefile.am b/data/Makefile.am
index 524cc6e..3da6614 100644
--- a/data/Makefile.am
+++ b/data/Makefile.am
@@ -4,71 +4,20 @@ uidir = $(pkgdatadir)
 ui_DATA = \
 	session-properties.ui
 
-if BUILD_SESSION_SELECTOR
-ui_DATA += session-selector.ui
-endif
-
-hwcompatdir = $(pkgdatadir)
-hwcompat_DATA = hardware-compatibility
-
-xsessiondir = $(datadir)/xsessions
-xsession_in_files = gnome.desktop.in
-
-if BUILD_SESSION_SELECTOR
-xsession_in_files += gnome-custom-session.desktop.in
-endif
-
-xsession_DATA = $(xsession_in_files:.desktop.in=.desktop)
-
-wayland_sessiondir = $(datadir)/wayland-sessions
-wayland_session_in_files = gnome-wayland.desktop.in
-wayland_session_DATA = $(wayland_session_in_files:.desktop.in=.desktop)
-
 desktopdir = $(datadir)/applications
 desktop_in_files = gnome-session-properties.desktop.in
 desktop_DATA = $(desktop_in_files:.desktop.in=.desktop)
 
-sessiondir = $(datadir)/gnome-session/sessions
-session_in_in_files = gnome.session.desktop.in.in gnome-dummy.session.desktop.in.in gnome-wayland.session.desktop.in.in
-session_in_files = $(session_in_in_files:.session.desktop.in.in=.session.desktop.in)
-session_DATA = $(session_in_files:.session.desktop.in=.session)
-
-%.session.desktop.in: %.session.desktop.in.in Makefile
-	$(AM_V_GEN)sed \
-		-e "s|\@LIBEXECDIR\@|$(libexecdir)|" \
-		$< > $@
-
-%.session: %.session.desktop.in   $(INTLTOOL_MERGE) $(wildcard $(top_srcdir)/po/*.po) ; LC_ALL=C $(INTLTOOL_MERGE) -d -u -c $(top_builddir)/po/.intltool-merge-cache $(top_srcdir)/po $< $@
-
 @INTLTOOL_DESKTOP_RULE@
 @INTLTOOL_XML_NOMERGE_RULE@
 
-gsettings_SCHEMAS = org.gnome.SessionManager.gschema.xml
-@GSETTINGS_RULES@
-
-migrationdir = $(datadir)/GConf/gsettings
-dist_migration_DATA = gnome-session.convert
-
 EXTRA_DIST =					\
-	$(xsession_in_files)			\
-	$(session_in_in_files)			\
-	$(wayland_session_in_files)		\
-	$(gsettings_SCHEMAS:.xml=.xml.in)	\
-	session-selector.ui			\
-	gnome-custom-session.desktop.in		\
-	$(ui_DATA)				\
-	$(hwcompat_DATA)
+	$(ui_DATA)
 
 CLEANFILES =					\
-	$(gsettings_SCHEMAS)			\
-	$(xsession_DATA)			\
-	$(wayland_session_DATA)			\
-	$(desktop_DATA)				\
-	$(session_DATA)
+	$(desktop_DATA)
 
 DISTCLEANFILES =				\
-	$(gsettings_SCHEMAS)			\
-	$(desktop_in_files)			\
-	$(wayland_session_in_files)
+	$(desktop_in_files)
 
 -include $(top_srcdir)/git.mk
diff --git a/data/gnome-custom-session.desktop.in b/data/gnome-custom-session.desktop.in
deleted file mode 100644
index ae36952..0000000
--- a/data/gnome-custom-session.desktop.in
+++ /dev/null
@@ -1,5 +0,0 @@
-[Desktop Entry]
-_Name=Custom
-_Comment=This entry lets you select a saved session
-Exec=gnome-session-custom-session
-TryExec=gnome-session-custom-session
diff --git a/data/gnome-dummy.session.desktop.in.in b/data/gnome-dummy.session.desktop.in.in
deleted file mode 100644
index f5a6d80..0000000
--- a/data/gnome-dummy.session.desktop.in.in
+++ /dev/null
@@ -1,2 +0,0 @@
-[GNOME Session]
-_Name=GNOME dummy
diff --git a/data/gnome-session.convert b/data/gnome-session.convert
deleted file mode 100644
index fd4dfab..0000000
--- a/data/gnome-session.convert
+++ /dev/null
@@ -1,3 +0,0 @@
-[org.gnome.SessionManager]
-auto-save-session = /apps/gnome-session/options/auto_save_session
-logout-prompt = /apps/gnome-session/options/logout_prompt
diff --git a/data/gnome-wayland.desktop.in b/data/gnome-wayland.desktop.in
deleted file mode 100644
index 5757902..0000000
--- a/data/gnome-wayland.desktop.in
+++ /dev/null
@@ -1,8 +0,0 @@
-[Desktop Entry]
-_Name=GNOME on Wayland
-_Comment=This session logs you into GNOME, using Wayland
-Exec=gnome-session --session=gnome-wayland
-TryExec=gnome-session
-Icon=
-Type=Application
-X-GDM-NeedsVT=true
diff --git a/data/gnome-wayland.session.desktop.in.in b/data/gnome-wayland.session.desktop.in.in
deleted file mode 100644
index 1c667d8..0000000
--- a/data/gnome-wayland.session.desktop.in.in
+++ /dev/null
@@ -1,3 +0,0 @@
-[GNOME Session]
-_Name=GNOME on Wayland
-RequiredComponents=gnome-shell-wayland;gnome-settings-daemon;
diff --git a/data/gnome.desktop.in b/data/gnome.desktop.in
deleted file mode 100644
index 8edd433..0000000
--- a/data/gnome.desktop.in
+++ /dev/null
@@ -1,7 +0,0 @@
-[Desktop Entry]
-_Name=GNOME
-_Comment=This session logs you into GNOME
-Exec=gnome-session
-TryExec=gnome-session
-Icon=
-Type=Application
diff --git a/data/gnome.session.desktop.in.in b/data/gnome.session.desktop.in.in
deleted file mode 100644
index dc8c57c..0000000
--- a/data/gnome.session.desktop.in.in
+++ /dev/null
@@ -1,3 +0,0 @@
-[GNOME Session]
-_Name=GNOME
-RequiredComponents=gnome-shell;gnome-settings-daemon;
diff --git a/data/hardware-compatibility b/data/hardware-compatibility
deleted file mode 100644
index 927ba8b..0000000
--- a/data/hardware-compatibility
+++ /dev/null
@@ -1,29 +0,0 @@
-##
-## This file contains a list of blacklist/whitelist regular expressions for
-## renderer strings.
-##
-## The regular expressions are case-insensitive POSIX Extended Regular
-## Expressions. See regex(7) for details.
-##
-## Syntax:
-##  - Comment lines start with '#'
-##  - Lines starting with '+' are whitelisting.
-##  - Lines starting with '-' are blacklisting.
-##  - Lines not starting with '#', '+', '-' are ignored.
-##
-
-# Intel 830-865
--Intel\(R\) 8[[:digit:]]{2,2}[^[:digit:]]
-
-# Intel IGD 
--Intel IGD
-
-# Pre-R300 radeon
--Mesa DRI R[12]00[^[:digit:]]
--Mesa DRI R[12]00$
-
-# Old Mesa software GL renderer
--software rasterizer
-
-# Gallium has softpipe; we explicitly enable llvmpipe
--softpipe
diff --git a/data/org.gnome.SessionManager.gschema.xml.in b/data/org.gnome.SessionManager.gschema.xml.in
deleted file mode 100644
index b2b220d..0000000
--- a/data/org.gnome.SessionManager.gschema.xml.in
+++ /dev/null
@@ -1,24 +0,0 @@
-<schemalist gettext-domain="gnome-session-3.0">
-  <schema id="org.gnome.SessionManager" path="/org/gnome/gnome-session/">
-    <key name="auto-save-session" type="b">
-      <default>false</default>
-      <summary>Save sessions</summary>
-      <description>If enabled, gnome-session will save the session automatically.</description>
-    </key>
-    <key name="auto-save-session-one-shot" type="b">
-      <default>false</default>
-      <summary>Save this session</summary>
-      <description>When enabled, gnome-session will automatically save the next session at log out even if auto saving is disabled.</description>
-    </key>
-    <key name="logout-prompt" type="b">
-      <default>true</default>
-      <summary>Logout prompt</summary>
-      <description>If enabled, gnome-session will prompt the user before ending a session.</description>
-    </key>
-    <key name="show-fallback-warning" type="b">
-      <default>true</default>
-      <summary>Show the fallback warning</summary>
-      <description>If enabled, gnome-session will display a warning dialog after login if the session was automatically fallen back.</description>
-    </key>
-  </schema>
-</schemalist>
diff --git a/data/session-selector.ui b/data/session-selector.ui
deleted file mode 100644
index 1c55712..0000000
--- a/data/session-selector.ui
+++ /dev/null
@@ -1,195 +0,0 @@
-<?xml version="1.0"?>
-<interface>
-  <requires lib="gtk+" version="2.16"/>
-  <!-- interface-naming-policy project-wide -->
-  <object class="GtkListStore" id="session-store">
-    <columns>
-      <!-- column-name name -->
-      <column type="gchararray"/>
-    </columns>
-  </object>
-  <object class="GtkTreeModelSort" id="sort-model">
-    <property name="model">session-store</property>
-  </object>
-  <object class="GtkWindow" id="main-window">
-    <property name="title" translatable="yes">Custom Session</property>
-    <property name="window_position">center</property>
-    <property name="default_width">500</property>
-    <property name="default_height">310</property>
-    <property name="decorated">False</property>
-    <child>
-      <object class="GtkFrame" id="frame1">
-        <property name="visible">True</property>
-        <property name="label_xalign">0.5</property>
-        <property name="shadow_type">out</property>
-        <child>
-          <object class="GtkAlignment" id="alignment3">
-            <property name="visible">True</property>
-            <property name="border_width">12</property>
-            <child>
-              <object class="GtkVBox" id="vbox3">
-                <property name="visible">True</property>
-                <property name="orientation">vertical</property>
-                <property name="spacing">6</property>
-
-                <child>
-                  <object class="GtkInfoBar" id="info-bar">
-                    <property name="visible">True</property>
-                    <property name="message-type">other</property>
-
-                    <child internal-child="content_area">
-                      <object class="GtkHBox" id="info-bar-content_area">
-                        <property name="visible">True</property>
-                        <property name="orientation">vertical</property>
-                        <property name="spacing">0</property>
-                        <child>
-                          <object class="GtkLabel" id="info-label">
-                            <property name="visible">True</property>
-                            <property name="xalign">0.0</property>
-                            <property name="yalign">0.5</property>
-                            <property name="label" translatable="yes">Please select a custom session to run</property>
-                          </object>
-                          <packing>
-                            <property name="expand">True</property>
-                            <property name="fill">True</property>
-                            <property name="position">0</property>
-                          </packing>
-                        </child>
-                      </object>
-                    </child>
-                  </object>
-                  <packing>
-                    <property name="expand">False</property>
-                    <property name="fill">True</property>
-                    <property name="position">0</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkVBox" id="vbox4">
-                    <property name="visible">True</property>
-                    <property name="orientation">vertical</property>
-                    <property name="spacing">12</property>
-                    <child>
-                      <object class="GtkHBox" id="hbox3">
-                        <property name="visible">True</property>
-                        <property name="spacing">12</property>
-                        <child>
-                          <object class="GtkScrolledWindow" id="scrolledwindow2">
-                            <property name="visible">True</property>
-                            <property name="can_focus">True</property>
-                            <property name="hscrollbar_policy">never</property>
-                            <property name="vscrollbar_policy">automatic</property>
-                            <property name="shadow_type">in</property>
-                            <child>
-                              <object class="GtkTreeView" id="session-list">
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="headers_visible">False</property>
-                                <property name="search_column">0</property>
-                                <property name="model">sort-model</property>
-                              </object>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="position">0</property>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkVButtonBox" id="vbuttonbox2">
-                            <property name="visible">True</property>
-                            <property name="orientation">vertical</property>
-                            <property name="spacing">6</property>
-                            <property name="layout_style">start</property>
-                            <child>
-                              <object class="GtkButton" id="new-session">
-                                <property name="label" translatable="yes">_New Session</property>
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="receives_default">True</property>
-                                <property name="use_underline">True</property>
-                              </object>
-                              <packing>
-                                <property name="expand">False</property>
-                                <property name="fill">False</property>
-                                <property name="position">0</property>
-                              </packing>
-                            </child>
-                            <child>
-                              <object class="GtkButton" id="remove-session">
-                                <property name="label" translatable="yes">_Remove Session</property>
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="receives_default">True</property>
-                                <property name="use_underline">True</property>
-                              </object>
-                              <packing>
-                                <property name="expand">False</property>
-                                <property name="fill">False</property>
-                                <property name="position">1</property>
-                              </packing>
-                            </child>
-                            <child>
-                              <object class="GtkButton" id="rename-session">
-                                <property name="label" translatable="yes">Rena_me Session</property>
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="receives_default">True</property>
-                                <property name="use_underline">True</property>
-                              </object>
-                              <packing>
-                                <property name="expand">False</property>
-                                <property name="fill">False</property>
-                                <property name="position">2</property>
-                              </packing>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="expand">False</property>
-                            <property name="position">1</property>
-                          </packing>
-                        </child>
-                      </object>
-                      <packing>
-                        <property name="position">1</property>
-                      </packing>
-                    </child>
-                  </object>
-                  <packing>
-                    <property name="position">1</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkHButtonBox" id="hbuttonbox2">
-                    <property name="visible">True</property>
-                    <property name="spacing">6</property>
-                    <property name="layout_style">end</property>
-                    <child>
-                      <object class="GtkButton" id="continue-button">
-                        <property name="label" translatable="yes">_Continue</property>
-                        <property name="visible">True</property>
-                        <property name="can_focus">True</property>
-                        <property name="can_default">True</property>
-                        <property name="has_default">True</property>
-                        <property name="receives_default">True</property>
-                        <property name="use_underline">True</property>
-                      </object>
-                      <packing>
-                        <property name="expand">False</property>
-                        <property name="fill">False</property>
-                        <property name="position">0</property>
-                      </packing>
-                    </child>
-                  </object>
-                  <packing>
-                    <property name="expand">False</property>
-                    <property name="position">2</property>
-                  </packing>
-                </child>
-              </object>
-            </child>
-          </object>
-        </child>
-      </object>
-    </child>
-  </object>
-</interface>
diff --git a/doc/Makefile.am b/doc/Makefile.am
index 1129c41..2df8bb4 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,7 +1,5 @@
-SUBDIRS = dbus
-
 if ENABLE_MAN
-SUBDIRS += man
+SUBDIRS = man
 endif
 
 -include $(top_srcdir)/git.mk
diff --git a/doc/dbus/Makefile.am b/doc/dbus/Makefile.am
deleted file mode 100644
index aedb24c..0000000
--- a/doc/dbus/Makefile.am
+++ /dev/null
@@ -1,48 +0,0 @@
-SPEC_XML_FILES =					\
-	gnome-session.xml				\
-	org.gnome.SessionManager.ref.xml		\
-	org.gnome.SessionManager.Client.ref.xml		\
-	org.gnome.SessionManager.ClientPrivate.ref.xml	\
-	org.gnome.SessionManager.Inhibitor.ref.xml	\
-	org.gnome.SessionManager.Presence.ref.xml
-
-if DOCBOOK_DOCS_ENABLED
-
-htmldocdir = $(docdir)/dbus
-htmldoc_DATA = gnome-session.html
-
-gnome-session.html: $(SPEC_XML_FILES)
-	$(AM_V_GEN)$(XMLTO) xhtml-nochunks -m $(top_srcdir)/doc/dbus/config.xsl gnome-session.xml
-
-endif # DOCBOOK_DOCS_ENABLED
-
-org.gnome.SessionManager.ref.xml: $(top_srcdir)/gnome-session/org.gnome.SessionManager.xml spec-to-docbook.xsl
-	$(AM_V_GEN)$(XSLTPROC) $(top_srcdir)/doc/dbus/spec-to-docbook.xsl $< | tail -n +2 > $@
-org.gnome.SessionManager.Client.ref.xml: $(top_srcdir)/gnome-session/org.gnome.SessionManager.Client.xml spec-to-docbook.xsl
-	$(AM_V_GEN)$(XSLTPROC) $(top_srcdir)/doc/dbus/spec-to-docbook.xsl $< | tail -n +2 > $@
-org.gnome.SessionManager.ClientPrivate.ref.xml: $(top_srcdir)/gnome-session/org.gnome.SessionManager.ClientPrivate.xml spec-to-docbook.xsl
-	$(AM_V_GEN)$(XSLTPROC) $(top_srcdir)/doc/dbus/spec-to-docbook.xsl $< | tail -n +2 > $@
-org.gnome.SessionManager.Inhibitor.ref.xml: $(top_srcdir)/gnome-session/org.gnome.SessionManager.Inhibitor.xml spec-to-docbook.xsl
-	$(AM_V_GEN)$(XSLTPROC) $(top_srcdir)/doc/dbus/spec-to-docbook.xsl $< | tail -n +2 > $@
-org.gnome.SessionManager.Presence.ref.xml: $(top_srcdir)/gnome-session/org.gnome.SessionManager.Presence.xml spec-to-docbook.xsl
-	$(AM_V_GEN)$(XSLTPROC) $(top_srcdir)/doc/dbus/spec-to-docbook.xsl $< | tail -n +2 > $@
-
-BUILT_SOURCES =	\
-	org.gnome.SessionManager.ref.xml \
-	org.gnome.SessionManager.Client.ref.xml \
-	org.gnome.SessionManager.ClientPrivate.ref.xml \
-	org.gnome.SessionManager.Inhibitor.ref.xml \
-	org.gnome.SessionManager.Presence.ref.xml
-
-CLEANFILES =				\
-	$(BUILT_SOURCES)		\
-	$(htmldoc_DATA)
-
-EXTRA_DIST =				\
-	gnome-session.xml.in		\
-	config.xsl			\
-	docbook.css			\
-	dbus-introspect-docs.dtd	\
-	spec-to-docbook.xsl
-
--include $(top_srcdir)/git.mk
diff --git a/doc/dbus/Makefile.in b/doc/dbus/Makefile.in
deleted file mode 100644
index ecd4e39..0000000
--- a/doc/dbus/Makefile.in
+++ /dev/null
@@ -1,607 +0,0 @@
-# Makefile.in generated by automake 1.13.4 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
-
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-@SET_MAKE@
-
-VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
-am__make_running_with_option = \
-  case $${target_option-} in \
-      ?) ;; \
-      *) echo "am__make_running_with_option: internal error: invalid" \
-              "target option '$${target_option-}' specified" >&2; \
-         exit 1;; \
-  esac; \
-  has_opt=no; \
-  sane_makeflags=$$MAKEFLAGS; \
-  if $(am__is_gnu_make); then \
-    sane_makeflags=$$MFLAGS; \
-  else \
-    case $$MAKEFLAGS in \
-      *\\[\ \	]*) \
-        bs=\\; \
-        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
-          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
-    esac; \
-  fi; \
-  skip_next=no; \
-  strip_trailopt () \
-  { \
-    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
-  }; \
-  for flg in $$sane_makeflags; do \
-    test $$skip_next = yes && { skip_next=no; continue; }; \
-    case $$flg in \
-      *=*|--*) continue;; \
-        -*I) strip_trailopt 'I'; skip_next=yes;; \
-      -*I?*) strip_trailopt 'I';; \
-        -*O) strip_trailopt 'O'; skip_next=yes;; \
-      -*O?*) strip_trailopt 'O';; \
-        -*l) strip_trailopt 'l'; skip_next=yes;; \
-      -*l?*) strip_trailopt 'l';; \
-      -[dEDm]) skip_next=yes;; \
-      -[JT]) skip_next=yes;; \
-    esac; \
-    case $$flg in \
-      *$$target_option*) has_opt=yes; break;; \
-    esac; \
-  done; \
-  test $$has_opt = yes
-am__make_dryrun = (target_option=n; $(am__make_running_with_option))
-am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
-pkgdatadir = $(datadir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkglibexecdir = $(libexecdir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-subdir = doc/dbus
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
-	$(srcdir)/gnome-session.xml.in
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/intltool.m4 \
-	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
-	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
-	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES = gnome-session.xml
-CONFIG_CLEAN_VPATH_FILES =
-AM_V_P = $(am__v_P_@AM_V@)
-am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
-am__v_P_0 = false
-am__v_P_1 = :
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN     " $@;
-am__v_GEN_1 = 
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
-am__v_at_1 = 
-SOURCES =
-DIST_SOURCES =
-am__can_run_installinfo = \
-  case $$AM_UPDATE_INFO_DIR in \
-    n|no|NO) false;; \
-    *) (install-info --version) >/dev/null 2>&1;; \
-  esac
-am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
-am__vpath_adj = case $$p in \
-    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
-    *) f=$$p;; \
-  esac;
-am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
-am__install_max = 40
-am__nobase_strip_setup = \
-  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
-am__nobase_strip = \
-  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
-am__nobase_list = $(am__nobase_strip_setup); \
-  for p in $$list; do echo "$$p $$p"; done | \
-  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
-  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
-    if (++n[$$2] == $(am__install_max)) \
-      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
-    END { for (dir in files) print dir, files[dir] }'
-am__base_list = \
-  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
-  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
-am__uninstall_files_from_dir = { \
-  test -z "$$files" \
-    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
-    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
-         $(am__cd) "$$dir" && rm -f $$files; }; \
-  }
-am__installdirs = "$(DESTDIR)$(htmldocdir)"
-DATA = $(htmldoc_DATA)
-am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = @ACLOCAL@
-ALL_LINGUAS = @ALL_LINGUAS@
-AMTAR = @AMTAR@
-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
-AR = @AR@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CATALOGS = @CATALOGS@
-CATOBJEXT = @CATOBJEXT@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFLAGS = @CFLAGS@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DATADIRNAME = @DATADIRNAME@
-DBUS_GLIB_CFLAGS = @DBUS_GLIB_CFLAGS@
-DBUS_GLIB_LIBS = @DBUS_GLIB_LIBS@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DISABLE_DEPRECATED = @DISABLE_DEPRECATED@
-DISABLE_DEPRECATED_CFLAGS = @DISABLE_DEPRECATED_CFLAGS@
-DLLTOOL = @DLLTOOL@
-DSYMUTIL = @DSYMUTIL@
-DUMPBIN = @DUMPBIN@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGG_SMCLIENT_CFLAGS = @EGG_SMCLIENT_CFLAGS@
-EGG_SMCLIENT_LIBS = @EGG_SMCLIENT_LIBS@
-EGREP = @EGREP@
-EXECINFO_LIBS = @EXECINFO_LIBS@
-EXEEXT = @EXEEXT@
-FGREP = @FGREP@
-GCONF_CFLAGS = @GCONF_CFLAGS@
-GCONF_LIBS = @GCONF_LIBS@
-GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
-GIOUNIX_CFLAGS = @GIOUNIX_CFLAGS@
-GIOUNIX_LIBS = @GIOUNIX_LIBS@
-GIO_CFLAGS = @GIO_CFLAGS@
-GIO_LIBS = @GIO_LIBS@
-GLIB_COMPILE_SCHEMAS = @GLIB_COMPILE_SCHEMAS@
-GLIB_GENMARSHAL = @GLIB_GENMARSHAL@
-GL_TEST_CFLAGS = @GL_TEST_CFLAGS@
-GL_TEST_LIBS = @GL_TEST_LIBS@
-GMOFILES = @GMOFILES@
-GMSGFMT = @GMSGFMT@
-GNOME_SESSION_CFLAGS = @GNOME_SESSION_CFLAGS@
-GNOME_SESSION_LIBS = @GNOME_SESSION_LIBS@
-GREP = @GREP@
-GSETTINGS_DISABLE_SCHEMAS_COMPILE = @GSETTINGS_DISABLE_SCHEMAS_COMPILE@
-GTK3_CFLAGS = @GTK3_CFLAGS@
-GTK3_LIBS = @GTK3_LIBS@
-HAVE_XRENDER = @HAVE_XRENDER@
-HAVE_XTEST = @HAVE_XTEST@
-ICE_CFLAGS = @ICE_CFLAGS@
-ICE_LIBS = @ICE_LIBS@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-INSTOBJEXT = @INSTOBJEXT@
-INTLLIBS = @INTLLIBS@
-INTLTOOL_EXTRACT = @INTLTOOL_EXTRACT@
-INTLTOOL_MERGE = @INTLTOOL_MERGE@
-INTLTOOL_PERL = @INTLTOOL_PERL@
-INTLTOOL_UPDATE = @INTLTOOL_UPDATE@
-INTLTOOL_V_MERGE = @INTLTOOL_V_MERGE@
-INTLTOOL_V_MERGE_OPTIONS = @INTLTOOL_V_MERGE_OPTIONS@
-INTLTOOL__v_MERGE_ = @INTLTOOL__v_MERGE_@
-INTLTOOL__v_MERGE_0 = @INTLTOOL__v_MERGE_0@
-LD = @LD@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LIPO = @LIPO@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAINT = @MAINT@
-MAKEINFO = @MAKEINFO@
-MANIFEST_TOOL = @MANIFEST_TOOL@
-MKDIR_P = @MKDIR_P@
-MKINSTALLDIRS = @MKINSTALLDIRS@
-MSGFMT = @MSGFMT@
-MSGFMT_OPTS = @MSGFMT_OPTS@
-MSGMERGE = @MSGMERGE@
-NM = @NM@
-NMEDIT = @NMEDIT@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-OTOOL = @OTOOL@
-OTOOL64 = @OTOOL64@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_URL = @PACKAGE_URL@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PKG_CONFIG = @PKG_CONFIG@
-PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
-PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
-POFILES = @POFILES@
-POSUB = @POSUB@
-PO_IN_DATADIR_FALSE = @PO_IN_DATADIR_FALSE@
-PO_IN_DATADIR_TRUE = @PO_IN_DATADIR_TRUE@
-RANLIB = @RANLIB@
-SED = @SED@
-SESSION_PROPERTIES_CFLAGS = @SESSION_PROPERTIES_CFLAGS@
-SESSION_PROPERTIES_LIBS = @SESSION_PROPERTIES_LIBS@
-SESSION_SELECTOR_CFLAGS = @SESSION_SELECTOR_CFLAGS@
-SESSION_SELECTOR_LIBS = @SESSION_SELECTOR_LIBS@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-SM_CFLAGS = @SM_CFLAGS@
-SM_LIBS = @SM_LIBS@
-STRIP = @STRIP@
-SYSTEMD_CFLAGS = @SYSTEMD_CFLAGS@
-SYSTEMD_LIBS = @SYSTEMD_LIBS@
-USE_NLS = @USE_NLS@
-VERSION = @VERSION@
-WARN_CFLAGS = @WARN_CFLAGS@
-X11_CFLAGS = @X11_CFLAGS@
-X11_LIBS = @X11_LIBS@
-XEXT_CFLAGS = @XEXT_CFLAGS@
-XEXT_LIBS = @XEXT_LIBS@
-XGETTEXT = @XGETTEXT@
-XMLTO = @XMLTO@
-XRENDER_CFLAGS = @XRENDER_CFLAGS@
-XRENDER_LIBS = @XRENDER_LIBS@
-XSLTPROC = @XSLTPROC@
-XTEST_CFLAGS = @XTEST_CFLAGS@
-XTEST_LIBS = @XTEST_LIBS@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_AR = @ac_ct_AR@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-gsettingsschemadir = @gsettingsschemadir@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-intltool__v_merge_options_ = @intltool__v_merge_options_@
-intltool__v_merge_options_0 = @intltool__v_merge_options_0@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target_alias = @target_alias@
-top_build_prefix = @top_build_prefix@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-SPEC_XML_FILES = \
-	gnome-session.xml				\
-	org.gnome.SessionManager.ref.xml		\
-	org.gnome.SessionManager.Client.ref.xml		\
-	org.gnome.SessionManager.ClientPrivate.ref.xml	\
-	org.gnome.SessionManager.Inhibitor.ref.xml	\
-	org.gnome.SessionManager.Presence.ref.xml
-
-@DOCBOOK_DOCS_ENABLED_TRUE@htmldocdir = $(docdir)/dbus
-@DOCBOOK_DOCS_ENABLED_TRUE@htmldoc_DATA = gnome-session.html
-BUILT_SOURCES = \
-	org.gnome.SessionManager.ref.xml \
-	org.gnome.SessionManager.Client.ref.xml \
-	org.gnome.SessionManager.ClientPrivate.ref.xml \
-	org.gnome.SessionManager.Inhibitor.ref.xml \
-	org.gnome.SessionManager.Presence.ref.xml
-
-CLEANFILES = \
-	$(BUILT_SOURCES)		\
-	$(htmldoc_DATA)
-
-EXTRA_DIST = \
-	gnome-session.xml.in		\
-	config.xsl			\
-	docbook.css			\
-	dbus-introspect-docs.dtd	\
-	spec-to-docbook.xsl
-
-all: $(BUILT_SOURCES)
-	$(MAKE) $(AM_MAKEFLAGS) all-am
-
-.SUFFIXES:
-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
-	        && { if test -f $@; then exit 0; else break; fi; }; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu doc/dbus/Makefile'; \
-	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --gnu doc/dbus/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(am__aclocal_m4_deps):
-gnome-session.xml: $(top_builddir)/config.status $(srcdir)/gnome-session.xml.in
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-install-htmldocDATA: $(htmldoc_DATA)
-	@$(NORMAL_INSTALL)
-	@list='$(htmldoc_DATA)'; test -n "$(htmldocdir)" || list=; \
-	if test -n "$$list"; then \
-	  echo " $(MKDIR_P) '$(DESTDIR)$(htmldocdir)'"; \
-	  $(MKDIR_P) "$(DESTDIR)$(htmldocdir)" || exit 1; \
-	fi; \
-	for p in $$list; do \
-	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
-	  echo "$$d$$p"; \
-	done | $(am__base_list) | \
-	while read files; do \
-	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(htmldocdir)'"; \
-	  $(INSTALL_DATA) $$files "$(DESTDIR)$(htmldocdir)" || exit $$?; \
-	done
-
-uninstall-htmldocDATA:
-	@$(NORMAL_UNINSTALL)
-	@list='$(htmldoc_DATA)'; test -n "$(htmldocdir)" || list=; \
-	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	dir='$(DESTDIR)$(htmldocdir)'; $(am__uninstall_files_from_dir)
-tags TAGS:
-
-ctags CTAGS:
-
-cscope cscopelist:
-
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
-	    if test -d "$(distdir)/$$file"; then \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
-	  else \
-	    test -f "$(distdir)/$$file" \
-	    || cp -p $$d/$$file "$(distdir)/$$file" \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: $(BUILT_SOURCES)
-	$(MAKE) $(AM_MAKEFLAGS) check-am
-all-am: Makefile $(DATA)
-installdirs:
-	for dir in "$(DESTDIR)$(htmldocdir)"; do \
-	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
-	done
-install: $(BUILT_SOURCES)
-	$(MAKE) $(AM_MAKEFLAGS) install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	if test -z '$(STRIP)'; then \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	      install; \
-	else \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
-	fi
-mostlyclean-generic:
-
-clean-generic:
-	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
-clean: clean-am
-
-clean-am: clean-generic clean-libtool mostlyclean-am
-
-distclean: distclean-am
-	-rm -f Makefile
-distclean-am: clean-am distclean-generic
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-html-am:
-
-info: info-am
-
-info-am:
-
-install-data-am: install-htmldocDATA
-
-install-dvi: install-dvi-am
-
-install-dvi-am:
-
-install-exec-am:
-
-install-html: install-html-am
-
-install-html-am:
-
-install-info: install-info-am
-
-install-info-am:
-
-install-man:
-
-install-pdf: install-pdf-am
-
-install-pdf-am:
-
-install-ps: install-ps-am
-
-install-ps-am:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-generic mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am: uninstall-htmldocDATA
-
-.MAKE: all check install install-am install-strip
-
-.PHONY: all all-am check check-am clean clean-generic clean-libtool \
-	cscopelist-am ctags-am distclean distclean-generic \
-	distclean-libtool distdir dvi dvi-am html html-am info info-am \
-	install install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-htmldocDATA install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-generic \
-	mostlyclean-libtool pdf pdf-am ps ps-am tags-am uninstall \
-	uninstall-am uninstall-htmldocDATA
-
-
-@DOCBOOK_DOCS_ENABLED_TRUE@gnome-session.html: $(SPEC_XML_FILES)
-@DOCBOOK_DOCS_ENABLED_TRUE@	$(AM_V_GEN)$(XMLTO) xhtml-nochunks -m $(top_srcdir)/doc/dbus/config.xsl gnome-session.xml
-
-org.gnome.SessionManager.ref.xml: $(top_srcdir)/gnome-session/org.gnome.SessionManager.xml spec-to-docbook.xsl
-	$(AM_V_GEN)$(XSLTPROC) $(top_srcdir)/doc/dbus/spec-to-docbook.xsl $< | tail -n +2 > $@
-org.gnome.SessionManager.Client.ref.xml: $(top_srcdir)/gnome-session/org.gnome.SessionManager.Client.xml spec-to-docbook.xsl
-	$(AM_V_GEN)$(XSLTPROC) $(top_srcdir)/doc/dbus/spec-to-docbook.xsl $< | tail -n +2 > $@
-org.gnome.SessionManager.ClientPrivate.ref.xml: $(top_srcdir)/gnome-session/org.gnome.SessionManager.ClientPrivate.xml spec-to-docbook.xsl
-	$(AM_V_GEN)$(XSLTPROC) $(top_srcdir)/doc/dbus/spec-to-docbook.xsl $< | tail -n +2 > $@
-org.gnome.SessionManager.Inhibitor.ref.xml: $(top_srcdir)/gnome-session/org.gnome.SessionManager.Inhibitor.xml spec-to-docbook.xsl
-	$(AM_V_GEN)$(XSLTPROC) $(top_srcdir)/doc/dbus/spec-to-docbook.xsl $< | tail -n +2 > $@
-org.gnome.SessionManager.Presence.ref.xml: $(top_srcdir)/gnome-session/org.gnome.SessionManager.Presence.xml spec-to-docbook.xsl
-	$(AM_V_GEN)$(XSLTPROC) $(top_srcdir)/doc/dbus/spec-to-docbook.xsl $< | tail -n +2 > $@
-
--include $(top_srcdir)/git.mk
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
diff --git a/doc/dbus/config.xsl b/doc/dbus/config.xsl
deleted file mode 100644
index 7aa9def..0000000
--- a/doc/dbus/config.xsl
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version='1.0'?>
-<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
-                xmlns:fo="http://www.w3.org/1999/XSL/Format"
-                version="1.0">
-  <xsl:param name="html.stylesheet" select="'docbook.css'"/>
-</xsl:stylesheet>
diff --git a/doc/dbus/dbus-introspect-docs.dtd b/doc/dbus/dbus-introspect-docs.dtd
deleted file mode 100644
index ca918fb..0000000
--- a/doc/dbus/dbus-introspect-docs.dtd
+++ /dev/null
@@ -1,32 +0,0 @@
-<!-- DTD for D-Bus Introspection Documentation -->
-
-<!ELEMENT doc (summary?,description?,errors?,permission?,since?,deprecated,seealso?)>
-
-<!ELEMENT summary (#PCDATA|ref)*>
-<!ELEMENT description (#PCDATA|para|example)*>
-<!ELEMENT errors (error)*>
-<!ELEMENT permission (#PCDATA|ref|para)*>
-<!ELEMENT since EMPTY>
-<!ATTLIST since version CDATA #REQUIRED>
-<!ELEMENT deprecated (#PCDATA|ref)>
-<!ATTLIST deprecated version CDATA #REQUIRED>
-<!ATTLIST deprecated instead CDATA #REQUIRED>
-<!ELEMENT seealso (ref+)>
-
-<!ELEMENT error (#PCDATA|para)*>
-<!ATTLIST error name CDATA #REQUIRED>
-<!ELEMENT para (#PCDATA|example|code|list|ref)*>
-<!ELEMENT example (#PCDATA|para|code|ref)*>
-<!ATTLIST language (c|glib|python|shell) #REQUIRED>
-<!ATTLIST title CDATA #IMPLIED>
-<!ELEMENT list (item*)>
-<!ATTLIST list type (bullet|number) #REQUIRED>
-<!ELEMENT item (term|definition)*>
-<!ELEMENT term (#PCDATA|ref)*>
-<!ELEMENT definition (#PCDATA|para)*>
-
-<!ELEMENT code (#PCDATA)>
-<!ATTLIST code lang CDATA #IMPLIED>
-<!ELEMENT ref CDATA>
-<!ATTLIST ref type (parameter|arg|signal|method|interface) #REQUIRED>
-<!ATTLIST ref to CDATA #REQUIRED>
diff --git a/doc/dbus/docbook.css b/doc/dbus/docbook.css
deleted file mode 100644
index 6a7373e..0000000
--- a/doc/dbus/docbook.css
+++ /dev/null
@@ -1,78 +0,0 @@
-body
-{
-  font-family: sans-serif;
-}
-h1.title
-{
-}
-.permission
-{
-  color: #ee0000;
-  text-decoration: underline;
-}
-.synopsis, .classsynopsis
-{
-  background: #eeeeee;
-  border: solid 1px #aaaaaa;
-  padding: 0.5em;
-}
-.programlisting
-{
-  background: #eeeeff;
-  border: solid 1px #aaaaff;
-  padding: 0.5em;
-}
-.variablelist
-{
-  padding: 4px;
-  margin-left: 3em;
-}
-.variablelist td:first-child
-{
-  vertical-align: top;
-}
-td.shortcuts
-{
-  color: #770000;
-  font-size: 80%;
-}
-div.refnamediv
-{
-  margin-top: 2em;
-}
-div.toc
-{
-  border: 2em;
-}
-a
-{
-  text-decoration: none;
-}
-a:hover
-{
-  text-decoration: underline;
-  color: #FF0000;
-}
-
-div.table table
-{
-  border-collapse: collapse;
-  border-spacing: 0px;
-  border-style: solid;
-  border-color: #777777;
-  border-width: 1px;
-}
-
-div.table table td, div.table table th
-{
-  border-style: solid;
-  border-color: #777777;
-  border-width: 1px;
-  padding: 3px;
-  vertical-align: top;
-}
-
-div.table table th
-{
-  background-color: #eeeeee;
-}
diff --git a/doc/dbus/gnome-session.xml.in b/doc/dbus/gnome-session.xml.in
deleted file mode 100644
index 5ffdaaf..0000000
--- a/doc/dbus/gnome-session.xml.in
+++ /dev/null
@@ -1,52 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
-<!ENTITY dbus-Manager SYSTEM "org.gnome.SessionManager.ref.xml">
-<!ENTITY dbus-Client SYSTEM "org.gnome.SessionManager.Client.ref.xml">
-<!ENTITY dbus-ClientPrivate SYSTEM "org.gnome.SessionManager.ClientPrivate.ref.xml">
-<!ENTITY dbus-Inhibitor SYSTEM "org.gnome.SessionManager.Inhibitor.ref.xml">
-<!ENTITY dbus-Presence SYSTEM "org.gnome.SessionManager.Presence.ref.xml">
-]>
-
-<book id="index">
-  <bookinfo>
-    <title>GNOME Session @VERSION@ Documentation</title>
-    <releaseinfo>Version @VERSION@</releaseinfo>
-    <authorgroup>
-      <author>
-        <firstname>William Jon</firstname>
-        <surname>McCann</surname>
-        <affiliation>
-          <address>
-            <email>jmccann@redhat.com</email>
-          </address>
-        </affiliation>
-      </author>
-    </authorgroup>
-  </bookinfo>
-
-  <part>
-    <title>Reference</title>
-
-    <reference id="dbus-reference">
-      <title>D-Bus API Reference</title>
-
-      <partintro>
-        <para>
-        This API is not yet stable and is likely to change in the future.
-        </para>
-      </partintro>
-
-      &dbus-Manager;
-      &dbus-Client;
-      &dbus-ClientPrivate;
-      &dbus-Inhibitor;
-      &dbus-Presence;
-
-    </reference>
-  </part>
-
-  <index>
-    <title>Index</title>
-  </index>
-
-</book>
diff --git a/doc/dbus/spec-to-docbook.xsl b/doc/dbus/spec-to-docbook.xsl
deleted file mode 100644
index 9a6a8da..0000000
--- a/doc/dbus/spec-to-docbook.xsl
+++ /dev/null
@@ -1,555 +0,0 @@
-<?xml version='1.0'?>
-<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
-  xmlns:doc="http://www.freedesktop.org/dbus/1.0/doc.dtd"
-  exclude-result-prefixes="doc">
-<!--
-     Convert D-Bus Glib xml into DocBook refentries
-     Copyright (C) 2007-2008 William Jon McCann
-     License: GPL
--->
-<xsl:output method="xml" indent="yes" encoding="UTF-8"/>
-
-<xsl:template match="/">
-
-<xsl:variable name="interface" select="//interface/@name"/>
-<xsl:variable name="basename">
-  <xsl:call-template name="interface-basename">
-    <xsl:with-param name="str" select="$interface"/>
-  </xsl:call-template>
-</xsl:variable>
-
-<refentry><xsl:attribute name="id"><xsl:value-of select="$interface"/></xsl:attribute>
-  <refmeta>
-    <refentrytitle role="top_of_page"><xsl:value-of select="//interface/@name"/></refentrytitle>
-  </refmeta>
-
-  <refnamediv>
-    <refname><xsl:value-of select="$interface"/></refname>
-    <refpurpose><xsl:value-of select="$basename"/> interface</refpurpose>
-  </refnamediv>
-
-  <refsynopsisdiv role="synopsis">
-    <title role="synopsis.title">Methods</title>
-    <synopsis>
-  <xsl:call-template name="methods-synopsis">
-    <xsl:with-param name="interface" select="$interface"/>
-  </xsl:call-template>
-    </synopsis>
-  </refsynopsisdiv>
-
-  <xsl:choose>
-    <xsl:when test="count(///signal) > 0">
-      <refsect1 role="signal_proto">
-        <title role="signal_proto.title">Signals</title>
-        <synopsis>
-          <xsl:call-template name="signals-synopsis">
-            <xsl:with-param name="interface" select="$interface"/>
-          </xsl:call-template>
-        </synopsis>
-      </refsect1>
-    </xsl:when>
-  </xsl:choose>
-
-  <refsect1 role="impl_interfaces">
-    <title role="impl_interfaces.title">Implemented Interfaces</title>
-    <para>
-    Objects implementing <xsl:value-of select="$interface"/> also implements
-    org.freedesktop.DBus.Introspectable,
-    org.freedesktop.DBus.Properties
-    </para>
-  </refsect1>
-
-  <xsl:choose>
-    <xsl:when test="count(///property) > 0">
-      <refsect1 role="properties">
-        <title role="properties.title">Properties</title>
-        <synopsis>
-          <xsl:call-template name="properties-synopsis">
-            <xsl:with-param name="interface" select="$interface"/>
-          </xsl:call-template>
-        </synopsis>
-      </refsect1>
-    </xsl:when>
-  </xsl:choose>
-
-  <refsect1 role="desc">
-    <title role="desc.title">Description</title>
-    <para>
-      <xsl:apply-templates select="//interface/doc:doc"/>
-    </para>
-  </refsect1>
-
-  <refsect1 role="details">
-    <title role="details.title">Details</title>
-    <xsl:call-template name="method-details">
-      <xsl:with-param name="interface" select="$interface"/>
-    </xsl:call-template>
-  </refsect1>
-
-  <xsl:choose>
-    <xsl:when test="count(///signal) > 0">
-      <refsect1 role="signals">
-        <title role="signals.title">Signal Details</title>
-        <xsl:call-template name="signal-details">
-          <xsl:with-param name="interface" select="$interface"/>
-        </xsl:call-template>
-      </refsect1>
-    </xsl:when>
-  </xsl:choose>
-
-  <xsl:choose>
-    <xsl:when test="count(///property) > 0">
-      <refsect1 role="property_details">
-        <title role="property_details.title">Property Details</title>
-        <xsl:call-template name="property-details">
-          <xsl:with-param name="interface" select="$interface"/>
-        </xsl:call-template>
-      </refsect1>
-    </xsl:when>
-  </xsl:choose>
-
-</refentry>
-</xsl:template>
-
-
-<xsl:template name="property-doc">
-  <xsl:apply-templates select="doc:doc/doc:description"/>
-
-  <xsl:choose>
-    <xsl:when test="count(arg) > 0">
-      <variablelist role="params">
-        <xsl:for-each select="arg">
-          <varlistentry><term><parameter><xsl:value-of select="@name"/></parameter>:</term>
-          <listitem><simpara><xsl:apply-templates select="doc:doc/doc:summary"/></simpara></listitem>
-          </varlistentry>
-        </xsl:for-each>
-      </variablelist>
-    </xsl:when>
-  </xsl:choose>
-
-  <xsl:apply-templates select="doc:doc/doc:since"/>
-  <xsl:apply-templates select="doc:doc/doc:deprecated"/>
-  <xsl:apply-templates select="doc:doc/doc:permission"/>
-  <xsl:apply-templates select="doc:doc/doc:seealso"/>
-</xsl:template>
-
-
-<xsl:template name="property-details">
-  <xsl:param name="interface"/>
-  <xsl:variable name="longest">
-    <xsl:call-template name="find-longest">
-      <xsl:with-param name="set" select="@name"/>
-    </xsl:call-template>
-  </xsl:variable>
-  <xsl:for-each select="///property">
-  <refsect2>
-    <title><anchor role="function"><xsl:attribute name="id"><xsl:value-of select="$interface"/>:<xsl:value-of select="@name"/></xsl:attribute></anchor>The "<xsl:value-of select="@name"/>" property</title>
-<indexterm><primary><xsl:value-of select="@name"/></primary><secondary><xsl:value-of select="$interface"/></secondary></indexterm>
-<programlisting>'<xsl:value-of select="@name"/>'<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="2"/></xsl:call-template>
-<xsl:call-template name="property-args"><xsl:with-param name="indent" select="string-length(@name) + 2"/></xsl:call-template></programlisting>
-
-    <xsl:call-template name="property-doc"/>
-  </refsect2>
-
-  </xsl:for-each>
-</xsl:template>
-
-<xsl:template name="signal-doc">
-  <xsl:apply-templates select="doc:doc/doc:description"/>
-
-  <xsl:choose>
-    <xsl:when test="count(arg) > 0">
-      <variablelist role="params">
-        <xsl:for-each select="arg">
-          <varlistentry><term><parameter><xsl:value-of select="@name"/></parameter>:</term>
-          <listitem><simpara><xsl:apply-templates select="doc:doc/doc:summary"/></simpara></listitem>
-          </varlistentry>
-        </xsl:for-each>
-      </variablelist>
-    </xsl:when>
-  </xsl:choose>
-
-  <xsl:apply-templates select="doc:doc/doc:since"/>
-  <xsl:apply-templates select="doc:doc/doc:deprecated"/>
-  <xsl:apply-templates select="doc:doc/doc:permission"/>
-  <xsl:apply-templates select="doc:doc/doc:seealso"/>
-</xsl:template>
-
-<xsl:template name="signal-details">
-  <xsl:param name="interface"/>
-  <xsl:variable name="longest">
-    <xsl:call-template name="find-longest">
-      <xsl:with-param name="set" select="@name"/>
-    </xsl:call-template>
-  </xsl:variable>
-  <xsl:for-each select="///signal">
-  <refsect2>
-    <title><anchor role="function"><xsl:attribute name="id"><xsl:value-of select="$interface"/>::<xsl:value-of select="@name"/></xsl:attribute></anchor>The <xsl:value-of select="@name"/> signal</title>
-<indexterm><primary><xsl:value-of select="@name"/></primary><secondary><xsl:value-of select="$interface"/></secondary></indexterm>
-<programlisting><xsl:value-of select="@name"/> (<xsl:call-template name="signal-args"><xsl:with-param name="indent" select="string-length(@name) + 2"/><xsl:with-param name="prefix" select="."/></xsl:call-template>)</programlisting>
-
-    <xsl:call-template name="signal-doc"/>
-  </refsect2>
-
-  </xsl:for-each>
-</xsl:template>
-
-<xsl:template match="doc:code">
-<programlisting>
-<xsl:apply-templates />
-</programlisting>
-</xsl:template>
-
-<xsl:template match="doc:tt">
-  <literal>
-    <xsl:apply-templates />
-  </literal>
-</xsl:template>
-
-<xsl:template match="doc:i">
-  <emphasis>
-    <xsl:apply-templates />
-  </emphasis>
-</xsl:template>
-
-<xsl:template match="doc:b">
-  <emphasis role="bold">
-    <xsl:apply-templates />
-  </emphasis>
-</xsl:template>
-
-<xsl:template match="doc:ulink">
-  <ulink>
-    <xsl:attribute name="url"><xsl:value-of select="@url"/></xsl:attribute>
-    <xsl:value-of select="."/>
-  </ulink>
-</xsl:template>
-
-<xsl:template match="doc:summary">
-  <xsl:apply-templates />
-</xsl:template>
-
-<xsl:template match="doc:example">
-<informalexample>
-<xsl:apply-templates />
-</informalexample>
-</xsl:template>
-
-<xsl:template name="listitems-do-term">
-  <xsl:param name="str"/>
-  <xsl:choose>
-    <xsl:when test="string-length($str) > 0">
-      <emphasis role="bold"><xsl:value-of select="$str"/>: </emphasis>
-    </xsl:when>
-  </xsl:choose>
-</xsl:template>
-
-<xsl:template name="do-listitems">
-  <xsl:for-each select="doc:item">
-    <listitem>
-      <simpara>
-        <xsl:call-template name="listitems-do-term"><xsl:with-param name="str" select="doc:term"/></xsl:call-template>
-        <xsl:apply-templates select="doc:definition"/>
-      </simpara>
-    </listitem>
-  </xsl:for-each>
-</xsl:template>
-
-<xsl:template match="doc:list">
-    <xsl:choose>
-      <xsl:when test="contains(@type,'number')">
-        <orderedlist>
-          <xsl:call-template name="do-listitems"/>
-        </orderedlist>
-      </xsl:when>
-      <xsl:otherwise>
-        <itemizedlist>
-          <xsl:call-template name="do-listitems"/>
-        </itemizedlist>
-      </xsl:otherwise>
-    </xsl:choose>
-</xsl:template>
-
-<xsl:template match="doc:para">
-<para>
-<xsl:apply-templates />
-</para>
-</xsl:template>
-
-<xsl:template match="doc:description">
-<xsl:apply-templates />
-</xsl:template>
-
-<xsl:template match="doc:since">
-<para role="since">Since <xsl:value-of select="@version"/>
-</para>
-</xsl:template>
-
-<xsl:template match="doc:deprecated">
-  <xsl:variable name="name" select="../../@name"/>
-  <xsl:variable name="parent">
-    <xsl:call-template name="interface-basename">
-      <xsl:with-param name="str" select="../../../@name"/>/>
-    </xsl:call-template>
-  </xsl:variable>
-
-  <xsl:variable name="type" select="name(../..)"/>
-
-  <para role="deprecated">
-  <warning><para><literal><xsl:value-of select="$name"/></literal> is deprecated since version <xsl:value-of select="@version"/> and should not be used in newly-written code. Use
-
-  <xsl:variable name="to">
-  <xsl:choose>
-    <xsl:when test="contains($type,'property')">
-      <xsl:value-of select="$parent"/>:<xsl:value-of select="@instead"/>
-    </xsl:when>
-    <xsl:when test="contains($type,'signal')">
-      <xsl:value-of select="$parent"/>::<xsl:value-of select="@instead"/>
-    </xsl:when>
-    <xsl:when test="contains($type,'method')">
-      <xsl:value-of select="$parent"/>.<xsl:value-of select="@instead"/>
-    </xsl:when>
-    <xsl:when test="contains($type,'interface')">
-      <xsl:value-of select="@instead"/>
-    </xsl:when>
-    <xsl:otherwise>
-      <xsl:value-of select="@instead"/>
-    </xsl:otherwise>
-  </xsl:choose>
-  </xsl:variable>
-
-  <xsl:call-template name="create-link">
-    <xsl:with-param name="type" select="$type"/>
-    <xsl:with-param name="to" select="$to"/>
-    <xsl:with-param name="val" select="@instead"/>
-  </xsl:call-template>
-instead.</para></warning>
-</para>
-</xsl:template>
-
-<xsl:template match="doc:permission">
-<para role="permission">
-<xsl:apply-templates />
-</para>
-</xsl:template>
-
-<xsl:template match="doc:errors">
-<para role="errors">
-<xsl:apply-templates />
-</para>
-</xsl:template>
-
-<xsl:template match="doc:seealso">
-<para>
-See also:
-<xsl:apply-templates />
-
-</para>
-</xsl:template>
-
-<xsl:template name="create-link">
-  <xsl:param name="type"/>
-  <xsl:param name="to"/>
-  <xsl:param name="val"/>
-
-  <xsl:choose>
-    <xsl:when test="contains($type,'property')">
-      <link><xsl:attribute name="linkend"><xsl:value-of select="$to"/></xsl:attribute><literal><xsl:value-of select="$val"/></literal></link>
-    </xsl:when>
-    <xsl:when test="contains($type,'signal')">
-      <link><xsl:attribute name="linkend"><xsl:value-of select="$to"/></xsl:attribute><literal><xsl:value-of select="$val"/></literal></link>
-    </xsl:when>
-    <xsl:when test="contains($type,'method')">
-      <link><xsl:attribute name="linkend"><xsl:value-of select="$to"/></xsl:attribute><function><xsl:value-of select="$val"/></function></link>
-    </xsl:when>
-    <xsl:when test="contains($type,'interface')">
-      <link><xsl:attribute name="linkend"><xsl:value-of select="$to"/></xsl:attribute><xsl:value-of select="$val"/></link>
-    </xsl:when>
-  </xsl:choose>
-</xsl:template>
-
-<xsl:template match="doc:ref">
-  <xsl:call-template name="create-link">
-    <xsl:with-param name="type" select="@type"/>
-    <xsl:with-param name="to" select="@to"/>
-    <xsl:with-param name="val" select="."/>
-  </xsl:call-template>
-</xsl:template>
-
-<xsl:template name="method-doc">
-  <xsl:apply-templates select="doc:doc/doc:description"/>
-
-  <xsl:choose>
-    <xsl:when test="count(arg) > 0">
-      <variablelist role="params">
-        <xsl:for-each select="arg">
-          <varlistentry><term><parameter><xsl:value-of select="@name"/></parameter>:</term>
-          <listitem><simpara><xsl:apply-templates select="doc:doc/doc:summary"/></simpara></listitem>
-          </varlistentry>
-        </xsl:for-each>
-      </variablelist>
-    </xsl:when>
-  </xsl:choose>
-
-  <xsl:apply-templates select="doc:doc/doc:since"/>
-  <xsl:apply-templates select="doc:doc/doc:deprecated"/>
-
-  <xsl:choose>
-    <xsl:when test="count(doc:doc/doc:errors) > 0">
-      <refsect3>
-        <title>Errors</title>
-        <variablelist role="errors">
-          <xsl:for-each select="doc:doc/doc:errors/doc:error">
-            <varlistentry>
-              <term><parameter><xsl:value-of select="@name"/></parameter>:</term>
-              <listitem><simpara><xsl:apply-templates select="."/></simpara></listitem>
-            </varlistentry>
-          </xsl:for-each>
-        </variablelist>
-      </refsect3>
-    </xsl:when>
-  </xsl:choose>
-
-  <xsl:choose>
-    <xsl:when test="count(doc:doc/doc:permission) > 0">
-      <refsect3>
-        <title>Permissions</title>
-        <xsl:apply-templates select="doc:doc/doc:permission"/>
-      </refsect3>
-    </xsl:when>
-  </xsl:choose>
-
-  <xsl:apply-templates select="doc:doc/doc:seealso"/>
-</xsl:template>
-
-<xsl:template name="method-details">
-  <xsl:param name="interface"/>
-  <xsl:variable name="longest">
-    <xsl:call-template name="find-longest">
-      <xsl:with-param name="set" select="@name"/>
-    </xsl:call-template>
-  </xsl:variable>
-  <xsl:for-each select="///method">
-    <refsect2>
-      <title><anchor role="function"><xsl:attribute name="id"><xsl:value-of select="$interface"/>.<xsl:value-of select="@name"/></xsl:attribute></anchor><xsl:value-of select="@name"/> ()</title>
-<indexterm><primary><xsl:value-of select="@name"/></primary><secondary><xsl:value-of select="$interface"/></secondary></indexterm>
-<programlisting><xsl:value-of select="@name"/> (<xsl:call-template name="method-args"><xsl:with-param name="indent" select="string-length(@name) + 2"/><xsl:with-param name="prefix" select="."/></xsl:call-template>)</programlisting>
-
-      <xsl:call-template name="method-doc"/>
-    </refsect2>
-
-  </xsl:for-each>
-</xsl:template>
-
-
-<xsl:template name="properties-synopsis">
-  <xsl:param name="interface"/>
-  <xsl:variable name="longest">
-    <xsl:call-template name="find-longest">
-      <xsl:with-param name="set" select="///property/@name"/>
-    </xsl:call-template>
-  </xsl:variable>
-  <xsl:for-each select="///property">
-<link><xsl:attribute name="linkend"><xsl:value-of select="$interface"/>:<xsl:value-of select="@name"/></xsl:attribute>'<xsl:value-of select="@name"/>'</link><xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$longest - string-length(@name) + 1"/></xsl:call-template> <xsl:call-template name="property-args"><xsl:with-param name="indent" select="$longest + 2"/></xsl:call-template>
-</xsl:for-each>
-</xsl:template>
-
-
-<xsl:template name="signals-synopsis">
-  <xsl:param name="interface"/>
-  <xsl:variable name="longest">
-    <xsl:call-template name="find-longest">
-      <xsl:with-param name="set" select="///signal/@name"/>
-    </xsl:call-template>
-  </xsl:variable>
-  <xsl:for-each select="///signal">
-<link><xsl:attribute name="linkend"><xsl:value-of select="$interface"/>::<xsl:value-of select="@name"/></xsl:attribute><xsl:value-of select="@name"/></link><xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$longest - string-length(@name) + 1"/></xsl:call-template>(<xsl:call-template name="signal-args"><xsl:with-param name="indent" select="$longest + 2"/><xsl:with-param name="prefix" select="///signal"/></xsl:call-template>)
-</xsl:for-each>
-</xsl:template>
-
-
-<xsl:template name="methods-synopsis">
-  <xsl:param name="interface"/>
-  <xsl:variable name="longest">
-    <xsl:call-template name="find-longest">
-      <xsl:with-param name="set" select="///method/@name"/>
-    </xsl:call-template>
-  </xsl:variable>
-  <xsl:for-each select="///method">
-<link><xsl:attribute name="linkend"><xsl:value-of select="$interface"/>.<xsl:value-of select="@name"/></xsl:attribute><xsl:value-of select="@name"/></link><xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$longest - string-length(@name) + 1"/></xsl:call-template>(<xsl:call-template name="method-args"><xsl:with-param name="indent" select="$longest + 2"/><xsl:with-param name="prefix" select="///method"/></xsl:call-template>)
-</xsl:for-each>
-</xsl:template>
-
-
-<xsl:template name="method-args"><xsl:param name="indent"/><xsl:param name="prefix"/><xsl:variable name="longest"><xsl:call-template name="find-longest"><xsl:with-param name="set" select="$prefix/arg/@type"/></xsl:call-template></xsl:variable><xsl:for-each select="arg"><xsl:value-of select="@direction"/>
-<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="4 - string-length(@direction)"/></xsl:call-template>'<xsl:value-of select="@type"/>'<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$longest - string-length(@type) + 1"/></xsl:call-template>
-<xsl:value-of select="@name"/><xsl:if test="not(position() = last())">,
-<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$indent"/></xsl:call-template></xsl:if>
-</xsl:for-each>
-</xsl:template>
-
-
-<xsl:template name="signal-args"><xsl:param name="indent"/><xsl:param name="prefix"/><xsl:variable name="longest"><xsl:call-template name="find-longest"><xsl:with-param name="set" select="$prefix/arg/@type"/></xsl:call-template></xsl:variable><xsl:for-each select="arg">'<xsl:value-of select="@type"/>'<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$longest - string-length(@type) + 1"/></xsl:call-template>
-<xsl:value-of select="@name"/><xsl:if test="not(position() = last())">,
-<xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="$indent"/></xsl:call-template></xsl:if>
-</xsl:for-each>
-</xsl:template>
-
-
-<xsl:template name="property-args"><xsl:param name="indent"/>
-<xsl:value-of select="@access"/><xsl:call-template name="pad-spaces"><xsl:with-param name="width" select="9 - string-length(@access) + 1"/></xsl:call-template>'<xsl:value-of select="@type"/>'
-</xsl:template>
-
-
-<xsl:template name="pad-spaces">
-  <xsl:param name="width"/>
-  <xsl:variable name="spaces" xml:space="preserve">                                                                        </xsl:variable>
-  <xsl:value-of select="substring($spaces,1,$width)"/>
-</xsl:template>
-
-
-<xsl:template name="find-longest">
-  <xsl:param name="set"/>
-  <xsl:param name="index" select="1"/>
-  <xsl:param name="longest" select="0"/>
-
-  <xsl:choose>
-    <xsl:when test="$index > count($set)">
-      <!--finished looking-->
-      <xsl:value-of select="$longest"/>
-    </xsl:when>
-    <xsl:when test="string-length($set[$index])>$longest">
-      <!--found new longest-->
-      <xsl:call-template name="find-longest">
-        <xsl:with-param name="set" select="$set"/>
-        <xsl:with-param name="index" select="$index + 1"/>
-        <xsl:with-param name="longest" select="string-length($set[$index])"/>
-      </xsl:call-template>
-    </xsl:when>
-    <xsl:otherwise>
-      <!--this isn't any longer-->
-      <xsl:call-template name="find-longest">
-        <xsl:with-param name="set" select="$set"/>
-        <xsl:with-param name="index" select="$index + 1"/>
-        <xsl:with-param name="longest" select="$longest"/>
-      </xsl:call-template>
-    </xsl:otherwise>
-  </xsl:choose>
-</xsl:template>
-
-
-<xsl:template name="interface-basename">
-  <xsl:param name="str"/>
-  <xsl:choose>
-    <xsl:when test="contains($str,'.')">
-      <xsl:call-template name="interface-basename">
-        <xsl:with-param name="str" select="substring-after($str,'.')"/>
-      </xsl:call-template>
-    </xsl:when>
-    <xsl:otherwise>
-      <xsl:value-of select="$str"/>
-    </xsl:otherwise>
-  </xsl:choose>
-</xsl:template>
-
-</xsl:stylesheet>
diff --git a/doc/man/Makefile.am b/doc/man/Makefile.am
index 2879423..94da001 100644
--- a/doc/man/Makefile.am
+++ b/doc/man/Makefile.am
@@ -10,21 +10,9 @@ XSLTPROC_FLAGS = \
 	$(AM_V_GEN) $(XSLTPROC) $(XSLTPROC_FLAGS) http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl $<
 
 man_MANS =				\
-	gnome-session.1			\
-	gnome-session-properties.1	\
-	gnome-session-quit.1		\
-	gnome-session-inhibit.1
-
-if BUILD_SESSION_SELECTOR
-man_MANS += gnome-session-selector.1
-endif
+	gnome-session-properties.1
 
 EXTRA_DIST =				\
-	gnome-session-inhibit.xml	\
-	gnome-session-selector.xml	\
 	$(man_MANS)
 
-CLEANFILES =				\
-	gnome-session-inhibit.1
-
 -include $(top_srcdir)/git.mk
diff --git a/doc/man/gnome-session-inhibit.1 b/doc/man/gnome-session-inhibit.1
deleted file mode 100644
index 2fcbdef..0000000
--- a/doc/man/gnome-session-inhibit.1
+++ /dev/null
@@ -1,74 +0,0 @@
-'\" t
-.\"     Title: gnome-session-inhibit
-.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
-.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
-.\"      Date: 03/19/2013
-.\"    Manual: User Commands
-.\"    Source: gnome-session
-.\"  Language: English
-.\"
-.TH "GNOME\-SESSION\-INHI" "1" "" "gnome-session" "User Commands"
-.\" -----------------------------------------------------------------
-.\" * Define some portability stuff
-.\" -----------------------------------------------------------------
-.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-.\" http://bugs.debian.org/507673
-.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
-.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-.ie \n(.g .ds Aq \(aq
-.el       .ds Aq '
-.\" -----------------------------------------------------------------
-.\" * set default formatting
-.\" -----------------------------------------------------------------
-.\" disable hyphenation
-.nh
-.\" disable justification (adjust text to left margin only)
-.ad l
-.\" -----------------------------------------------------------------
-.\" * MAIN CONTENT STARTS HERE *
-.\" -----------------------------------------------------------------
-.SH "NAME"
-gnome-session-inhibit \- inhibit gnome\-session functionality
-.SH "SYNOPSIS"
-.HP \w'\fBgnome\-session\-inhibit\fR\ 'u
-\fBgnome\-session\-inhibit\fR [OPTION...] [COMMAND]
-.SH "DESCRIPTION"
-.PP
-\fBgnome\-session\-inhibit\fR
-can inhibit certain gnome\-session functionality while executing the given COMMAND\&. To achieve this, it calls the Inhibit() method of the gnome\-session D\-Bus API and creates an inhibitor\&. The inhibitor is automatically removed when gnome\-session\-inhibit exits\&.
-.PP
-A typical use case is to prevent the session from going idle (and thus locking the screen) while a movie player is running\&.
-.SH "OPTIONS"
-.PP
-\fB\-h\fR, \fB\-\-help\fR
-.RS 4
-print help and exit
-.RE
-.PP
-\fB\-\-version\fR
-.RS 4
-print version information and exit
-.RE
-.PP
-\fB\-\-app\-id\fR ID
-.RS 4
-The application id to use when calling the gnome\-session Inhibit() method\&. If this option is not specified, "unknown" is used\&.
-.RE
-.PP
-\fB\-\-reason\fR REASON
-.RS 4
-A human\-readable reason to pass along when calling the gnome\-session Inhibit() method\&. If this option is not specified, "not specified" is used\&.
-.RE
-.PP
-\fB\-\-inhibit\fR ARG
-.RS 4
-ARG specifies the things to inhibit, as a colon\-separated list\&. The possible values are logout, switch\-user, suspend, idle, automount\&. If this option is used more than once, the values are combined\&. If this option is not specified, "idle" is assumed\&.
-.RE
-.PP
-\fB\-\-inhibit\-only\fR
-.RS 4
-Do not launch COMMAND and wait forever instead
-.RE
-.SH "SEE ALSO"
-.PP
-\fBsystemd-inhibit\fR(1)
diff --git a/doc/man/gnome-session-inhibit.xml b/doc/man/gnome-session-inhibit.xml
deleted file mode 100644
index d7ed4c8..0000000
--- a/doc/man/gnome-session-inhibit.xml
+++ /dev/null
@@ -1,99 +0,0 @@
-<refentry id="gnome-session-inhibit" lang="en">
-
-<refentryinfo>
-<title>gnome-session-inhibit</title>
-<productname>gnome-session</productname>
-</refentryinfo>
-
-<refmeta>
-<refentrytitle>gnome-session-inhibit</refentrytitle>
-<manvolnum>1</manvolnum>
-<refmiscinfo class="manual">User Commands</refmiscinfo>
-</refmeta>
-
-<refnamediv>
-<refname>gnome-session-inhibit</refname>
-<refpurpose>inhibit gnome-session functionality</refpurpose>
-</refnamediv>
-
-<refsynopsisdiv>
-<cmdsynopsis>
-<command>gnome-session-inhibit</command>
-<arg choice="opt" rep="repeat">OPTION</arg>
-<arg choice="opt">COMMAND</arg>
-</cmdsynopsis>
-</refsynopsisdiv>
-
-<refsect1><title>Description</title>
-<para><command>gnome-session-inhibit</command> can inhibit certain
-gnome-session functionality while executing the given COMMAND. To
-achieve this, it calls the Inhibit() method of the gnome-session
-D-Bus API and creates an inhibitor. The inhibitor is automatically
-removed when gnome-session-inhibit exits.
-</para>
-<para>
-A typical use case is to prevent the session from going idle (and
-thus locking the screen) while a movie player is running.
-</para>
-
-</refsect1>
-
-<refsect1><title>Options</title>
-<variablelist>
-
-<varlistentry>
-<term><option>-h</option>, <option>--help</option></term>
-<listitem><para>
-print help and exit
-</para></listitem>
-</varlistentry>
-
-<varlistentry>
-<term><option>--version</option></term>
-<listitem><para>
-print version information and exit
-</para></listitem>
-</varlistentry>
-
-<varlistentry>
-<term><option>--app-id</option> ID</term>
-<listitem><para>
-The application id to use when calling the gnome-session Inhibit() method.
-If this option is not specified, "unknown" is used.
-</para></listitem>
-</varlistentry>
-
-<varlistentry>
-<term><option>--reason</option> REASON</term>
-<listitem><para>
-A human-readable reason to pass along when calling the gnome-session
-Inhibit() method. If this option is not specified, "not specified" is used.
-</para></listitem>
-</varlistentry>
-
-<varlistentry>
-<term><option>--inhibit</option> ARG</term>
-<listitem><para>
-ARG specifies the things to inhibit, as a colon-separated list. The
-possible values are logout, switch-user, suspend, idle, automount.
-If this option is used more than once, the values are combined.
-If this option is not specified, "idle" is assumed.
-</para></listitem>
-</varlistentry>
-
-<varlistentry>
-<term><option>--inhibit-only</option></term>
-<listitem><para>
-Do not launch COMMAND and wait forever instead
-</para></listitem>
-</varlistentry>
-
-</variablelist>
-</refsect1>
-
-<refsect1><title>See also</title>
-<para>
-<citerefentry><refentrytitle>systemd-inhibit</refentrytitle><manvolnum>1</manvolnum></citerefentry>
-</para>
-</refsect1>
-</refentry>
diff --git a/doc/man/gnome-session-quit.1 b/doc/man/gnome-session-quit.1
deleted file mode 100644
index f0fdd16..0000000
--- a/doc/man/gnome-session-quit.1
+++ /dev/null
@@ -1,34 +0,0 @@
-.\"
-.\" gnome-session-quit manual page.
-.\" (C) 2000 Miguel de Icaza (miguel@helixcode.com)
-.\" (C) 2009-2010 Vincent Untz (vuntz@gnome.org)
-.\"
-.TH GNOME-SESSION-QUIT 1 "GNOME"
-.SH NAME
-gnome-session-quit \- End the current GNOME session
-.SH SYNOPSIS
-.B gnome-session-quit [\-\-logout|\-\-power-off|\-\-reboot] [\-\-force] [\-\-no-prompt]
-.SH DESCRIPTION
-The \fIgnome-session-quit\fP program can be used to end a GNOME session.
-.SH OPTIONS
-The following options are supported:
-.TP
-.I "--logout"
-Prompt the user to confirm logout. This is the default behavior.
-.TP
-.I "--power-off"
-Prompt the user to confirm system power off.
-.TP
-.I "--reboot"
-Prompt the user to confirm system reboot.
-.TP
-.I "--force"
-Ignore any inhibitors.
-.TP
-.I "--no-prompt"
-End the session without user interaction. This only works with \fI--logout\fP.
-.SH BUGS
-If you find bugs in the \fIgnome-session-quit\fP program, please report
-these on https://bugzilla.gnome.org.
-.SH SEE ALSO
-.BR gnome-session(1)
diff --git a/doc/man/gnome-session-selector.xml b/doc/man/gnome-session-selector.xml
deleted file mode 100644
index 7beb1e4..0000000
--- a/doc/man/gnome-session-selector.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<refentry id="gnome-session-selector" lang="en">
-
-<refentryinfo>
-<title>gnome-session-selector</title>
-<productname>gnome-session</productname>
-</refentryinfo>
-
-<refmeta>
-<refentrytitle>gnome-session-selector</refentrytitle>
-<manvolnum>1</manvolnum>
-<refmiscinfo class="manual">User Commands</refmiscinfo>
-</refmeta>
-
-<refnamediv>
-<refname>gnome-session-selector</refname>
-<refpurpose>Selects a session to use with gnome-session</refpurpose>
-</refnamediv>
-
-<refsynopsisdiv>
-<cmdsynopsis>
-<command>gnome-session-selector</command>
-<arg choice="opt">session</arg>
-</cmdsynopsis>
-</refsynopsisdiv>
-
-<refsect1><title>Description</title>
-<para><command>gnome-session-selector</command> can be used from a
-xsession desktop file to select a session before gnome-session is run.
-gnome-session reads and stores its session in the
-<filename><envar>$XDG_DATA_HOME</envar>/gnome-session/saved-session</filename>
-directory. <command>gnome-session-selector</command> works by replacing
-the saved-session directory by a symlink to another directory. Since the
-session name is used as the directory name, it may not contain '/' characters
-or begin with a '.'.
-</para>
-<para>
-When a session name is specified, <command>gnome-session-selector</command>
-will create a symlink to select this session.
-</para>
-<para>
-When started without arguments, <command>gnome-session-selector</command>
-will present a dialog that allows to choose one of the existing sessions
-or create a new one.
-</para>
-</refsect1>
-
-<refsect1><title>See also</title>
-<para>
-<citerefentry><refentrytitle>gnome-session</refentrytitle><manvolnum>1</manvolnum></citerefentry>
-</para>
-</refsect1>
-</refentry>
diff --git a/doc/man/gnome-session.1 b/doc/man/gnome-session.1
deleted file mode 100644
index 35c062c..0000000
--- a/doc/man/gnome-session.1
+++ /dev/null
@@ -1,114 +0,0 @@
-.\"
-.\" gnome-session manual page.
-.\" (C) 2000 Miguel de Icaza (miguel@helixcode.com)
-.\" (C) 2009-2010 Vincent Untz (vuntz@gnome.org)
-.\"
-.TH GNOME-SESSION 1 "GNOME"
-.SH NAME
-gnome-session \- Start the GNOME desktop environment
-.SH SYNOPSIS
-.B gnome-session [\-a|\-\-autostart=DIR] [\-\-session=SESSION] [\-\-failsafe|\-f] [\-\-debug] [\-\-whale]
-.SH DESCRIPTION
-The \fIgnome-session\fP program starts up the GNOME desktop
-environment. This command is typically executed by your login manager
-(either gdm, xdm, or from your X startup scripts). It will load
-either your saved session, or it will provide a default session for the
-user as defined by the system administrator (or the default GNOME
-installation on your system).
-.PP
-The default session is defined in \fBgnome.session\fP, a .desktop-like
-file that is looked for in
-\fB$XDG_CONFIG_HOME/gnome-session/sessions\fP,
-\fB$XDG_CONFIG_DIRS/gnome-session/sessions\fP and
-\fB$XDG_DATA_DIRS/gnome-session/sessions\fP.
-.PP
-When saving a session, \fIgnome-session\fP saves the currently running
-applications in the \fB$XDG_CONFIG_HOME/gnome-session/saved-session\fP
-directory.
-.PP
-\fIgnome-session\fP is an X11R6 session manager. It can manage GNOME
-applications as well as any X11R6 SM compliant application.
-.SH OPTIONS
-The following options are supported:
-.TP
-.I "--autostart=DIR"
-Start all applications defined in \fIDIR\fP, instead of starting the
-applications defined in \fBgnome.session\fP, or via the \fI--session\fP
-option. Multiple \fI--autostart\fP options can be passed.
-.TP
-.I "--session=SESSION"
-Use the applications defined in \fBSESSION.session\fP. If not specified,
-\fBgnome.session\fP will be used.
-.TP
-.I "--failsafe"
-Run in fail-safe mode. User-specified applications will not be started.
-.TP
-.I "--debug"
-Enable debugging code.
-.TP
-.I "--whale"
-Show the fail whale in a dialog for debugging it.
-.SH SESSION DEFINITION
-Sessions are defined in \fB.session\fP files, that are using a .desktop-like
-format, with the following keys in the \fBGNOME Session\fP group:
-.TP
-.I Name
-Name of the session. This can be localized.
-.TP
-.I RequiredComponents
-List of component identifiers (desktop files) that are required by the session. The required components will always run in the session.
-.PP
-Here is an example of a session definition:
-.PP
-.in +4n
-.nf
-[GNOME Session]
-Name=GNOME
-RequiredComponents=gnome-shell;gnome-settings-daemon;
-.in
-.fi
-.PP
-The \fB.session\fP files are looked for in
-\fB$XDG_CONFIG_HOME/gnome-session/sessions\fP,
-\fB$XDG_CONFIG_DIRS/gnome-session/sessions\fP and
-\fB$XDG_DATA_DIRS/gnome-session/sessions\fP.
-.SH ENVIRONMENT
-\fIgnome-session\fP sets several environment variables for the use of
-its child processes:
-.PP
-.B SESSION_MANAGER
-.IP
-This variable is used by session-manager aware clients to contact
-gnome-session.
-.PP
-.B DISPLAY
-.IP
-This variable is set to the X display being used by
-\fIgnome-session\fP. Note that if the \fI--display\fP option is used
-this might be different from the setting of the environment variable
-when gnome-session is invoked.
-.SH FILES
-.PP
-.B $XDG_CONFIG_HOME/config/autostart
-.B $XDG_CONFIG_DIRS/config/autostart
-.B /usr/share/gnome/autostart
-.IP
-The applications defined in those directories will be started on login.
-\fIgnome-session-properties(1)\fP can be used to easily configure them.
-.PP
-.B $XDG_CONFIG_HOME/gnome-session/sessions
-.B $XDG_CONFIG_DIRS/gnome-session/sessions
-.B $XDG_DATA_DIRS/gnome-session/sessions
-.IP
-These directories contain the \fB.session\fP files that can be used
-with the \fI--session\fP option.
-.PP
-.B $XDG_CONFIG_HOME/gnome-session/saved-session
-.IP
-This directory contains the list of applications of the saved session.
-.SH BUGS
-If you find bugs in the \fIgnome-session\fP program, please report
-these on https://bugzilla.gnome.org.
-.SH SEE ALSO
-.BR gnome-session-properties(1)
-.BR gnome-session-quit(1)
diff --git a/egg/Makefile.am b/egg/Makefile.am
deleted file mode 100644
index 0ce07c5..0000000
--- a/egg/Makefile.am
+++ /dev/null
@@ -1,52 +0,0 @@
-platform_defines = -DEGG_SM_CLIENT_BACKEND_XSMP
-platform_ltlibraries =                   \
-	libeggdesktopfile.la             \
-	libeggsmclient-gnome.la
-platform_libs = 			\
-	libeggdesktopfile.la		\
-	$(SM_LIBS)			\
-	$(ICE_LIBS)
-platform_sources = eggsmclient-xsmp.c
-
-INCLUDES =                               \
-	-DG_LOG_DOMAIN=\""EggSMClient"\" \
-	$(platform_defines)              \
-	$(EGG_SMCLIENT_CFLAGS)           \
-	$(SM_CFLAGS)			 \
-	$(ICE_CFLAGS)			 \
-	$(WARN_CFLAGS)			 \
-	$(DISABLE_DEPRECATED_CFLAGS)
-
-noinst_LTLIBRARIES =                     \
-	libeggsmclient.la                \
-	$(platform_ltlibraries)
-
-libeggsmclient_la_LIBADD =               \
-	$(EGG_SMCLIENT_LIBS)             \
-	$(SM_LIBS)			 \
-	$(ICE_LIBS)			 \
-	$(platform_libs)
-
-libeggsmclient_la_SOURCES =              \
-	eggsmclient.c                    \
-	eggsmclient.h                    \
-	eggsmclient-private.h            \
-	$(platform_sources)
-
-libeggsmclient_gnome_la_LIBADD =         \
-	$(libeggsmclient_la_LIBADD)
-
-libeggsmclient_gnome_la_SOURCES =        \
-	eggsmclient.c                    \
-	eggsmclient.h                    \
-	eggsmclient-private.h            \
-	$(platform_sources)
-
-libeggdesktopfile_la_LIBADD =            \
-	$(EGG_SMCLIENT_LIBS)
-
-libeggdesktopfile_la_SOURCES =           \
-	eggdesktopfile.c                 \
-	eggdesktopfile.h
-
--include $(top_srcdir)/git.mk
diff --git a/egg/Makefile.in b/egg/Makefile.in
deleted file mode 100644
index 27fb9e4..0000000
--- a/egg/Makefile.in
+++ /dev/null
@@ -1,728 +0,0 @@
-# Makefile.in generated by automake 1.13.4 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
-
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-@SET_MAKE@
-
-VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
-am__make_running_with_option = \
-  case $${target_option-} in \
-      ?) ;; \
-      *) echo "am__make_running_with_option: internal error: invalid" \
-              "target option '$${target_option-}' specified" >&2; \
-         exit 1;; \
-  esac; \
-  has_opt=no; \
-  sane_makeflags=$$MAKEFLAGS; \
-  if $(am__is_gnu_make); then \
-    sane_makeflags=$$MFLAGS; \
-  else \
-    case $$MAKEFLAGS in \
-      *\\[\ \	]*) \
-        bs=\\; \
-        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
-          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
-    esac; \
-  fi; \
-  skip_next=no; \
-  strip_trailopt () \
-  { \
-    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
-  }; \
-  for flg in $$sane_makeflags; do \
-    test $$skip_next = yes && { skip_next=no; continue; }; \
-    case $$flg in \
-      *=*|--*) continue;; \
-        -*I) strip_trailopt 'I'; skip_next=yes;; \
-      -*I?*) strip_trailopt 'I';; \
-        -*O) strip_trailopt 'O'; skip_next=yes;; \
-      -*O?*) strip_trailopt 'O';; \
-        -*l) strip_trailopt 'l'; skip_next=yes;; \
-      -*l?*) strip_trailopt 'l';; \
-      -[dEDm]) skip_next=yes;; \
-      -[JT]) skip_next=yes;; \
-    esac; \
-    case $$flg in \
-      *$$target_option*) has_opt=yes; break;; \
-    esac; \
-  done; \
-  test $$has_opt = yes
-am__make_dryrun = (target_option=n; $(am__make_running_with_option))
-am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
-pkgdatadir = $(datadir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkglibexecdir = $(libexecdir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-subdir = egg
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
-	$(top_srcdir)/depcomp
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/intltool.m4 \
-	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
-	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
-	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-CONFIG_CLEAN_VPATH_FILES =
-LTLIBRARIES = $(noinst_LTLIBRARIES)
-am__DEPENDENCIES_1 =
-libeggdesktopfile_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
-am_libeggdesktopfile_la_OBJECTS = eggdesktopfile.lo
-libeggdesktopfile_la_OBJECTS = $(am_libeggdesktopfile_la_OBJECTS)
-AM_V_lt = $(am__v_lt_@AM_V@)
-am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
-am__v_lt_0 = --silent
-am__v_lt_1 = 
-am__DEPENDENCIES_2 = libeggdesktopfile.la $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1)
-am__DEPENDENCIES_3 = $(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_2)
-libeggsmclient_gnome_la_DEPENDENCIES = $(am__DEPENDENCIES_3)
-am__objects_1 = eggsmclient-xsmp.lo
-am_libeggsmclient_gnome_la_OBJECTS = eggsmclient.lo $(am__objects_1)
-libeggsmclient_gnome_la_OBJECTS =  \
-	$(am_libeggsmclient_gnome_la_OBJECTS)
-libeggsmclient_la_DEPENDENCIES = $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_2)
-am_libeggsmclient_la_OBJECTS = eggsmclient.lo $(am__objects_1)
-libeggsmclient_la_OBJECTS = $(am_libeggsmclient_la_OBJECTS)
-AM_V_P = $(am__v_P_@AM_V@)
-am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
-am__v_P_0 = false
-am__v_P_1 = :
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN     " $@;
-am__v_GEN_1 = 
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
-am__v_at_1 = 
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
-depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__depfiles_maybe = depfiles
-am__mv = mv -f
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
-	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
-	$(AM_CFLAGS) $(CFLAGS)
-AM_V_CC = $(am__v_CC_@AM_V@)
-am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
-am__v_CC_0 = @echo "  CC      " $@;
-am__v_CC_1 = 
-CCLD = $(CC)
-LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(AM_LDFLAGS) $(LDFLAGS) -o $@
-AM_V_CCLD = $(am__v_CCLD_@AM_V@)
-am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
-am__v_CCLD_0 = @echo "  CCLD    " $@;
-am__v_CCLD_1 = 
-SOURCES = $(libeggdesktopfile_la_SOURCES) \
-	$(libeggsmclient_gnome_la_SOURCES) \
-	$(libeggsmclient_la_SOURCES)
-DIST_SOURCES = $(libeggdesktopfile_la_SOURCES) \
-	$(libeggsmclient_gnome_la_SOURCES) \
-	$(libeggsmclient_la_SOURCES)
-am__can_run_installinfo = \
-  case $$AM_UPDATE_INFO_DIR in \
-    n|no|NO) false;; \
-    *) (install-info --version) >/dev/null 2>&1;; \
-  esac
-am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
-# Read a list of newline-separated strings from the standard input,
-# and print each of them once, without duplicates.  Input order is
-# *not* preserved.
-am__uniquify_input = $(AWK) '\
-  BEGIN { nonempty = 0; } \
-  { items[$$0] = 1; nonempty = 1; } \
-  END { if (nonempty) { for (i in items) print i; }; } \
-'
-# Make sure the list of sources is unique.  This is necessary because,
-# e.g., the same source file might be shared among _SOURCES variables
-# for different programs/libraries.
-am__define_uniq_tagged_files = \
-  list='$(am__tagged_files)'; \
-  unique=`for i in $$list; do \
-    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-  done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = @ACLOCAL@
-ALL_LINGUAS = @ALL_LINGUAS@
-AMTAR = @AMTAR@
-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
-AR = @AR@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CATALOGS = @CATALOGS@
-CATOBJEXT = @CATOBJEXT@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFLAGS = @CFLAGS@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DATADIRNAME = @DATADIRNAME@
-DBUS_GLIB_CFLAGS = @DBUS_GLIB_CFLAGS@
-DBUS_GLIB_LIBS = @DBUS_GLIB_LIBS@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DISABLE_DEPRECATED = @DISABLE_DEPRECATED@
-DISABLE_DEPRECATED_CFLAGS = @DISABLE_DEPRECATED_CFLAGS@
-DLLTOOL = @DLLTOOL@
-DSYMUTIL = @DSYMUTIL@
-DUMPBIN = @DUMPBIN@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGG_SMCLIENT_CFLAGS = @EGG_SMCLIENT_CFLAGS@
-EGG_SMCLIENT_LIBS = @EGG_SMCLIENT_LIBS@
-EGREP = @EGREP@
-EXECINFO_LIBS = @EXECINFO_LIBS@
-EXEEXT = @EXEEXT@
-FGREP = @FGREP@
-GCONF_CFLAGS = @GCONF_CFLAGS@
-GCONF_LIBS = @GCONF_LIBS@
-GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
-GIOUNIX_CFLAGS = @GIOUNIX_CFLAGS@
-GIOUNIX_LIBS = @GIOUNIX_LIBS@
-GIO_CFLAGS = @GIO_CFLAGS@
-GIO_LIBS = @GIO_LIBS@
-GLIB_COMPILE_SCHEMAS = @GLIB_COMPILE_SCHEMAS@
-GLIB_GENMARSHAL = @GLIB_GENMARSHAL@
-GL_TEST_CFLAGS = @GL_TEST_CFLAGS@
-GL_TEST_LIBS = @GL_TEST_LIBS@
-GMOFILES = @GMOFILES@
-GMSGFMT = @GMSGFMT@
-GNOME_SESSION_CFLAGS = @GNOME_SESSION_CFLAGS@
-GNOME_SESSION_LIBS = @GNOME_SESSION_LIBS@
-GREP = @GREP@
-GSETTINGS_DISABLE_SCHEMAS_COMPILE = @GSETTINGS_DISABLE_SCHEMAS_COMPILE@
-GTK3_CFLAGS = @GTK3_CFLAGS@
-GTK3_LIBS = @GTK3_LIBS@
-HAVE_XRENDER = @HAVE_XRENDER@
-HAVE_XTEST = @HAVE_XTEST@
-ICE_CFLAGS = @ICE_CFLAGS@
-ICE_LIBS = @ICE_LIBS@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-INSTOBJEXT = @INSTOBJEXT@
-INTLLIBS = @INTLLIBS@
-INTLTOOL_EXTRACT = @INTLTOOL_EXTRACT@
-INTLTOOL_MERGE = @INTLTOOL_MERGE@
-INTLTOOL_PERL = @INTLTOOL_PERL@
-INTLTOOL_UPDATE = @INTLTOOL_UPDATE@
-INTLTOOL_V_MERGE = @INTLTOOL_V_MERGE@
-INTLTOOL_V_MERGE_OPTIONS = @INTLTOOL_V_MERGE_OPTIONS@
-INTLTOOL__v_MERGE_ = @INTLTOOL__v_MERGE_@
-INTLTOOL__v_MERGE_0 = @INTLTOOL__v_MERGE_0@
-LD = @LD@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LIPO = @LIPO@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAINT = @MAINT@
-MAKEINFO = @MAKEINFO@
-MANIFEST_TOOL = @MANIFEST_TOOL@
-MKDIR_P = @MKDIR_P@
-MKINSTALLDIRS = @MKINSTALLDIRS@
-MSGFMT = @MSGFMT@
-MSGFMT_OPTS = @MSGFMT_OPTS@
-MSGMERGE = @MSGMERGE@
-NM = @NM@
-NMEDIT = @NMEDIT@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-OTOOL = @OTOOL@
-OTOOL64 = @OTOOL64@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_URL = @PACKAGE_URL@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PKG_CONFIG = @PKG_CONFIG@
-PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
-PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
-POFILES = @POFILES@
-POSUB = @POSUB@
-PO_IN_DATADIR_FALSE = @PO_IN_DATADIR_FALSE@
-PO_IN_DATADIR_TRUE = @PO_IN_DATADIR_TRUE@
-RANLIB = @RANLIB@
-SED = @SED@
-SESSION_PROPERTIES_CFLAGS = @SESSION_PROPERTIES_CFLAGS@
-SESSION_PROPERTIES_LIBS = @SESSION_PROPERTIES_LIBS@
-SESSION_SELECTOR_CFLAGS = @SESSION_SELECTOR_CFLAGS@
-SESSION_SELECTOR_LIBS = @SESSION_SELECTOR_LIBS@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-SM_CFLAGS = @SM_CFLAGS@
-SM_LIBS = @SM_LIBS@
-STRIP = @STRIP@
-SYSTEMD_CFLAGS = @SYSTEMD_CFLAGS@
-SYSTEMD_LIBS = @SYSTEMD_LIBS@
-USE_NLS = @USE_NLS@
-VERSION = @VERSION@
-WARN_CFLAGS = @WARN_CFLAGS@
-X11_CFLAGS = @X11_CFLAGS@
-X11_LIBS = @X11_LIBS@
-XEXT_CFLAGS = @XEXT_CFLAGS@
-XEXT_LIBS = @XEXT_LIBS@
-XGETTEXT = @XGETTEXT@
-XMLTO = @XMLTO@
-XRENDER_CFLAGS = @XRENDER_CFLAGS@
-XRENDER_LIBS = @XRENDER_LIBS@
-XSLTPROC = @XSLTPROC@
-XTEST_CFLAGS = @XTEST_CFLAGS@
-XTEST_LIBS = @XTEST_LIBS@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_AR = @ac_ct_AR@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-gsettingsschemadir = @gsettingsschemadir@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-intltool__v_merge_options_ = @intltool__v_merge_options_@
-intltool__v_merge_options_0 = @intltool__v_merge_options_0@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target_alias = @target_alias@
-top_build_prefix = @top_build_prefix@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-platform_defines = -DEGG_SM_CLIENT_BACKEND_XSMP
-platform_ltlibraries = \
-	libeggdesktopfile.la             \
-	libeggsmclient-gnome.la
-
-platform_libs = \
-	libeggdesktopfile.la		\
-	$(SM_LIBS)			\
-	$(ICE_LIBS)
-
-platform_sources = eggsmclient-xsmp.c
-INCLUDES = \
-	-DG_LOG_DOMAIN=\""EggSMClient"\" \
-	$(platform_defines)              \
-	$(EGG_SMCLIENT_CFLAGS)           \
-	$(SM_CFLAGS)			 \
-	$(ICE_CFLAGS)			 \
-	$(WARN_CFLAGS)			 \
-	$(DISABLE_DEPRECATED_CFLAGS)
-
-noinst_LTLIBRARIES = \
-	libeggsmclient.la                \
-	$(platform_ltlibraries)
-
-libeggsmclient_la_LIBADD = \
-	$(EGG_SMCLIENT_LIBS)             \
-	$(SM_LIBS)			 \
-	$(ICE_LIBS)			 \
-	$(platform_libs)
-
-libeggsmclient_la_SOURCES = \
-	eggsmclient.c                    \
-	eggsmclient.h                    \
-	eggsmclient-private.h            \
-	$(platform_sources)
-
-libeggsmclient_gnome_la_LIBADD = \
-	$(libeggsmclient_la_LIBADD)
-
-libeggsmclient_gnome_la_SOURCES = \
-	eggsmclient.c                    \
-	eggsmclient.h                    \
-	eggsmclient-private.h            \
-	$(platform_sources)
-
-libeggdesktopfile_la_LIBADD = \
-	$(EGG_SMCLIENT_LIBS)
-
-libeggdesktopfile_la_SOURCES = \
-	eggdesktopfile.c                 \
-	eggdesktopfile.h
-
-all: all-am
-
-.SUFFIXES:
-.SUFFIXES: .c .lo .o .obj
-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
-	        && { if test -f $@; then exit 0; else break; fi; }; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu egg/Makefile'; \
-	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --gnu egg/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(am__aclocal_m4_deps):
-
-clean-noinstLTLIBRARIES:
-	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
-	@list='$(noinst_LTLIBRARIES)'; \
-	locs=`for p in $$list; do echo $$p; done | \
-	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
-	      sort -u`; \
-	test -z "$$locs" || { \
-	  echo rm -f $${locs}; \
-	  rm -f $${locs}; \
-	}
-
-libeggdesktopfile.la: $(libeggdesktopfile_la_OBJECTS) $(libeggdesktopfile_la_DEPENDENCIES) $(EXTRA_libeggdesktopfile_la_DEPENDENCIES) 
-	$(AM_V_CCLD)$(LINK)  $(libeggdesktopfile_la_OBJECTS) $(libeggdesktopfile_la_LIBADD) $(LIBS)
-
-libeggsmclient-gnome.la: $(libeggsmclient_gnome_la_OBJECTS) $(libeggsmclient_gnome_la_DEPENDENCIES) $(EXTRA_libeggsmclient_gnome_la_DEPENDENCIES) 
-	$(AM_V_CCLD)$(LINK)  $(libeggsmclient_gnome_la_OBJECTS) $(libeggsmclient_gnome_la_LIBADD) $(LIBS)
-
-libeggsmclient.la: $(libeggsmclient_la_OBJECTS) $(libeggsmclient_la_DEPENDENCIES) $(EXTRA_libeggsmclient_la_DEPENDENCIES) 
-	$(AM_V_CCLD)$(LINK)  $(libeggsmclient_la_OBJECTS) $(libeggsmclient_la_LIBADD) $(LIBS)
-
-mostlyclean-compile:
-	-rm -f *.$(OBJEXT)
-
-distclean-compile:
-	-rm -f *.tab.c
-
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eggdesktopfile.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eggsmclient-xsmp.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eggsmclient.Plo@am__quote@
-
-.c.o:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c $<
-
-.c.obj:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c `$(CYGPATH_W) '$<'`
-
-.c.lo:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o $@ $<
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-ID: $(am__tagged_files)
-	$(am__define_uniq_tagged_files); mkid -fID $$unique
-tags: tags-am
-TAGS: tags
-
-tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
-	set x; \
-	here=`pwd`; \
-	$(am__define_uniq_tagged_files); \
-	shift; \
-	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  if test $$# -gt 0; then \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      "$$@" $$unique; \
-	  else \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      $$unique; \
-	  fi; \
-	fi
-ctags: ctags-am
-
-CTAGS: ctags
-ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
-	$(am__define_uniq_tagged_files); \
-	test -z "$(CTAGS_ARGS)$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && $(am__cd) $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) "$$here"
-cscopelist: cscopelist-am
-
-cscopelist-am: $(am__tagged_files)
-	list='$(am__tagged_files)'; \
-	case "$(srcdir)" in \
-	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
-	  *) sdir=$(subdir)/$(srcdir) ;; \
-	esac; \
-	for i in $$list; do \
-	  if test -f "$$i"; then \
-	    echo "$(subdir)/$$i"; \
-	  else \
-	    echo "$$sdir/$$i"; \
-	  fi; \
-	done >> $(top_builddir)/cscope.files
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
-	    if test -d "$(distdir)/$$file"; then \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
-	  else \
-	    test -f "$(distdir)/$$file" \
-	    || cp -p $$d/$$file "$(distdir)/$$file" \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-am
-all-am: Makefile $(LTLIBRARIES)
-installdirs:
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	if test -z '$(STRIP)'; then \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	      install; \
-	else \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
-	fi
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am
-
-clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
-	mostlyclean-am
-
-distclean: distclean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-tags
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-html-am:
-
-info: info-am
-
-info-am:
-
-install-data-am:
-
-install-dvi: install-dvi-am
-
-install-dvi-am:
-
-install-exec-am:
-
-install-html: install-html-am
-
-install-html-am:
-
-install-info: install-info-am
-
-install-info-am:
-
-install-man:
-
-install-pdf: install-pdf-am
-
-install-pdf-am:
-
-install-ps: install-ps-am
-
-install-ps-am:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am:
-
-.MAKE: install-am install-strip
-
-.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
-	clean-libtool clean-noinstLTLIBRARIES cscopelist-am ctags \
-	ctags-am distclean distclean-compile distclean-generic \
-	distclean-libtool distclean-tags distdir dvi dvi-am html \
-	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	tags tags-am uninstall uninstall-am
-
-
--include $(top_srcdir)/git.mk
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
diff --git a/egg/eggdesktopfile.c b/egg/eggdesktopfile.c
deleted file mode 100644
index 443d5ec..0000000
--- a/egg/eggdesktopfile.c
+++ /dev/null
@@ -1,1528 +0,0 @@
-/* eggdesktopfile.c - Freedesktop.Org Desktop Files
- * Copyright (C) 2007 Novell, Inc.
- *
- * Based on gnome-desktop-item.c
- * Copyright (C) 1999, 2000 Red Hat Inc.
- * Copyright (C) 2001 George Lebl
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public License
- * as published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; see the file COPYING.LIB. If not,
- * write to the Free Software Foundation, Inc., 59 Temple Place -
- * Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "eggdesktopfile.h"
-
-#include <string.h>
-#include <unistd.h>
-
-#include <glib/gi18n.h>
-#include <gdk/gdkx.h>
-#include <gtk/gtk.h>
-
-struct EggDesktopFile {
-  GKeyFile           *key_file;
-  char               *source;
-
-  char               *name, *icon;
-  EggDesktopFileType  type;
-  char                document_code;
-};
-
-/**
- * egg_desktop_file_new:
- * @desktop_file_path: path to a Freedesktop-style Desktop file
- * @error: error pointer
- *
- * Creates a new #EggDesktopFile for @desktop_file.
- *
- * Return value: the new #EggDesktopFile, or %NULL on error.
- **/
-EggDesktopFile *
-egg_desktop_file_new (const char *desktop_file_path, GError **error)
-{
-  GKeyFile *key_file;
-
-  key_file = g_key_file_new ();
-  if (!g_key_file_load_from_file (key_file, desktop_file_path, 0, error))
-    {
-      g_key_file_free (key_file);
-      return NULL;
-    }
-
-  return egg_desktop_file_new_from_key_file (key_file, desktop_file_path,
-					     error);
-}
-
-/**
- * egg_desktop_file_new_from_data_dirs:
- * @desktop_file_path: relative path to a Freedesktop-style Desktop file
- * @error: error pointer
- *
- * Looks for @desktop_file_path in the paths returned from
- * g_get_user_data_dir() and g_get_system_data_dirs(), and creates
- * a new #EggDesktopFile from it.
- *
- * Return value: the new #EggDesktopFile, or %NULL on error.
- **/
-EggDesktopFile *
-egg_desktop_file_new_from_data_dirs (const char  *desktop_file_path,
-				     GError     **error)
-{
-  EggDesktopFile *desktop_file;
-  GKeyFile *key_file;
-  char *full_path;
-
-  key_file = g_key_file_new ();
-  if (!g_key_file_load_from_data_dirs (key_file, desktop_file_path,
-				       &full_path, 0, error))
-    {
-      g_key_file_free (key_file);
-      return NULL;
-    }
-
-  desktop_file = egg_desktop_file_new_from_key_file (key_file,
-						     full_path,
-						     error);
-  g_free (full_path);
-  return desktop_file;
-}
-
-/**
- * egg_desktop_file_new_from_dirs:
- * @desktop_file_path: relative path to a Freedesktop-style Desktop file
- * @search_dirs: NULL-terminated array of directories to search
- * @error: error pointer
- *
- * Looks for @desktop_file_path in the paths returned from
- * g_get_user_data_dir() and g_get_system_data_dirs(), and creates
- * a new #EggDesktopFile from it.
- *
- * Return value: the new #EggDesktopFile, or %NULL on error.
- **/
-EggDesktopFile *
-egg_desktop_file_new_from_dirs (const char  *desktop_file_path,
-				const char **search_dirs,
-				GError     **error)
-{
-  EggDesktopFile *desktop_file;
-  GKeyFile *key_file;
-  char *full_path;
-
-  key_file = g_key_file_new ();
-  if (!g_key_file_load_from_dirs (key_file, desktop_file_path, search_dirs,
-				  &full_path, 0, error))
-    {
-      g_key_file_free (key_file);
-      return NULL;
-    }
-
-  desktop_file = egg_desktop_file_new_from_key_file (key_file,
-						     full_path,
-						     error);
-  g_free (full_path);
-  return desktop_file;
-}
-
-/**
- * egg_desktop_file_new_from_key_file:
- * @key_file: a #GKeyFile representing a desktop file
- * @source: the path or URI that @key_file was loaded from, or %NULL
- * @error: error pointer
- *
- * Creates a new #EggDesktopFile for @key_file. Assumes ownership of
- * @key_file (on success or failure); you should consider @key_file to
- * be freed after calling this function.
- *
- * Return value: the new #EggDesktopFile, or %NULL on error.
- **/
-EggDesktopFile *
-egg_desktop_file_new_from_key_file (GKeyFile    *key_file,
-				    const char  *source,
-				    GError     **error)
-{
-  EggDesktopFile *desktop_file;
-  char *version, *type;
-
-  if (!g_key_file_has_group (key_file, EGG_DESKTOP_FILE_GROUP))
-    {
-      g_set_error (error, EGG_DESKTOP_FILE_ERROR,
-		   EGG_DESKTOP_FILE_ERROR_INVALID,
-		   _("File is not a valid .desktop file"));
-      g_key_file_free (key_file);
-      return NULL;
-    }
-
-  version = g_key_file_get_value (key_file, EGG_DESKTOP_FILE_GROUP,
-				  EGG_DESKTOP_FILE_KEY_VERSION,
-				  NULL);
-  if (version)
-    {
-      double version_num;
-      char *end;
-
-      version_num = g_ascii_strtod (version, &end);
-      if (*end)
-	{
-	  g_warning ("Invalid Version string '%s' in %s",
-		     version, source ? source : "(unknown)");
-	}
-      else if (version_num > 1.0)
-	{
-	  g_set_error (error, EGG_DESKTOP_FILE_ERROR,
-		       EGG_DESKTOP_FILE_ERROR_INVALID,
-		       /* translators: 'Version' is from a desktop file, and
-			* should not be translated. '%s' would probably be a
-			* version number. */
-		       _("Unrecognized desktop file Version '%s'"), version);
-	  g_free (version);
-	  g_key_file_free (key_file);
-	  return NULL;
-	}
-      g_free (version);
-    }
-
-  desktop_file = g_new0 (EggDesktopFile, 1);
-  desktop_file->key_file = key_file;
-
-  if (g_path_is_absolute (source))
-    desktop_file->source = g_filename_to_uri (source, NULL, NULL);
-  else
-    desktop_file->source = g_strdup (source);
-
-  desktop_file->name = g_key_file_get_locale_string (key_file,
-						     EGG_DESKTOP_FILE_GROUP,
-						     EGG_DESKTOP_FILE_KEY_NAME,
-						     NULL,
-						     error);
-  if (!desktop_file->name)
-    {
-      egg_desktop_file_free (desktop_file);
-      return NULL;
-    }
-
-  type = g_key_file_get_string (key_file, EGG_DESKTOP_FILE_GROUP,
-				EGG_DESKTOP_FILE_KEY_TYPE, error);
-  if (!type)
-    {
-      egg_desktop_file_free (desktop_file);
-      return NULL;
-    }
-
-  if (!strcmp (type, "Application"))
-    {
-      char *exec, *p;
-
-      desktop_file->type = EGG_DESKTOP_FILE_TYPE_APPLICATION;
-
-      exec = g_key_file_get_string (key_file,
-				    EGG_DESKTOP_FILE_GROUP,
-				    EGG_DESKTOP_FILE_KEY_EXEC,
-				    error);
-      if (!exec)
-	{
-	  egg_desktop_file_free (desktop_file);
-	  g_free (type);
-	  return NULL;
-	}
-
-      /* See if it takes paths or URIs or neither */
-      for (p = exec; *p; p++)
-	{
-	  if (*p == '%')
-	    {
-	      if (p[1] == '\0' || strchr ("FfUu", p[1]))
-		{
-		  desktop_file->document_code = p[1];
-		  break;
-		}
-	      p++;
-	    }
-	}
-
-      g_free (exec);
-    }
-  else if (!strcmp (type, "Link"))
-    {
-      char *url;
-
-      desktop_file->type = EGG_DESKTOP_FILE_TYPE_LINK;
-
-      url = g_key_file_get_string (key_file,
-				   EGG_DESKTOP_FILE_GROUP,
-				   EGG_DESKTOP_FILE_KEY_URL,
-				   error);
-      if (!url)
-	{
-	  egg_desktop_file_free (desktop_file);
-	  g_free (type);
-	  return NULL;
-	}
-      g_free (url);
-    }
-  else if (!strcmp (type, "Directory"))
-    desktop_file->type = EGG_DESKTOP_FILE_TYPE_DIRECTORY;
-  else
-    desktop_file->type = EGG_DESKTOP_FILE_TYPE_UNRECOGNIZED;
-
-  g_free (type);
-
-  /* Check the Icon key */
-  desktop_file->icon = g_key_file_get_string (key_file,
-					      EGG_DESKTOP_FILE_GROUP,
-					      EGG_DESKTOP_FILE_KEY_ICON,
-					      NULL);
-  if (desktop_file->icon && !g_path_is_absolute (desktop_file->icon))
-    {
-      char *ext;
-
-      /* Lots of .desktop files still get this wrong */
-      ext = strrchr (desktop_file->icon, '.');
-      if (ext && (!strcmp (ext, ".png") ||
-		  !strcmp (ext, ".xpm") ||
-		  !strcmp (ext, ".svg")))
-	{
-	  g_warning ("Desktop file '%s' has malformed Icon key '%s'"
-		     "(should not include extension)",
-		     source ? source : "(unknown)",
-		     desktop_file->icon);
-	  *ext = '\0';
-	}
-    }
-
-  return desktop_file;
-}
-
-/**
- * egg_desktop_file_free:
- * @desktop_file: an #EggDesktopFile
- *
- * Frees @desktop_file.
- **/
-void
-egg_desktop_file_free (EggDesktopFile *desktop_file)
-{
-  g_key_file_free (desktop_file->key_file);
-  g_free (desktop_file->source);
-  g_free (desktop_file->name);
-  g_free (desktop_file->icon);
-  g_free (desktop_file);
-}
-
-/**
- * egg_desktop_file_get_source:
- * @desktop_file: an #EggDesktopFile
- *
- * Gets the URI that @desktop_file was loaded from.
- *
- * Return value: @desktop_file's source URI
- **/
-const char *
-egg_desktop_file_get_source (EggDesktopFile *desktop_file)
-{
-  return desktop_file->source;
-}
-
-/**
- * egg_desktop_file_get_desktop_file_type:
- * @desktop_file: an #EggDesktopFile
- *
- * Gets the desktop file type of @desktop_file.
- *
- * Return value: @desktop_file's type
- **/
-EggDesktopFileType
-egg_desktop_file_get_desktop_file_type (EggDesktopFile *desktop_file)
-{
-  return desktop_file->type;
-}
-
-/**
- * egg_desktop_file_get_name:
- * @desktop_file: an #EggDesktopFile
- *
- * Gets the (localized) value of @desktop_file's "Name" key.
- *
- * Return value: the application/link name
- **/
-const char *
-egg_desktop_file_get_name (EggDesktopFile *desktop_file)
-{
-  return desktop_file->name;
-}
-
-/**
- * egg_desktop_file_get_icon:
- * @desktop_file: an #EggDesktopFile
- *
- * Gets the value of @desktop_file's "Icon" key.
- *
- * If the icon string is a full path (that is, if g_path_is_absolute()
- * returns %TRUE when called on it), it points to a file containing an
- * unthemed icon. If the icon string is not a full path, it is the
- * name of a themed icon, which can be looked up with %GtkIconTheme,
- * or passed directly to a theme-aware widget like %GtkImage or
- * %GtkCellRendererPixbuf.
- *
- * Return value: the icon path or name
- **/
-const char *
-egg_desktop_file_get_icon (EggDesktopFile *desktop_file)
-{
-  return desktop_file->icon;
-}
-
-gboolean
-egg_desktop_file_has_key (EggDesktopFile  *desktop_file,
-			  const char      *key,
-			  GError         **error)
-{
-  return g_key_file_has_key (desktop_file->key_file,
-			     EGG_DESKTOP_FILE_GROUP, key,
-			     error);
-}
-
-char *
-egg_desktop_file_get_string (EggDesktopFile  *desktop_file,
-			     const char      *key,
-			     GError         **error)
-{
-  return g_key_file_get_string (desktop_file->key_file,
-				EGG_DESKTOP_FILE_GROUP, key,
-				error);
-}
-
-char *
-egg_desktop_file_get_locale_string (EggDesktopFile  *desktop_file,
-				    const char      *key,
-				    const char      *locale,
-				    GError         **error)
-{
-  return g_key_file_get_locale_string (desktop_file->key_file,
-				       EGG_DESKTOP_FILE_GROUP, key, locale,
-				       error);
-}
-
-gboolean
-egg_desktop_file_get_boolean (EggDesktopFile  *desktop_file,
-			      const char      *key,
-			      GError         **error)
-{
-  return g_key_file_get_boolean (desktop_file->key_file,
-				 EGG_DESKTOP_FILE_GROUP, key,
-				 error);
-}
-
-double
-egg_desktop_file_get_numeric (EggDesktopFile  *desktop_file,
-			      const char      *key,
-			      GError         **error)
-{
-  return g_key_file_get_double (desktop_file->key_file,
-				EGG_DESKTOP_FILE_GROUP, key,
-				error);
-}
-
-int
-egg_desktop_file_get_integer (EggDesktopFile *desktop_file,
-			      const char     *key,
-    			      GError	    **error)
-{
-  return g_key_file_get_integer (desktop_file->key_file,
-				 EGG_DESKTOP_FILE_GROUP, key,
-				 error);
-}
-
-char **
-egg_desktop_file_get_string_list (EggDesktopFile  *desktop_file,
-				  const char      *key,
-				  gsize           *length,
-				  GError         **error)
-{
-  return g_key_file_get_string_list (desktop_file->key_file,
-				     EGG_DESKTOP_FILE_GROUP, key, length,
-				     error);
-}
-
-char **
-egg_desktop_file_get_locale_string_list (EggDesktopFile  *desktop_file,
-					 const char      *key,
-					 const char      *locale,
-					 gsize           *length,
-					 GError         **error)
-{
-  return g_key_file_get_locale_string_list (desktop_file->key_file,
-					    EGG_DESKTOP_FILE_GROUP, key,
-					    locale, length,
-					    error);
-}
-
-/**
- * egg_desktop_file_can_launch:
- * @desktop_file: an #EggDesktopFile
- * @desktop_environment: the name of the running desktop environment,
- * or %NULL
- *
- * Tests if @desktop_file can/should be launched in the current
- * environment. If @desktop_environment is non-%NULL, @desktop_file's
- * "OnlyShowIn" and "NotShowIn" keys are checked to make sure that
- * this desktop_file is appropriate for the named environment.
- *
- * Furthermore, if @desktop_file has type
- * %EGG_DESKTOP_FILE_TYPE_APPLICATION, its "TryExec" key (if any) is
- * also checked, to make sure the binary it points to exists.
- *
- * egg_desktop_file_can_launch() does NOT check the value of the
- * "Hidden" key.
- *
- * Return value: %TRUE if @desktop_file can be launched
- **/
-gboolean
-egg_desktop_file_can_launch (EggDesktopFile *desktop_file,
-			     const char     *desktop_environment)
-{
-  char *try_exec, *found_program;
-  char **only_show_in, **not_show_in;
-  gboolean found;
-  int i;
-
-  if (desktop_file->type != EGG_DESKTOP_FILE_TYPE_APPLICATION &&
-      desktop_file->type != EGG_DESKTOP_FILE_TYPE_LINK)
-    return FALSE;
-
-  if (desktop_environment)
-    {
-      only_show_in = g_key_file_get_string_list (desktop_file->key_file,
-						 EGG_DESKTOP_FILE_GROUP,
-						 EGG_DESKTOP_FILE_KEY_ONLY_SHOW_IN,
-						 NULL, NULL);
-      if (only_show_in)
-	{
-	  for (i = 0, found = FALSE; only_show_in[i] && !found; i++)
-	    {
-	      if (!strcmp (only_show_in[i], desktop_environment))
-		found = TRUE;
-	    }
-
-	  g_strfreev (only_show_in);
-
-	  if (!found)
-	    return FALSE;
-	}
-
-      not_show_in = g_key_file_get_string_list (desktop_file->key_file,
-						EGG_DESKTOP_FILE_GROUP,
-						EGG_DESKTOP_FILE_KEY_NOT_SHOW_IN,
-						NULL, NULL);
-      if (not_show_in)
-	{
-	  for (i = 0, found = FALSE; not_show_in[i] && !found; i++)
-	    {
-	      if (!strcmp (not_show_in[i], desktop_environment))
-		found = TRUE;
-	    }
-
-	  g_strfreev (not_show_in);
-
-	  if (found)
-	    return FALSE;
-	}
-    }
-
-  if (desktop_file->type == EGG_DESKTOP_FILE_TYPE_APPLICATION)
-    {
-      try_exec = g_key_file_get_string (desktop_file->key_file,
-					EGG_DESKTOP_FILE_GROUP,
-					EGG_DESKTOP_FILE_KEY_TRY_EXEC,
-					NULL);
-      if (try_exec)
-	{
-	  found_program = g_find_program_in_path (try_exec);
-	  g_free (try_exec);
-
-	  if (!found_program)
-	    return FALSE;
-	  g_free (found_program);
-	}
-    }
-
-  return TRUE;
-}
-
-/**
- * egg_desktop_file_accepts_documents:
- * @desktop_file: an #EggDesktopFile
- *
- * Tests if @desktop_file represents an application that can accept
- * documents on the command line.
- *
- * Return value: %TRUE or %FALSE
- **/
-gboolean
-egg_desktop_file_accepts_documents (EggDesktopFile *desktop_file)
-{
-  return desktop_file->document_code != 0;
-}
-
-/**
- * egg_desktop_file_accepts_multiple:
- * @desktop_file: an #EggDesktopFile
- *
- * Tests if @desktop_file can accept multiple documents at once.
- *
- * If this returns %FALSE, you can still pass multiple documents to
- * egg_desktop_file_launch(), but that will result in multiple copies
- * of the application being launched. See egg_desktop_file_launch()
- * for more details.
- *
- * Return value: %TRUE or %FALSE
- **/
-gboolean
-egg_desktop_file_accepts_multiple (EggDesktopFile *desktop_file)
-{
-  return (desktop_file->document_code == 'F' ||
-	  desktop_file->document_code == 'U');
-}
-
-/**
- * egg_desktop_file_accepts_uris:
- * @desktop_file: an #EggDesktopFile
- *
- * Tests if @desktop_file can accept (non-"file:") URIs as documents to
- * open.
- *
- * Return value: %TRUE or %FALSE
- **/
-gboolean
-egg_desktop_file_accepts_uris (EggDesktopFile *desktop_file)
-{
-  return (desktop_file->document_code == 'U' ||
-	  desktop_file->document_code == 'u');
-}
-
-static void
-append_quoted_word (GString    *str,
-		    const char *s,
-		    gboolean    in_single_quotes,
-		    gboolean    in_double_quotes)
-{
-  const char *p;
-
-  if (!in_single_quotes && !in_double_quotes)
-    g_string_append_c (str, '\'');
-  else if (!in_single_quotes && in_double_quotes)
-    g_string_append (str, "\"'");
-
-  if (!strchr (s, '\''))
-    g_string_append (str, s);
-  else
-    {
-      for (p = s; *p != '\0'; p++)
-	{
-	  if (*p == '\'')
-	    g_string_append (str, "'\\''");
-	  else
-	    g_string_append_c (str, *p);
-	}
-    }
-
-  if (!in_single_quotes && !in_double_quotes)
-    g_string_append_c (str, '\'');
-  else if (!in_single_quotes && in_double_quotes)
-    g_string_append (str, "'\"");
-}
-
-static void
-do_percent_subst (EggDesktopFile *desktop_file,
-		  char            code,
-		  GString        *str,
-		  GSList        **documents,
-		  gboolean        in_single_quotes,
-		  gboolean        in_double_quotes)
-{
-  GSList *d;
-  char *doc;
-
-  switch (code)
-    {
-    case '%':
-      g_string_append_c (str, '%');
-      break;
-
-    case 'F':
-    case 'U':
-      for (d = *documents; d; d = d->next)
-	{
-	  doc = d->data;
-	  g_string_append (str, " ");
-	  append_quoted_word (str, doc, in_single_quotes, in_double_quotes);
-	}
-      *documents = NULL;
-      break;
-
-    case 'f':
-    case 'u':
-      if (*documents)
-	{
-	  doc = (*documents)->data;
-	  g_string_append (str, " ");
-	  append_quoted_word (str, doc, in_single_quotes, in_double_quotes);
-	  *documents = (*documents)->next;
-	}
-      break;
-
-    case 'i':
-      if (desktop_file->icon)
-	{
-	  g_string_append (str, "--icon ");
-	  append_quoted_word (str, desktop_file->icon,
-			      in_single_quotes, in_double_quotes);
-	}
-      break;
-
-    case 'c':
-      if (desktop_file->name)
-	{
-	  append_quoted_word (str, desktop_file->name,
-			      in_single_quotes, in_double_quotes);
-	}
-      break;
-
-    case 'k':
-      if (desktop_file->source)
-	{
-	  append_quoted_word (str, desktop_file->source,
-			      in_single_quotes, in_double_quotes);
-	}
-      break;
-
-    case 'D':
-    case 'N':
-    case 'd':
-    case 'n':
-    case 'v':
-    case 'm':
-      /* Deprecated; skip */
-      break;
-
-    default:
-      g_warning ("Unrecognized %%-code '%%%c' in Exec", code);
-      break;
-    }
-}
-
-static char *
-parse_exec (EggDesktopFile  *desktop_file,
-	    GSList         **documents,
-	    GError         **error)
-{
-  char *exec, *p, *command;
-  gboolean escape, single_quot, double_quot;
-  GString *gs;
-
-  exec = g_key_file_get_string (desktop_file->key_file,
-				EGG_DESKTOP_FILE_GROUP,
-				EGG_DESKTOP_FILE_KEY_EXEC,
-				error);
-  if (!exec)
-    return NULL;
-
-  /* Build the command */
-  gs = g_string_new (NULL);
-  escape = single_quot = double_quot = FALSE;
-
-  for (p = exec; *p != '\0'; p++)
-    {
-      if (escape)
-	{
-	  escape = FALSE;
-	  g_string_append_c (gs, *p);
-	}
-      else if (*p == '\\')
-	{
-	  if (!single_quot)
-	    escape = TRUE;
-	  g_string_append_c (gs, *p);
-	}
-      else if (*p == '\'')
-	{
-	  g_string_append_c (gs, *p);
-	  if (!single_quot && !double_quot)
-	    single_quot = TRUE;
-	  else if (single_quot)
-	    single_quot = FALSE;
-	}
-      else if (*p == '"')
-	{
-	  g_string_append_c (gs, *p);
-	  if (!single_quot && !double_quot)
-	    double_quot = TRUE;
-	  else if (double_quot)
-	    double_quot = FALSE;
-	}
-      else if (*p == '%' && p[1])
-	{
-	  do_percent_subst (desktop_file, p[1], gs, documents,
-			    single_quot, double_quot);
-	  p++;
-	}
-      else
-	g_string_append_c (gs, *p);
-    }
-
-  g_free (exec);
-  command = g_string_free (gs, FALSE);
-
-  /* Prepend "xdg-terminal " if needed (FIXME: use gvfs) */
-  if (g_key_file_has_key (desktop_file->key_file,
-			  EGG_DESKTOP_FILE_GROUP,
-			  EGG_DESKTOP_FILE_KEY_TERMINAL,
-			  NULL))
-    {
-      GError *terminal_error = NULL;
-      gboolean use_terminal =
-	g_key_file_get_boolean (desktop_file->key_file,
-				EGG_DESKTOP_FILE_GROUP,
-				EGG_DESKTOP_FILE_KEY_TERMINAL,
-				&terminal_error);
-      if (terminal_error)
-	{
-	  g_free (command);
-	  g_propagate_error (error, terminal_error);
-	  return NULL;
-	}
-
-      if (use_terminal)
-	{
-	  gs = g_string_new ("xdg-terminal ");
-	  append_quoted_word (gs, command, FALSE, FALSE);
-	  g_free (command);
-	  command = g_string_free (gs, FALSE);
-	}
-    }
-
-  return command;
-}
-
-static GSList *
-translate_document_list (EggDesktopFile *desktop_file, GSList *documents)
-{
-  gboolean accepts_uris = egg_desktop_file_accepts_uris (desktop_file);
-  GSList *ret, *d;
-
-  for (d = documents, ret = NULL; d; d = d->next)
-    {
-      const char *document = d->data;
-      gboolean is_uri = !g_path_is_absolute (document);
-      char *translated;
-
-      if (accepts_uris)
-	{
-	  if (is_uri)
-	    translated = g_strdup (document);
-	  else
-	    translated = g_filename_to_uri (document, NULL, NULL);
-	}
-      else
-	{
-	  if (is_uri)
-	    translated = g_filename_from_uri (document, NULL, NULL);
-	  else
-	    translated = g_strdup (document);
-	}
-
-      if (translated)
-	ret = g_slist_prepend (ret, translated);
-    }
-
-  return g_slist_reverse (ret);
-}
-
-static void
-free_document_list (GSList *documents)
-{
-  GSList *d;
-
-  for (d = documents; d; d = d->next)
-    g_free (d->data);
-  g_slist_free (documents);
-}
-
-/**
- * egg_desktop_file_parse_exec:
- * @desktop_file: a #EggDesktopFile
- * @documents: a list of document paths or URIs
- * @error: error pointer
- *
- * Parses @desktop_file's Exec key, inserting @documents into it, and
- * returns the result.
- *
- * If @documents contains non-file: URIs and @desktop_file does not
- * accept URIs, those URIs will be ignored. Likewise, if @documents
- * contains more elements than @desktop_file accepts, the extra
- * documents will be ignored.
- *
- * Return value: the parsed Exec string
- **/
-char *
-egg_desktop_file_parse_exec (EggDesktopFile  *desktop_file,
-			     GSList          *documents,
-			     GError         **error)
-{
-  GSList *translated, *docs;
-  char *command;
-
-  docs = translated = translate_document_list (desktop_file, documents);
-  command = parse_exec (desktop_file, &docs, error);
-  free_document_list (translated);
-
-  return command;
-}
-
-static gboolean
-parse_link (EggDesktopFile  *desktop_file,
-	    EggDesktopFile **app_desktop_file,
-	    GSList         **documents,
-	    GError         **error)
-{
-  char *url;
-  GKeyFile *key_file;
-
-  url = g_key_file_get_string (desktop_file->key_file,
-			       EGG_DESKTOP_FILE_GROUP,
-			       EGG_DESKTOP_FILE_KEY_URL,
-			       error);
-  if (!url)
-    return FALSE;
-  *documents = g_slist_prepend (NULL, url);
-
-  /* FIXME: use gvfs */
-  key_file = g_key_file_new ();
-  g_key_file_set_string (key_file, EGG_DESKTOP_FILE_GROUP,
-			 EGG_DESKTOP_FILE_KEY_NAME,
-			 "xdg-open");
-  g_key_file_set_string (key_file, EGG_DESKTOP_FILE_GROUP,
-			 EGG_DESKTOP_FILE_KEY_TYPE,
-			 "Application");
-  g_key_file_set_string (key_file, EGG_DESKTOP_FILE_GROUP,
-			 EGG_DESKTOP_FILE_KEY_EXEC,
-			 "xdg-open %u");
-  *app_desktop_file = egg_desktop_file_new_from_key_file (key_file, NULL, NULL);
-  return TRUE;
-}
-
-#if GTK_CHECK_VERSION (2, 12, 0)
-static char *
-start_startup_notification (GdkDisplay     *display,
-			    EggDesktopFile *desktop_file,
-			    const char     *argv0,
-			    int             screen,
-			    int             workspace,
-			    guint32         launch_time)
-{
-  static int sequence = 0;
-  char *startup_id;
-  char *description, *wmclass;
-  char *screen_str, *workspace_str;
-
-  if (g_key_file_has_key (desktop_file->key_file,
-			  EGG_DESKTOP_FILE_GROUP,
-			  EGG_DESKTOP_FILE_KEY_STARTUP_NOTIFY,
-			  NULL))
-    {
-      if (!g_key_file_get_boolean (desktop_file->key_file,
-				   EGG_DESKTOP_FILE_GROUP,
-				   EGG_DESKTOP_FILE_KEY_STARTUP_NOTIFY,
-				   NULL))
-	return NULL;
-      wmclass = NULL;
-    }
-  else
-    {
-      wmclass = g_key_file_get_string (desktop_file->key_file,
-				       EGG_DESKTOP_FILE_GROUP,
-				       EGG_DESKTOP_FILE_KEY_STARTUP_WM_CLASS,
-				       NULL);
-      if (!wmclass)
-	return NULL;
-    }
-
-  if (launch_time == (guint32)-1)
-    launch_time = gdk_x11_display_get_user_time (display);
-  startup_id = g_strdup_printf ("%s-%lu-%s-%s-%d_TIME%lu",
-				g_get_prgname (),
-				(unsigned long)getpid (),
-				g_get_host_name (),
-				argv0,
-				sequence++,
-				(unsigned long)launch_time);
-
-  description = g_strdup_printf (_("Starting %s"), desktop_file->name);
-  screen_str = g_strdup_printf ("%d", screen);
-  workspace_str = workspace == -1 ? NULL : g_strdup_printf ("%d", workspace);
-
-  gdk_x11_display_broadcast_startup_message (display, "new",
-					     "ID", startup_id,
-					     "NAME", desktop_file->name,
-					     "SCREEN", screen_str,
-					     "BIN", argv0,
-					     "ICON", desktop_file->icon,
-					     "DESKTOP", workspace_str,
-					     "DESCRIPTION", description,
-					     "WMCLASS", wmclass,
-					     NULL);
-
-  g_free (description);
-  g_free (wmclass);
-  g_free (screen_str);
-  g_free (workspace_str);
-
-  return startup_id;
-}
-
-static void
-end_startup_notification (GdkDisplay *display,
-			  const char *startup_id)
-{
-  gdk_x11_display_broadcast_startup_message (display, "remove",
-					     "ID", startup_id,
-					     NULL);
-}
-
-#define EGG_DESKTOP_FILE_SN_TIMEOUT_LENGTH (30 /* seconds */)
-
-typedef struct {
-  GdkDisplay *display;
-  char *startup_id;
-} StartupNotificationData;
-
-static gboolean
-startup_notification_timeout (gpointer data)
-{
-  StartupNotificationData *sn_data = data;
-
-  end_startup_notification (sn_data->display, sn_data->startup_id);
-  g_object_unref (sn_data->display);
-  g_free (sn_data->startup_id);
-  g_free (sn_data);
-
-  return FALSE;
-}
-
-static void
-set_startup_notification_timeout (GdkDisplay *display,
-				  const char *startup_id)
-{
-  StartupNotificationData *sn_data;
-
-  sn_data = g_new (StartupNotificationData, 1);
-  sn_data->display = g_object_ref (display);
-  sn_data->startup_id = g_strdup (startup_id);
-
-  g_timeout_add_seconds (EGG_DESKTOP_FILE_SN_TIMEOUT_LENGTH,
-			 startup_notification_timeout, sn_data);
-}
-#endif /* GTK 2.12 */
-
-static GPtrArray *
-array_putenv (GPtrArray *env, char *variable)
-{
-  guint i, keylen;
-
-  if (!env)
-    {
-      char **envp;
-
-      env = g_ptr_array_new ();
-
-      envp = g_listenv ();
-      for (i = 0; envp[i]; i++)
-        {
-          const char *value;
-
-          value = g_getenv (envp[i]);
-          g_ptr_array_add (env, g_strdup_printf ("%s=%s", envp[i],
-                                                 value ? value : ""));
-        }
-      g_strfreev (envp);
-    }
-
-  keylen = strcspn (variable, "=");
-
-  /* Remove old value of key */
-  for (i = 0; i < env->len; i++)
-    {
-      char *envvar = env->pdata[i];
-
-      if (!strncmp (envvar, variable, keylen) && envvar[keylen] == '=')
-	{
-	  g_free (envvar);
-	  g_ptr_array_remove_index_fast (env, i);
-	  break;
-	}
-    }
-
-  /* Add new value */
-  g_ptr_array_add (env, g_strdup (variable));
-
-  return env;
-}
-
-static gboolean
-egg_desktop_file_launchv (EggDesktopFile *desktop_file,
-			  GSList *documents, va_list args,
-			  GError **error)
-{
-  EggDesktopFileLaunchOption option;
-  GSList *translated_documents = NULL, *docs = NULL;
-  char *command, **argv;
-  int argc, i, screen_num;
-  gboolean success, current_success;
-  GdkDisplay *display;
-  char *startup_id;
-
-  GPtrArray   *env = NULL;
-  char       **variables = NULL;
-  GdkScreen   *screen = NULL;
-  int          workspace = -1;
-  const char  *directory = NULL;
-  guint32      launch_time = (guint32)-1;
-  GSpawnFlags  flags = G_SPAWN_SEARCH_PATH;
-  GSpawnChildSetupFunc setup_func = NULL;
-  gpointer     setup_data = NULL;
-
-  GPid        *ret_pid = NULL;
-  int         *ret_stdin = NULL, *ret_stdout = NULL, *ret_stderr = NULL;
-  char       **ret_startup_id = NULL;
-
-  if (documents && desktop_file->document_code == 0)
-    {
-      g_set_error (error, EGG_DESKTOP_FILE_ERROR,
-		   EGG_DESKTOP_FILE_ERROR_NOT_LAUNCHABLE,
-		   _("Application does not accept documents on command line"));
-      return FALSE;
-    }
-
-  /* Read the options: technically it's incorrect for the caller to
-   * NULL-terminate the list of options (rather than 0-terminating
-   * it), but NULL-terminating lets us use G_GNUC_NULL_TERMINATED,
-   * it's more consistent with other glib/gtk methods, and it will
-   * work as long as sizeof (int) <= sizeof (NULL), and NULL is
-   * represented as 0. (Which is true everywhere we care about.)
-   */
-  while ((option = va_arg (args, EggDesktopFileLaunchOption)))
-    {
-      switch (option)
-	{
-	case EGG_DESKTOP_FILE_LAUNCH_CLEARENV:
-	  if (env)
-	    g_ptr_array_free (env, TRUE);
-	  env = g_ptr_array_new ();
-	  break;
-	case EGG_DESKTOP_FILE_LAUNCH_PUTENV:
-	  variables = va_arg (args, char **);
-	  for (i = 0; variables[i]; i++)
-	    env = array_putenv (env, variables[i]);
-	  break;
-
-	case EGG_DESKTOP_FILE_LAUNCH_SCREEN:
-	  screen = va_arg (args, GdkScreen *);
-	  break;
-	case EGG_DESKTOP_FILE_LAUNCH_WORKSPACE:
-	  workspace = va_arg (args, int);
-	  break;
-
-	case EGG_DESKTOP_FILE_LAUNCH_DIRECTORY:
-	  directory = va_arg (args, const char *);
-	  break;
-	case EGG_DESKTOP_FILE_LAUNCH_TIME:
-	  launch_time = va_arg (args, guint32);
-	  break;
-	case EGG_DESKTOP_FILE_LAUNCH_FLAGS:
-	  flags |= va_arg (args, GSpawnFlags);
-	  /* Make sure they didn't set any flags that don't make sense. */
-	  flags &= ~G_SPAWN_FILE_AND_ARGV_ZERO;
-	  break;
-	case EGG_DESKTOP_FILE_LAUNCH_SETUP_FUNC:
-	  setup_func = va_arg (args, GSpawnChildSetupFunc);
-	  setup_data = va_arg (args, gpointer);
-	  break;
-
-	case EGG_DESKTOP_FILE_LAUNCH_RETURN_PID:
-	  ret_pid = va_arg (args, GPid *);
-	  break;
-	case EGG_DESKTOP_FILE_LAUNCH_RETURN_STDIN_PIPE:
-	  ret_stdin = va_arg (args, int *);
-	  break;
-	case EGG_DESKTOP_FILE_LAUNCH_RETURN_STDOUT_PIPE:
-	  ret_stdout = va_arg (args, int *);
-	  break;
-	case EGG_DESKTOP_FILE_LAUNCH_RETURN_STDERR_PIPE:
-	  ret_stderr = va_arg (args, int *);
-	  break;
-	case EGG_DESKTOP_FILE_LAUNCH_RETURN_STARTUP_ID:
-	  ret_startup_id = va_arg (args, char **);
-	  break;
-
-	default:
-	  g_set_error (error, EGG_DESKTOP_FILE_ERROR,
-		       EGG_DESKTOP_FILE_ERROR_UNRECOGNIZED_OPTION,
-		       _("Unrecognized launch option: %d"),
-		       GPOINTER_TO_INT (option));
-	  success = FALSE;
-	  goto out;
-	}
-    }
-
-  if (screen)
-    {
-      char *display_name = gdk_screen_make_display_name (screen);
-      char *display_env = g_strdup_printf ("DISPLAY=%s", display_name);
-      env = array_putenv (env, display_env);
-      g_free (display_name);
-      g_free (display_env);
-
-      display = gdk_screen_get_display (screen);
-    }
-  else
-    {
-      display = gdk_display_get_default ();
-      screen = gdk_display_get_default_screen (display);
-    }
-  screen_num = gdk_screen_get_number (screen);
-
-  translated_documents = translate_document_list (desktop_file, documents);
-  docs = translated_documents;
-
-  success = FALSE;
-
-  do
-    {
-      command = parse_exec (desktop_file, &docs, error);
-      if (!command)
-	goto out;
-
-      if (!g_shell_parse_argv (command, &argc, &argv, error))
-	{
-	  g_free (command);
-	  goto out;
-	}
-      g_free (command);
-
-#if GTK_CHECK_VERSION (2, 12, 0)
-      startup_id = start_startup_notification (display, desktop_file,
-					       argv[0], screen_num,
-					       workspace, launch_time);
-      if (startup_id)
-	{
-	  char *startup_id_env = g_strdup_printf ("DESKTOP_STARTUP_ID=%s",
-						  startup_id);
-	  env = array_putenv (env, startup_id_env);
-	  g_free (startup_id_env);
-	}
-#else
-      startup_id = NULL;
-#endif /* GTK 2.12 */
-
-      if (env != NULL)
-	g_ptr_array_add (env, NULL);
-
-      current_success =
-	g_spawn_async_with_pipes (directory,
-				  argv,
-				  env ? (char **)(env->pdata) : NULL,
-				  flags,
-				  setup_func, setup_data,
-				  ret_pid,
-				  ret_stdin, ret_stdout, ret_stderr,
-				  error);
-      g_strfreev (argv);
-
-      if (startup_id)
-	{
-#if GTK_CHECK_VERSION (2, 12, 0)
-	  if (current_success)
-	    {
-	      set_startup_notification_timeout (display, startup_id);
-
-	      if (ret_startup_id)
-		*ret_startup_id = startup_id;
-	      else
-		g_free (startup_id);
-	    }
-	  else
-#endif /* GTK 2.12 */
-	    g_free (startup_id);
-	}
-      else if (ret_startup_id)
-	*ret_startup_id = NULL;
-
-      if (current_success)
-	{
-	  /* If we successfully launch any instances of the app, make
-	   * sure we return TRUE and don't set @error.
-	   */
-	  success = TRUE;
-	  error = NULL;
-
-	  /* Also, only set the output params on the first one */
-	  ret_pid = NULL;
-	  ret_stdin = ret_stdout = ret_stderr = NULL;
-	  ret_startup_id = NULL;
-	}
-    }
-  while (docs && current_success);
-
- out:
-  if (env)
-    {
-      g_ptr_array_foreach (env, (GFunc)g_free, NULL);
-      g_ptr_array_free (env, TRUE);
-    }
-  free_document_list (translated_documents);
-
-  return success;
-}
-
-/**
- * egg_desktop_file_launch:
- * @desktop_file: an #EggDesktopFile
- * @documents: a list of URIs or paths to documents to open
- * @error: error pointer
- * @...: additional options
- *
- * Launches @desktop_file with the given arguments. Additional options
- * can be specified as follows:
- *
- *   %EGG_DESKTOP_FILE_LAUNCH_CLEARENV: (no arguments)
- *       clears the environment in the child process
- *   %EGG_DESKTOP_FILE_LAUNCH_PUTENV: (char **variables)
- *       adds the NAME=VALUE strings in the given %NULL-terminated
- *       array to the child process's environment
- *   %EGG_DESKTOP_FILE_LAUNCH_SCREEN: (GdkScreen *screen)
- *       causes the application to be launched on the given screen
- *   %EGG_DESKTOP_FILE_LAUNCH_WORKSPACE: (int workspace)
- *       causes the application to be launched on the given workspace
- *   %EGG_DESKTOP_FILE_LAUNCH_DIRECTORY: (char *dir)
- *       causes the application to be launched in the given directory
- *   %EGG_DESKTOP_FILE_LAUNCH_TIME: (guint32 launch_time)
- *       sets the "launch time" for the application. If the user
- *       interacts with another window after @launch_time but before
- *       the launched application creates its first window, the window
- *       manager may choose to not give focus to the new application.
- *       Passing 0 for @launch_time will explicitly request that the
- *       application not receive focus.
- *   %EGG_DESKTOP_FILE_LAUNCH_FLAGS (GSpawnFlags flags)
- *       Sets additional #GSpawnFlags to use. See g_spawn_async() for
- *       more details.
- *   %EGG_DESKTOP_FILE_LAUNCH_SETUP_FUNC (GSpawnChildSetupFunc, gpointer)
- *       Sets the child setup callback and the data to pass to it.
- *       (See g_spawn_async() for more details.)
- *
- *   %EGG_DESKTOP_FILE_LAUNCH_RETURN_PID (GPid **pid)
- *       On a successful launch, sets *@pid to the PID of the launched
- *       application.
- *   %EGG_DESKTOP_FILE_LAUNCH_RETURN_STARTUP_ID (char **startup_id)
- *       On a successful launch, sets *@startup_id to the Startup
- *       Notification "startup id" of the launched application.
- *   %EGG_DESKTOP_FILE_LAUNCH_RETURN_STDIN_PIPE (int *fd)
- *       On a successful launch, sets *@fd to the file descriptor of
- *       a pipe connected to the application's stdin.
- *   %EGG_DESKTOP_FILE_LAUNCH_RETURN_STDOUT_PIPE (int *fd)
- *       On a successful launch, sets *@fd to the file descriptor of
- *       a pipe connected to the application's stdout.
- *   %EGG_DESKTOP_FILE_LAUNCH_RETURN_STDERR_PIPE (int *fd)
- *       On a successful launch, sets *@fd to the file descriptor of
- *       a pipe connected to the application's stderr.
- *
- * The options should be terminated with a single %NULL.
- *
- * If @documents contains multiple documents, but
- * egg_desktop_file_accepts_multiple() returns %FALSE for
- * @desktop_file, then egg_desktop_file_launch() will actually launch
- * multiple instances of the application. In that case, the return
- * value (as well as any values passed via
- * %EGG_DESKTOP_FILE_LAUNCH_RETURN_PID, etc) will only reflect the
- * first instance of the application that was launched (but the
- * %EGG_DESKTOP_FILE_LAUNCH_SETUP_FUNC will be called for each
- * instance).
- *
- * Return value: %TRUE if the application was successfully launched.
- **/
-gboolean
-egg_desktop_file_launch (EggDesktopFile *desktop_file,
-			 GSList *documents, GError **error,
-			 ...)
-{
-  va_list args;
-  gboolean success;
-  EggDesktopFile *app_desktop_file;
-
-  switch (desktop_file->type)
-    {
-    case EGG_DESKTOP_FILE_TYPE_APPLICATION:
-      va_start (args, error);
-      success = egg_desktop_file_launchv (desktop_file, documents,
-					  args, error);
-      va_end (args);
-      break;
-
-    case EGG_DESKTOP_FILE_TYPE_LINK:
-      if (documents)
-	{
-	  g_set_error (error, EGG_DESKTOP_FILE_ERROR,
-		       EGG_DESKTOP_FILE_ERROR_NOT_LAUNCHABLE,
-		       /* translators: The 'Type=Link' string is found in a
-			* desktop file, and should not be translated. */
-		       _("Can't pass document URIs to a 'Type=Link' desktop entry"));
-	  return FALSE;
-	}	  
-
-      if (!parse_link (desktop_file, &app_desktop_file, &documents, error))
-	return FALSE;
-
-      va_start (args, error);
-      success = egg_desktop_file_launchv (app_desktop_file, documents,
-					  args, error);
-      va_end (args);
-
-      egg_desktop_file_free (app_desktop_file);
-      free_document_list (documents);
-      break;
-
-    case EGG_DESKTOP_FILE_TYPE_UNRECOGNIZED:
-    case EGG_DESKTOP_FILE_TYPE_DIRECTORY:
-    default:
-      g_set_error (error, EGG_DESKTOP_FILE_ERROR,
-		   EGG_DESKTOP_FILE_ERROR_NOT_LAUNCHABLE,
-		   _("Not a launchable item"));
-      success = FALSE;
-      break;
-    }
-
-  return success;
-}
-
-
-GQuark
-egg_desktop_file_error_quark (void)
-{
-  return g_quark_from_static_string ("egg-desktop_file-error-quark");
-}
-
-
-G_LOCK_DEFINE_STATIC (egg_desktop_file);
-static EggDesktopFile *egg_desktop_file;
-
-static void
-egg_set_desktop_file_internal (const char *desktop_file_path,
-                               gboolean set_defaults)
-{
-  GError *error = NULL;
-
-  G_LOCK (egg_desktop_file);
-  if (egg_desktop_file)
-    egg_desktop_file_free (egg_desktop_file);
-
-  egg_desktop_file = egg_desktop_file_new (desktop_file_path, &error);
-  if (error)
-    {
-      g_warning ("Could not load desktop file '%s': %s",
-		 desktop_file_path, error->message);
-      g_error_free (error);
-    }
-
-  if (set_defaults && egg_desktop_file != NULL) {
-    /* Set localized application name and default window icon */
-    if (egg_desktop_file->name)
-      g_set_application_name (egg_desktop_file->name);
-    if (egg_desktop_file->icon)
-      {
-        if (g_path_is_absolute (egg_desktop_file->icon))
-          gtk_window_set_default_icon_from_file (egg_desktop_file->icon, NULL);
-        else
-          gtk_window_set_default_icon_name (egg_desktop_file->icon);
-      }
-  }
-
-  G_UNLOCK (egg_desktop_file);
-}
-
-/**
- * egg_set_desktop_file:
- * @desktop_file_path: path to the application's desktop file
- *
- * Creates an #EggDesktopFile for the application from the data at
- * @desktop_file_path. This will also call g_set_application_name()
- * with the localized application name from the desktop file, and
- * gtk_window_set_default_icon_name() or
- * gtk_window_set_default_icon_from_file() with the application's
- * icon. Other code may use additional information from the desktop
- * file.
- * See egg_set_desktop_file_without_defaults() for a variant of this
- * function that does not set the application name and default window
- * icon.
- *
- * Note that for thread safety reasons, this function can only
- * be called once, and is mutually exclusive with calling
- * egg_set_desktop_file_without_defaults().
- **/
-void
-egg_set_desktop_file (const char *desktop_file_path)
-{
-  egg_set_desktop_file_internal (desktop_file_path, TRUE);
-}
-
-/**
- * egg_set_desktop_file_without_defaults:
- * @desktop_file_path: path to the application's desktop file
- *
- * Creates an #EggDesktopFile for the application from the data at
- * @desktop_file_path.
- * See egg_set_desktop_file() for a variant of this function that
- * sets the application name and default window icon from the information
- * in the desktop file.
- *
- * Note that for thread safety reasons, this function can only
- * be called once, and is mutually exclusive with calling
- * egg_set_desktop_file().
- **/
-void
-egg_set_desktop_file_without_defaults (const char *desktop_file_path)
-{
-  egg_set_desktop_file_internal (desktop_file_path, FALSE);
-}
-
-/**
- * egg_get_desktop_file:
- * 
- * Gets the application's #EggDesktopFile, as set by
- * egg_set_desktop_file().
- * 
- * Return value: the #EggDesktopFile, or %NULL if it hasn't been set.
- **/
-EggDesktopFile *
-egg_get_desktop_file (void)
-{
-  EggDesktopFile *retval;
-
-  G_LOCK (egg_desktop_file);
-  retval = egg_desktop_file;
-  G_UNLOCK (egg_desktop_file);
-
-  return retval;
-}
diff --git a/egg/eggdesktopfile.h b/egg/eggdesktopfile.h
deleted file mode 100644
index 16c5426..0000000
--- a/egg/eggdesktopfile.h
+++ /dev/null
@@ -1,163 +0,0 @@
-/* eggdesktopfile.h - Freedesktop.Org Desktop Files
- * Copyright (C) 2007 Novell, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public License
- * as published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; see the file COPYING.LIB. If not,
- * write to the Free Software Foundation, Inc., 59 Temple Place -
- * Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef __EGG_DESKTOP_FILE_H__
-#define __EGG_DESKTOP_FILE_H__
-
-#include <glib.h>
-
-G_BEGIN_DECLS
-
-typedef struct EggDesktopFile EggDesktopFile;
-
-typedef enum {
-	EGG_DESKTOP_FILE_TYPE_UNRECOGNIZED,
-
-	EGG_DESKTOP_FILE_TYPE_APPLICATION,
-	EGG_DESKTOP_FILE_TYPE_LINK,
-	EGG_DESKTOP_FILE_TYPE_DIRECTORY
-} EggDesktopFileType;
-
-EggDesktopFile     *egg_desktop_file_new                (const char   *desktop_file_path,
-							 GError      **error);
-
-EggDesktopFile     *egg_desktop_file_new_from_data_dirs (const char   *desktop_file_path,
-							 GError      **error);
-EggDesktopFile     *egg_desktop_file_new_from_dirs      (const char   *desktop_file_path,
-							 const char  **search_dirs,
-							 GError      **error);
-EggDesktopFile     *egg_desktop_file_new_from_key_file  (GKeyFile     *key_file,
-							 const char   *source,
-							 GError      **error);
-
-void                egg_desktop_file_free               (EggDesktopFile  *desktop_file);
-
-const char         *egg_desktop_file_get_source         (EggDesktopFile  *desktop_file);
-
-EggDesktopFileType  egg_desktop_file_get_desktop_file_type (EggDesktopFile  *desktop_file);
-
-const char         *egg_desktop_file_get_name           (EggDesktopFile  *desktop_file);
-const char         *egg_desktop_file_get_icon           (EggDesktopFile  *desktop_file);
-
-gboolean            egg_desktop_file_can_launch         (EggDesktopFile  *desktop_file,
-							 const char      *desktop_environment);
-
-gboolean            egg_desktop_file_accepts_documents  (EggDesktopFile  *desktop_file);
-gboolean            egg_desktop_file_accepts_multiple   (EggDesktopFile  *desktop_file);
-gboolean            egg_desktop_file_accepts_uris       (EggDesktopFile  *desktop_file);
-
-char               *egg_desktop_file_parse_exec         (EggDesktopFile  *desktop_file,
-							 GSList          *documents,
-							 GError         **error);
-
-gboolean            egg_desktop_file_launch             (EggDesktopFile  *desktop_file,
-							 GSList          *documents,
-							 GError         **error,
-							 ...) G_GNUC_NULL_TERMINATED;
-
-typedef enum {
-	EGG_DESKTOP_FILE_LAUNCH_CLEARENV = 1,
-	EGG_DESKTOP_FILE_LAUNCH_PUTENV,
-	EGG_DESKTOP_FILE_LAUNCH_SCREEN,
-	EGG_DESKTOP_FILE_LAUNCH_WORKSPACE,
-	EGG_DESKTOP_FILE_LAUNCH_DIRECTORY,
-	EGG_DESKTOP_FILE_LAUNCH_TIME,
-	EGG_DESKTOP_FILE_LAUNCH_FLAGS,
-	EGG_DESKTOP_FILE_LAUNCH_SETUP_FUNC,
-	EGG_DESKTOP_FILE_LAUNCH_RETURN_PID,
-	EGG_DESKTOP_FILE_LAUNCH_RETURN_STDIN_PIPE,
-	EGG_DESKTOP_FILE_LAUNCH_RETURN_STDOUT_PIPE,
-	EGG_DESKTOP_FILE_LAUNCH_RETURN_STDERR_PIPE,
-	EGG_DESKTOP_FILE_LAUNCH_RETURN_STARTUP_ID
-} EggDesktopFileLaunchOption;
-
-/* Standard Keys */
-#define EGG_DESKTOP_FILE_GROUP			"Desktop Entry"
-
-#define EGG_DESKTOP_FILE_KEY_TYPE		"Type"
-#define EGG_DESKTOP_FILE_KEY_VERSION		"Version"
-#define EGG_DESKTOP_FILE_KEY_NAME		"Name"
-#define EGG_DESKTOP_FILE_KEY_GENERIC_NAME	"GenericName"
-#define EGG_DESKTOP_FILE_KEY_NO_DISPLAY		"NoDisplay"
-#define EGG_DESKTOP_FILE_KEY_COMMENT		"Comment"
-#define EGG_DESKTOP_FILE_KEY_ICON		"Icon"
-#define EGG_DESKTOP_FILE_KEY_HIDDEN		"Hidden"
-#define EGG_DESKTOP_FILE_KEY_ONLY_SHOW_IN	"OnlyShowIn"
-#define EGG_DESKTOP_FILE_KEY_NOT_SHOW_IN	"NotShowIn"
-#define EGG_DESKTOP_FILE_KEY_TRY_EXEC		"TryExec"
-#define EGG_DESKTOP_FILE_KEY_EXEC		"Exec"
-#define EGG_DESKTOP_FILE_KEY_PATH		"Path"
-#define EGG_DESKTOP_FILE_KEY_TERMINAL		"Terminal"
-#define EGG_DESKTOP_FILE_KEY_MIME_TYPE		"MimeType"
-#define EGG_DESKTOP_FILE_KEY_CATEGORIES		"Categories"
-#define EGG_DESKTOP_FILE_KEY_STARTUP_NOTIFY	"StartupNotify"
-#define EGG_DESKTOP_FILE_KEY_STARTUP_WM_CLASS	"StartupWMClass"
-#define EGG_DESKTOP_FILE_KEY_URL		"URL"
-
-/* Accessors */
-gboolean  egg_desktop_file_has_key                (EggDesktopFile  *desktop_file,
-						   const char      *key,
-						   GError         **error);
-char     *egg_desktop_file_get_string             (EggDesktopFile  *desktop_file,
-						   const char      *key,
-						   GError         **error) G_GNUC_MALLOC;
-char     *egg_desktop_file_get_locale_string      (EggDesktopFile  *desktop_file,
-						   const char      *key,
-						   const char      *locale,
-						   GError         **error) G_GNUC_MALLOC;
-gboolean  egg_desktop_file_get_boolean            (EggDesktopFile  *desktop_file,
-						   const char      *key,
-						   GError         **error);
-double    egg_desktop_file_get_numeric            (EggDesktopFile  *desktop_file,
-						   const char      *key,
-						   GError         **error);
-int       egg_desktop_file_get_integer            (EggDesktopFile  *desktop_file,
-						   const char      *key,
-						   GError         **error);
-char    **egg_desktop_file_get_string_list        (EggDesktopFile  *desktop_file,
-						   const char      *key,
-						   gsize           *length,
-						   GError         **error) G_GNUC_MALLOC;
-char    **egg_desktop_file_get_locale_string_list (EggDesktopFile  *desktop_file,
-						   const char      *key,
-						   const char      *locale,
-						   gsize           *length,
-						   GError         **error) G_GNUC_MALLOC;
-
-
-/* Errors */
-#define EGG_DESKTOP_FILE_ERROR egg_desktop_file_error_quark()
-
-GQuark egg_desktop_file_error_quark (void);
-
-typedef enum {
-	EGG_DESKTOP_FILE_ERROR_INVALID,
-	EGG_DESKTOP_FILE_ERROR_NOT_LAUNCHABLE,
-	EGG_DESKTOP_FILE_ERROR_UNRECOGNIZED_OPTION
-} EggDesktopFileError;
-
-/* Global application desktop file */
-void            egg_set_desktop_file                  (const char *desktop_file_path);
-void            egg_set_desktop_file_without_defaults (const char *desktop_file_path);
-EggDesktopFile *egg_get_desktop_file                  (void);
-
-
-G_END_DECLS
-
-#endif /* __EGG_DESKTOP_FILE_H__ */
diff --git a/egg/eggsmclient-private.h b/egg/eggsmclient-private.h
deleted file mode 100644
index 0c98eee..0000000
--- a/egg/eggsmclient-private.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/* eggsmclient-private.h
- * Copyright (C) 2007 Novell, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef __EGG_SM_CLIENT_PRIVATE_H__
-#define __EGG_SM_CLIENT_PRIVATE_H__
-
-#include <gtk/gtk.h>
-
-#if !GTK_CHECK_VERSION(2,91,7) && !GTK_CHECK_VERSION(3,0,0)
-/* GTK+ 3 includes this automatically */
-#include <gdkconfig.h>
-#endif
-
-#include "eggsmclient.h"
-
-G_BEGIN_DECLS
-
-GKeyFile *egg_sm_client_save_state     (EggSMClient *client);
-void      egg_sm_client_quit_requested (EggSMClient *client);
-void      egg_sm_client_quit_cancelled (EggSMClient *client);
-void      egg_sm_client_quit           (EggSMClient *client);
-
-#if defined (GDK_WINDOWING_X11)
-# ifdef EGG_SM_CLIENT_BACKEND_XSMP
-GType        egg_sm_client_xsmp_get_type (void);
-EggSMClient *egg_sm_client_xsmp_new      (void);
-# endif
-# ifdef EGG_SM_CLIENT_BACKEND_DBUS
-GType        egg_sm_client_dbus_get_type (void);
-EggSMClient *egg_sm_client_dbus_new      (void);
-# endif
-#elif defined (GDK_WINDOWING_WIN32)
-GType        egg_sm_client_win32_get_type (void);
-EggSMClient *egg_sm_client_win32_new      (void);
-#elif defined (GDK_WINDOWING_QUARTZ)
-GType        egg_sm_client_osx_get_type (void);
-EggSMClient *egg_sm_client_osx_new      (void);
-#endif
-
-G_END_DECLS
-
-
-#endif /* __EGG_SM_CLIENT_PRIVATE_H__ */
diff --git a/egg/eggsmclient-xsmp.c b/egg/eggsmclient-xsmp.c
deleted file mode 100644
index 9fd1e5d..0000000
--- a/egg/eggsmclient-xsmp.c
+++ /dev/null
@@ -1,1375 +0,0 @@
-/*
- * Copyright (C) 2007 Novell, Inc.
- *
- * Inspired by various other pieces of code including GsmClient (C)
- * 2001 Havoc Pennington, GnomeClient (C) 1998 Carsten Schaar, and twm
- * session code (C) 1998 The Open Group.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-
-#include "eggsmclient.h"
-#include "eggsmclient-private.h"
-
-#include "eggdesktopfile.h"
-
-#include <errno.h>
-#include <fcntl.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <X11/SM/SMlib.h>
-
-#include <gdk/gdk.h>
-#include <gdk/gdkx.h>
-
-#define EGG_TYPE_SM_CLIENT_XSMP            (egg_sm_client_xsmp_get_type ())
-#define EGG_SM_CLIENT_XSMP(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), EGG_TYPE_SM_CLIENT_XSMP, EggSMClientXSMP))
-#define EGG_SM_CLIENT_XSMP_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), EGG_TYPE_SM_CLIENT_XSMP, EggSMClientXSMPClass))
-#define EGG_IS_SM_CLIENT_XSMP(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EGG_TYPE_SM_CLIENT_XSMP))
-#define EGG_IS_SM_CLIENT_XSMP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EGG_TYPE_SM_CLIENT_XSMP))
-#define EGG_SM_CLIENT_XSMP_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), EGG_TYPE_SM_CLIENT_XSMP, EggSMClientXSMPClass))
-
-typedef struct _EggSMClientXSMP        EggSMClientXSMP;
-typedef struct _EggSMClientXSMPClass   EggSMClientXSMPClass;
-
-/* These mostly correspond to the similarly-named states in section
- * 9.1 of the XSMP spec. Some of the states there aren't represented
- * here, because we don't need them. SHUTDOWN_CANCELLED is slightly
- * different from the spec; we use it when the client is IDLE after a
- * ShutdownCancelled message, but the application is still interacting
- * and doesn't know the shutdown has been cancelled yet.
- */
-typedef enum
-{
-  XSMP_STATE_IDLE,
-  XSMP_STATE_SAVE_YOURSELF,
-  XSMP_STATE_INTERACT_REQUEST,
-  XSMP_STATE_INTERACT,
-  XSMP_STATE_SAVE_YOURSELF_DONE,
-  XSMP_STATE_SHUTDOWN_CANCELLED,
-  XSMP_STATE_CONNECTION_CLOSED
-} EggSMClientXSMPState;
-
-static const char *state_names[] = {
-  "idle",
-  "save-yourself",
-  "interact-request",
-  "interact",
-  "save-yourself-done",
-  "shutdown-cancelled",
-  "connection-closed"
-};
-
-#define EGG_SM_CLIENT_XSMP_STATE(xsmp) (state_names[(xsmp)->state])
-
-struct _EggSMClientXSMP
-{
-  EggSMClient parent;
-
-  SmcConn connection;
-  char *client_id;
-
-  EggSMClientXSMPState state;
-  char **restart_command;
-  gboolean set_restart_command;
-  int restart_style;
-
-  guint idle;
-
-  /* Current SaveYourself state */
-  guint expecting_initial_save_yourself : 1;
-  guint need_save_state : 1;
-  guint need_quit_requested : 1;
-  guint interact_errors : 1;
-  guint shutting_down : 1;
-
-  /* Todo list */
-  guint waiting_to_set_initial_properties : 1;
-  guint waiting_to_emit_quit : 1;
-  guint waiting_to_emit_quit_cancelled : 1;
-  guint waiting_to_save_myself : 1;
-
-};
-
-struct _EggSMClientXSMPClass
-{
-  EggSMClientClass parent_class;
-
-};
-
-static void     sm_client_xsmp_startup (EggSMClient *client,
-					const char  *client_id);
-static void     sm_client_xsmp_set_restart_command (EggSMClient  *client,
-						    int           argc,
-						    const char  **argv);
-static void     sm_client_xsmp_will_quit (EggSMClient *client,
-					  gboolean     will_quit);
-static gboolean sm_client_xsmp_end_session (EggSMClient         *client,
-					    EggSMClientEndStyle  style,
-					    gboolean  request_confirmation);
-
-static void xsmp_save_yourself      (SmcConn   smc_conn,
-				     SmPointer client_data,
-				     int       save_style,
-				     Bool      shutdown,
-				     int       interact_style,
-				     Bool      fast);
-static void xsmp_die                (SmcConn   smc_conn,
-				     SmPointer client_data);
-static void xsmp_save_complete      (SmcConn   smc_conn,
-				     SmPointer client_data);
-static void xsmp_shutdown_cancelled (SmcConn   smc_conn,
-				     SmPointer client_data);
-static void xsmp_interact           (SmcConn   smc_conn,
-				     SmPointer client_data);
-
-static SmProp *array_prop        (const char    *name,
-				  ...);
-static SmProp *ptrarray_prop     (const char    *name,
-				  GPtrArray     *values);
-static SmProp *string_prop       (const char    *name,
-				  const char    *value);
-static SmProp *card8_prop        (const char    *name,
-				  unsigned char  value);
-
-static void set_properties         (EggSMClientXSMP *xsmp, ...);
-static void delete_properties      (EggSMClientXSMP *xsmp, ...);
-
-static GPtrArray *generate_command (char       **restart_command,
-				    const char  *client_id,
-				    const char  *state_file);
-
-static void save_state            (EggSMClientXSMP *xsmp);
-static void do_save_yourself      (EggSMClientXSMP *xsmp);
-static void update_pending_events (EggSMClientXSMP *xsmp);
-
-static void     ice_init             (void);
-static gboolean process_ice_messages (IceConn       ice_conn);
-static void     smc_error_handler    (SmcConn       smc_conn,
-				      Bool          swap,
-				      int           offending_minor_opcode,
-				      unsigned long offending_sequence,
-				      int           error_class,
-				      int           severity,
-				      SmPointer     values);
-
-G_DEFINE_TYPE (EggSMClientXSMP, egg_sm_client_xsmp, EGG_TYPE_SM_CLIENT)
-
-static void
-egg_sm_client_xsmp_init (EggSMClientXSMP *xsmp)
-{
-  xsmp->state = XSMP_STATE_CONNECTION_CLOSED;
-  xsmp->connection = NULL;
-  xsmp->restart_style = SmRestartIfRunning;
-}
-
-static void
-egg_sm_client_xsmp_class_init (EggSMClientXSMPClass *klass)
-{
-  EggSMClientClass *sm_client_class = EGG_SM_CLIENT_CLASS (klass);
-
-  sm_client_class->startup             = sm_client_xsmp_startup;
-  sm_client_class->set_restart_command = sm_client_xsmp_set_restart_command;
-  sm_client_class->will_quit           = sm_client_xsmp_will_quit;
-  sm_client_class->end_session         = sm_client_xsmp_end_session;
-}
-
-EggSMClient *
-egg_sm_client_xsmp_new (void)
-{
-  if (!g_getenv ("SESSION_MANAGER"))
-    return NULL;
-
-  return g_object_new (EGG_TYPE_SM_CLIENT_XSMP, NULL);
-}
-
-static gboolean
-sm_client_xsmp_set_initial_properties (gpointer user_data)
-{
-  EggSMClientXSMP *xsmp = user_data;
-  EggDesktopFile *desktop_file;
-  GPtrArray *clone, *restart;
-  char pid_str[64];
-
-  if (xsmp->idle)
-    {
-      g_source_remove (xsmp->idle);
-      xsmp->idle = 0;
-    }
-  xsmp->waiting_to_set_initial_properties = FALSE;
-
-  if (egg_sm_client_get_mode () == EGG_SM_CLIENT_MODE_NO_RESTART)
-    xsmp->restart_style = SmRestartNever;
-
-  /* Parse info out of desktop file */
-  desktop_file = egg_get_desktop_file ();
-  if (desktop_file)
-    {
-      GError *err = NULL;
-      char *cmdline, **argv;
-      int argc;
-
-      if (xsmp->restart_style == SmRestartIfRunning)
-	{
-	  if (egg_desktop_file_get_boolean (desktop_file, 
-					    "X-GNOME-AutoRestart", NULL))
-	    xsmp->restart_style = SmRestartImmediately;
-	}
-
-      if (!xsmp->set_restart_command)
-	{
-	  cmdline = egg_desktop_file_parse_exec (desktop_file, NULL, &err);
-	  if (cmdline && g_shell_parse_argv (cmdline, &argc, &argv, &err))
-	    {
-	      egg_sm_client_set_restart_command (EGG_SM_CLIENT (xsmp),
-						 argc, (const char **)argv);
-	      g_strfreev (argv);
-	    }
-	  else
-	    {
-	      g_warning ("Could not parse Exec line in desktop file: %s",
-			 err->message);
-	      g_error_free (err);
-	    }
-	  g_free (cmdline);
-	}
-    }
-
-  if (!xsmp->set_restart_command)
-    xsmp->restart_command = g_strsplit (g_get_prgname (), " ", -1);
-
-  clone = generate_command (xsmp->restart_command, NULL, NULL);
-  restart = generate_command (xsmp->restart_command, xsmp->client_id, NULL);
-
-  g_debug ("Setting initial properties");
-
-  /* Program, CloneCommand, RestartCommand, and UserID are required.
-   * ProcessID isn't required, but the SM may be able to do something
-   * useful with it.
-   */
-  g_snprintf (pid_str, sizeof (pid_str), "%lu", (gulong) getpid ());
-  set_properties (xsmp,
-		  string_prop   (SmProgram, g_get_prgname ()),
-		  ptrarray_prop (SmCloneCommand, clone),
-		  ptrarray_prop (SmRestartCommand, restart),
-		  string_prop   (SmUserID, g_get_user_name ()),
-		  string_prop   (SmProcessID, pid_str),
-		  card8_prop    (SmRestartStyleHint, xsmp->restart_style),
-		  NULL);
-  g_ptr_array_free (clone, TRUE);
-  g_ptr_array_free (restart, TRUE);
-
-  if (desktop_file)
-    {
-      set_properties (xsmp,
-		      string_prop ("_GSM_DesktopFile", egg_desktop_file_get_source (desktop_file)),
-		      NULL);
-    }
-
-  update_pending_events (xsmp);
-  return FALSE;
-}
-
-/* This gets called from two different places: xsmp_die() (when the
- * server asks us to disconnect) and process_ice_messages() (when the
- * server disconnects unexpectedly).
- */
-static void
-sm_client_xsmp_disconnect (EggSMClientXSMP *xsmp)
-{
-  SmcConn connection;
-
-  if (!xsmp->connection)
-    return;
-
-  g_debug ("Disconnecting");
-
-  connection = xsmp->connection;
-  xsmp->connection = NULL;
-  SmcCloseConnection (connection, 0, NULL);
-  xsmp->state = XSMP_STATE_CONNECTION_CLOSED;
-
-  xsmp->waiting_to_save_myself = FALSE;
-  update_pending_events (xsmp);
-}
-
-static void
-sm_client_xsmp_startup (EggSMClient *client,
-			const char  *client_id)
-{
-  EggSMClientXSMP *xsmp = (EggSMClientXSMP *)client;
-  SmcCallbacks callbacks;
-  char *ret_client_id;
-  char error_string_ret[256];
-
-  xsmp->client_id = g_strdup (client_id);
-
-  ice_init ();
-  SmcSetErrorHandler (smc_error_handler);
-
-  callbacks.save_yourself.callback      = xsmp_save_yourself;
-  callbacks.die.callback                = xsmp_die;
-  callbacks.save_complete.callback      = xsmp_save_complete;
-  callbacks.shutdown_cancelled.callback = xsmp_shutdown_cancelled;
-
-  callbacks.save_yourself.client_data      = xsmp;
-  callbacks.die.client_data                = xsmp;
-  callbacks.save_complete.client_data      = xsmp;
-  callbacks.shutdown_cancelled.client_data = xsmp;
-
-  client_id = NULL;
-  error_string_ret[0] = '\0';
-  xsmp->connection =
-    SmcOpenConnection (NULL, xsmp, SmProtoMajor, SmProtoMinor,
-		       SmcSaveYourselfProcMask | SmcDieProcMask |
-		       SmcSaveCompleteProcMask |
-		       SmcShutdownCancelledProcMask,
-		       &callbacks,
-		       xsmp->client_id, &ret_client_id,
-		       sizeof (error_string_ret), error_string_ret);
-
-  if (!xsmp->connection)
-    {
-      g_warning ("Failed to connect to the session manager: %s\n",
-		 error_string_ret[0] ?
-		 error_string_ret : "no error message given");
-      xsmp->state = XSMP_STATE_CONNECTION_CLOSED;
-      return;
-    }
-
-  /* We expect a pointless initial SaveYourself if either (a) we
-   * didn't have an initial client ID, or (b) we DID have an initial
-   * client ID, but the server rejected it and gave us a new one.
-   */
-  if (!xsmp->client_id ||
-      (ret_client_id && strcmp (xsmp->client_id, ret_client_id) != 0))
-    xsmp->expecting_initial_save_yourself = TRUE;
-
-  if (ret_client_id)
-    {
-      g_free (xsmp->client_id);
-      xsmp->client_id = g_strdup (ret_client_id);
-      free (ret_client_id);
-
-      gdk_threads_enter ();
-#if !GTK_CHECK_VERSION(2,23,3) && !GTK_CHECK_VERSION(3,0,0)
-      gdk_set_sm_client_id (xsmp->client_id);
-#else
-      gdk_x11_set_sm_client_id (xsmp->client_id);
-#endif
-      gdk_threads_leave ();
-
-      g_debug ("Got client ID \"%s\"", xsmp->client_id);
-    }
-
-  xsmp->state = XSMP_STATE_IDLE;
-
-  /* Do not set the initial properties until we reach the main loop,
-   * so that the application has a chance to call
-   * egg_set_desktop_file(). (This may also help the session manager
-   * have a better idea of when the application is fully up and
-   * running.)
-   */
-  xsmp->waiting_to_set_initial_properties = TRUE;
-  xsmp->idle = g_idle_add (sm_client_xsmp_set_initial_properties, client);
-}
-
-static void
-sm_client_xsmp_set_restart_command (EggSMClient  *client,
-				    int           argc,
-				    const char  **argv)
-{
-  EggSMClientXSMP *xsmp = (EggSMClientXSMP *)client;
-  int i;
-
-  g_strfreev (xsmp->restart_command);
-
-  xsmp->restart_command = g_new (char *, argc + 1);
-  for (i = 0; i < argc; i++)
-    xsmp->restart_command[i] = g_strdup (argv[i]);
-  xsmp->restart_command[i] = NULL;
-
-  xsmp->set_restart_command = TRUE;
-}
-
-static void
-sm_client_xsmp_will_quit (EggSMClient *client,
-			  gboolean     will_quit)
-{
-  EggSMClientXSMP *xsmp = (EggSMClientXSMP *)client;
-
-  if (xsmp->state == XSMP_STATE_CONNECTION_CLOSED)
-    {
-      /* The session manager has already exited! Schedule a quit
-       * signal.
-       */
-      xsmp->waiting_to_emit_quit = TRUE;
-      update_pending_events (xsmp);
-      return;
-    }
-  else if (xsmp->state == XSMP_STATE_SHUTDOWN_CANCELLED)
-    {
-      /* We received a ShutdownCancelled message while the application
-       * was interacting; Schedule a quit_cancelled signal.
-       */
-      xsmp->waiting_to_emit_quit_cancelled = TRUE;
-      update_pending_events (xsmp);
-      return;
-    }
-
-  g_return_if_fail (xsmp->state == XSMP_STATE_INTERACT);
-
-  g_debug ("Sending InteractDone(%s)", will_quit ? "False" : "True");
-  SmcInteractDone (xsmp->connection, !will_quit);
-
-  if (will_quit && xsmp->need_save_state)
-    save_state (xsmp);
-
-  g_debug ("Sending SaveYourselfDone(%s)", will_quit ? "True" : "False");
-  SmcSaveYourselfDone (xsmp->connection, will_quit);
-  xsmp->state = XSMP_STATE_SAVE_YOURSELF_DONE;
-}
-
-static gboolean
-sm_client_xsmp_end_session (EggSMClient         *client,
-			    EggSMClientEndStyle  style,
-			    gboolean             request_confirmation)
-{
-  EggSMClientXSMP *xsmp = (EggSMClientXSMP *)client;
-  int save_type;
-
-  /* To end the session via XSMP, we have to send a
-   * SaveYourselfRequest. We aren't allowed to do that if anything
-   * else is going on, but we don't want to expose this fact to the
-   * application. So we do our best to patch things up here...
-   *
-   * In the worst case, this method might block for some length of
-   * time in process_ice_messages, but the only time that code path is
-   * honestly likely to get hit is if the application tries to end the
-   * session as the very first thing it does, in which case it
-   * probably won't actually block anyway. It's not worth gunking up
-   * the API to try to deal nicely with the other 0.01% of cases where
-   * this happens.
-   */
-
-  while (xsmp->state != XSMP_STATE_IDLE ||
-	 xsmp->expecting_initial_save_yourself)
-    {
-      /* If we're already shutting down, we don't need to do anything. */
-      if (xsmp->shutting_down)
-	return TRUE;
-
-      switch (xsmp->state)
-	{
-	case XSMP_STATE_CONNECTION_CLOSED:
-	  return FALSE;
-
-	case XSMP_STATE_SAVE_YOURSELF:
-	  /* Trying to log out from the save_state callback? Whatever.
-	   * Abort the save_state.
-	   */
-	  SmcSaveYourselfDone (xsmp->connection, FALSE);
-	  xsmp->state = XSMP_STATE_SAVE_YOURSELF_DONE;
-	  break;
-
-	case XSMP_STATE_INTERACT_REQUEST:
-	case XSMP_STATE_INTERACT:
-	case XSMP_STATE_SHUTDOWN_CANCELLED:
-	  /* Already in a shutdown-related state, just ignore
-	   * the new shutdown request...
-	   */
-	  return TRUE;
-
-	case XSMP_STATE_IDLE:
-	  if (xsmp->waiting_to_set_initial_properties)
-	    sm_client_xsmp_set_initial_properties (xsmp);
-
-	  if (!xsmp->expecting_initial_save_yourself)
-	    break;
-	  /* else fall through */
-
-	case XSMP_STATE_SAVE_YOURSELF_DONE:
-	  /* We need to wait for some response from the server.*/
-	  process_ice_messages (SmcGetIceConnection (xsmp->connection));
-	  break;
-
-	default:
-	  /* Hm... shouldn't happen */
-	  return FALSE;
-	}
-    }
-
-  /* xfce4-session will do the wrong thing if we pass SmSaveGlobal and
-   * the user chooses to save the session. But gnome-session will do
-   * the wrong thing if we pass SmSaveBoth and the user chooses NOT to
-   * save the session... Sigh.
-   */
-  if (!strcmp (SmcVendor (xsmp->connection), "xfce4-session"))
-    save_type = SmSaveBoth;
-  else
-    save_type = SmSaveGlobal;
-
-  g_debug ("Sending SaveYourselfRequest(SmSaveGlobal, Shutdown, SmInteractStyleAny, %sFast)", request_confirmation ? "!" : "");
-  SmcRequestSaveYourself (xsmp->connection,
-			  save_type,
-			  True, /* shutdown */
-			  SmInteractStyleAny,
-			  !request_confirmation, /* fast */
-			  True /* global */);
-  return TRUE;
-}
-
-static gboolean
-idle_do_pending_events (gpointer data)
-{
-  EggSMClientXSMP *xsmp = data;
-  EggSMClient *client = data;
-
-  gdk_threads_enter ();
-
-  xsmp->idle = 0;
-
-  if (xsmp->waiting_to_emit_quit)
-    {
-      xsmp->waiting_to_emit_quit = FALSE;
-      egg_sm_client_quit (client);
-      goto out;
-    }
-
-  if (xsmp->waiting_to_emit_quit_cancelled)
-    {
-      xsmp->waiting_to_emit_quit_cancelled = FALSE;
-      egg_sm_client_quit_cancelled (client);
-      xsmp->state = XSMP_STATE_IDLE;
-    }
-
-  if (xsmp->waiting_to_save_myself)
-    {
-      xsmp->waiting_to_save_myself = FALSE;
-      do_save_yourself (xsmp);
-    }
-
- out:
-  gdk_threads_leave ();
-  return FALSE;
-}
-
-static void
-update_pending_events (EggSMClientXSMP *xsmp)
-{
-  gboolean want_idle =
-    xsmp->waiting_to_emit_quit ||
-    xsmp->waiting_to_emit_quit_cancelled ||
-    xsmp->waiting_to_save_myself;
-
-  if (want_idle)
-    {
-      if (xsmp->idle == 0)
-	xsmp->idle = g_idle_add (idle_do_pending_events, xsmp);
-    }
-  else
-    {
-      if (xsmp->idle != 0)
-	g_source_remove (xsmp->idle);
-      xsmp->idle = 0;
-    }
-}
-
-static void
-fix_broken_state (EggSMClientXSMP *xsmp, const char *message,
-		  gboolean send_interact_done,
-		  gboolean send_save_yourself_done)
-{
-  g_warning ("Received XSMP %s message in state %s: client or server error",
-	     message, EGG_SM_CLIENT_XSMP_STATE (xsmp));
-
-  /* Forget any pending SaveYourself plans we had */
-  xsmp->waiting_to_save_myself = FALSE;
-  update_pending_events (xsmp);
-
-  if (send_interact_done)
-    SmcInteractDone (xsmp->connection, False);
-  if (send_save_yourself_done)
-    SmcSaveYourselfDone (xsmp->connection, True);
-
-  xsmp->state = send_save_yourself_done ? XSMP_STATE_SAVE_YOURSELF_DONE : XSMP_STATE_IDLE;
-}
-
-/* SM callbacks */
-
-static void
-xsmp_save_yourself (SmcConn   smc_conn,
-		    SmPointer client_data,
-		    int       save_type,
-		    Bool      shutdown,
-		    int       interact_style,
-		    Bool      fast)
-{
-  EggSMClientXSMP *xsmp = client_data;
-  gboolean wants_quit_requested;
-
-  g_debug ("Received SaveYourself(%s, %s, %s, %s) in state %s",
-	   save_type == SmSaveLocal ? "SmSaveLocal" :
-	   save_type == SmSaveGlobal ? "SmSaveGlobal" : "SmSaveBoth",
-	   shutdown ? "Shutdown" : "!Shutdown",
-	   interact_style == SmInteractStyleAny ? "SmInteractStyleAny" :
-	   interact_style == SmInteractStyleErrors ? "SmInteractStyleErrors" :
-	   "SmInteractStyleNone", fast ? "Fast" : "!Fast",
-	   EGG_SM_CLIENT_XSMP_STATE (xsmp));
-
-  if (xsmp->state != XSMP_STATE_IDLE &&
-      xsmp->state != XSMP_STATE_SHUTDOWN_CANCELLED)
-    {
-      fix_broken_state (xsmp, "SaveYourself", FALSE, TRUE);
-      return;
-    }
-
-  if (xsmp->waiting_to_set_initial_properties)
-    sm_client_xsmp_set_initial_properties (xsmp);
-
-  /* If this is the initial SaveYourself, ignore it; we've already set
-   * properties and there's no reason to actually save state too.
-   */
-  if (xsmp->expecting_initial_save_yourself)
-    {
-      xsmp->expecting_initial_save_yourself = FALSE;
-
-      if (save_type == SmSaveLocal &&
-	  interact_style == SmInteractStyleNone &&
-	  !shutdown && !fast)
-	{
-	  g_debug ("Sending SaveYourselfDone(True) for initial SaveYourself");
-	  SmcSaveYourselfDone (xsmp->connection, True);
-	  /* As explained in the comment at the end of
-	   * do_save_yourself(), SAVE_YOURSELF_DONE is the correct
-	   * state here, not IDLE.
-	   */
-	  xsmp->state = XSMP_STATE_SAVE_YOURSELF_DONE;
-	  return;
-	}
-      else
-	g_warning ("First SaveYourself was not the expected one!");
-    }
-
-  /* Even ignoring the "fast" flag completely, there are still 18
-   * different combinations of save_type, shutdown and interact_style.
-   * We interpret them as follows:
-   *
-   *   Type  Shutdown  Interact	 Interpretation
-   *     G      F       A/E/N  	 do nothing (1)
-   *     G      T         N    	 do nothing (1)*
-   *     G      T        A/E   	 quit_requested (2)
-   *    L/B     F       A/E/N  	 save_state (3)
-   *    L/B     T         N    	 save_state (3)*
-   *    L/B     T        A/E   	 quit_requested, then save_state (4)
-   *
-   *   1. Do nothing, because the SM asked us to do something
-   *      uninteresting (save open files, but then don't quit
-   *      afterward) or rude (save open files without asking the user
-   *      for confirmation).
-   *
-   *   2. Request interaction and then emit ::quit_requested. This
-   *      perhaps isn't quite correct for the SmInteractStyleErrors
-   *      case, but we don't care.
-   *
-   *   3. Emit ::save_state. The SmSaveBoth SaveYourselfs in these
-   *      rows essentially get demoted to SmSaveLocal, because their
-   *      Global halves correspond to "do nothing".
-   *
-   *   4. Request interaction, emit ::quit_requested, and then emit
-   *      ::save_state after interacting. This is the SmSaveBoth
-   *      equivalent of #2, but we also promote SmSaveLocal shutdown
-   *      SaveYourselfs to SmSaveBoth here, because we want to give
-   *      the user a chance to save open files before quitting.
-   *
-   * (* It would be nice if we could do something useful when the
-   * session manager sends a SaveYourself with shutdown True and
-   * SmInteractStyleNone. But we can't, so we just pretend it didn't
-   * even tell us it was shutting down. The docs for ::quit mention
-   * that it might not always be preceded by ::quit_requested.)
-   */
-
-  /* As an optimization, we don't actually request interaction and
-   * emit ::quit_requested if the application isn't listening to the
-   * signal.
-   */
-  wants_quit_requested = g_signal_has_handler_pending (xsmp, g_signal_lookup ("quit_requested", EGG_TYPE_SM_CLIENT), 0, FALSE);
-
-  xsmp->need_save_state     = (save_type != SmSaveGlobal);
-  xsmp->need_quit_requested = (shutdown && wants_quit_requested &&
-			       interact_style != SmInteractStyleNone);
-  xsmp->interact_errors     = (interact_style == SmInteractStyleErrors);
-
-  xsmp->shutting_down       = shutdown;
-
-  do_save_yourself (xsmp);
-}
-
-static void
-do_save_yourself (EggSMClientXSMP *xsmp)
-{
-  if (xsmp->state == XSMP_STATE_SHUTDOWN_CANCELLED)
-    {
-      /* The SM cancelled a previous SaveYourself, but we haven't yet
-       * had a chance to tell the application, so we can't start
-       * processing this SaveYourself yet.
-       */
-      xsmp->waiting_to_save_myself = TRUE;
-      update_pending_events (xsmp);
-      return;
-    }
-
-  if (xsmp->need_quit_requested)
-    {
-      xsmp->state = XSMP_STATE_INTERACT_REQUEST;
-
-      g_debug ("Sending InteractRequest(%s)",
-	       xsmp->interact_errors ? "Error" : "Normal");
-      SmcInteractRequest (xsmp->connection,
-			  xsmp->interact_errors ? SmDialogError : SmDialogNormal,
-			  xsmp_interact,
-			  xsmp);
-      return;
-    }
-
-  if (xsmp->need_save_state)
-    {
-      save_state (xsmp);
-
-      /* Though unlikely, the client could have been disconnected
-       * while the application was saving its state.
-       */
-      if (!xsmp->connection)
-	 return;
-    }
-
-  g_debug ("Sending SaveYourselfDone(True)");
-  SmcSaveYourselfDone (xsmp->connection, True);
-
-  /* The client state diagram in the XSMP spec says that after a
-   * non-shutdown SaveYourself, we go directly back to "idle". But
-   * everything else in both the XSMP spec and the libSM docs
-   * disagrees.
-   */
-  xsmp->state = XSMP_STATE_SAVE_YOURSELF_DONE;
-}
-
-static void
-save_state (EggSMClientXSMP *xsmp)
-{
-  GKeyFile *state_file;
-  char *state_file_path, *data;
-  EggDesktopFile *desktop_file;
-  GPtrArray *restart;
-  int offset, fd;
-
-  /* We set xsmp->state before emitting save_state, but our caller is
-   * responsible for setting it back afterward.
-   */
-  xsmp->state = XSMP_STATE_SAVE_YOURSELF;
-
-  state_file = egg_sm_client_save_state ((EggSMClient *)xsmp);
-  if (!state_file)
-    {
-      restart = generate_command (xsmp->restart_command, xsmp->client_id, NULL);
-      set_properties (xsmp,
-		      ptrarray_prop (SmRestartCommand, restart),
-		      NULL);
-      g_ptr_array_free (restart, TRUE);
-      delete_properties (xsmp, SmDiscardCommand, NULL);
-      return;
-    }
-
-  desktop_file = egg_get_desktop_file ();
-  if (desktop_file)
-    {
-      GKeyFile *merged_file;
-      char *desktop_file_path;
-
-      merged_file = g_key_file_new ();
-      desktop_file_path =
-	g_filename_from_uri (egg_desktop_file_get_source (desktop_file),
-			     NULL, NULL);
-      if (desktop_file_path &&
-	  g_key_file_load_from_file (merged_file, desktop_file_path,
-				     G_KEY_FILE_KEEP_COMMENTS |
-				     G_KEY_FILE_KEEP_TRANSLATIONS, NULL))
-	{
-	  guint g, k, i;
-	  char **groups, **keys, *value, *exec;
-
-	  groups = g_key_file_get_groups (state_file, NULL);
-	  for (g = 0; groups[g]; g++)
-	    {
-	      keys = g_key_file_get_keys (state_file, groups[g], NULL, NULL);
-	      for (k = 0; keys[k]; k++)
-		{
-		  value = g_key_file_get_value (state_file, groups[g],
-						keys[k], NULL);
-		  if (value)
-		    {
-		      g_key_file_set_value (merged_file, groups[g],
-					    keys[k], value);
-		      g_free (value);
-		    }
-		}
-	      g_strfreev (keys);
-	    }
-	  g_strfreev (groups);
-
-	  g_key_file_free (state_file);
-	  state_file = merged_file;
-
-	  /* Update Exec key using "--sm-client-state-file %k" */
-	  restart = generate_command (xsmp->restart_command,
-				      NULL, "%k");
-	  for (i = 0; i < restart->len; i++)
-	    restart->pdata[i] = g_shell_quote (restart->pdata[i]);
-	  g_ptr_array_add (restart, NULL);
-	  exec = g_strjoinv (" ", (char **)restart->pdata);
-	  g_strfreev ((char **)restart->pdata);
-	  g_ptr_array_free (restart, FALSE);
-
-	  g_key_file_set_string (state_file, EGG_DESKTOP_FILE_GROUP,
-				 EGG_DESKTOP_FILE_KEY_EXEC,
-				 exec);
-	  g_free (exec);
-	}
-      else
-	desktop_file = NULL;
-
-      g_free (desktop_file_path);
-    }
-
-  /* Now write state_file to disk. (We can't use mktemp(), because
-   * that requires the filename to end with "XXXXXX", and we want
-   * it to end with ".desktop".)
-   */
-
-  data = g_key_file_to_data (state_file, NULL, NULL);
-  g_key_file_free (state_file);
-
-  offset = 0;
-  while (1)
-    {
-      state_file_path = g_strdup_printf ("%s%csession-state%c%s-%ld.%s",
-					 g_get_user_config_dir (),
-					 G_DIR_SEPARATOR, G_DIR_SEPARATOR,
-					 g_get_prgname (),
-					 (long)time (NULL) + offset,
-					 desktop_file ? "desktop" : "state");
-
-      fd = open (state_file_path, O_WRONLY | O_CREAT | O_EXCL, 0644);
-      if (fd == -1)
-	{
-	  if (errno == EEXIST)
-	    {
-	      offset++;
-	      g_free (state_file_path);
-	      continue;
-	    }
-	  else if (errno == ENOTDIR || errno == ENOENT)
-	    {
-	      char *sep = strrchr (state_file_path, G_DIR_SEPARATOR);
-
-	      *sep = '\0';
-	      if (g_mkdir_with_parents (state_file_path, 0755) != 0)
-		{
-		  g_warning ("Could not create directory '%s'",
-			     state_file_path);
-		  g_free (state_file_path);
-		  state_file_path = NULL;
-		  break;
-		}
-
-	      continue;
-	    }
-
-	  g_warning ("Could not create file '%s': %s",
-		     state_file_path, g_strerror (errno));
-	  g_free (state_file_path);
-	  state_file_path = NULL;
-	  break;
-	}
-
-      close (fd);
-      g_file_set_contents (state_file_path, data, -1, NULL);
-      break;
-    }
-  g_free (data);
-
-  restart = generate_command (xsmp->restart_command, xsmp->client_id,
-			      state_file_path);
-  set_properties (xsmp,
-		  ptrarray_prop (SmRestartCommand, restart),
-		  NULL);
-  g_ptr_array_free (restart, TRUE);
-
-  if (state_file_path)
-    {
-      set_properties (xsmp,
-		      array_prop (SmDiscardCommand,
-				  "/bin/rm", "-rf", state_file_path,
-				  NULL),
-		      NULL);
-      g_free (state_file_path);
-    }
-}
-
-static void
-xsmp_interact (SmcConn   smc_conn,
-	       SmPointer client_data)
-{
-  EggSMClientXSMP *xsmp = client_data;
-  EggSMClient *client = client_data;
-
-  g_debug ("Received Interact message in state %s",
-	   EGG_SM_CLIENT_XSMP_STATE (xsmp));
-
-  if (xsmp->state != XSMP_STATE_INTERACT_REQUEST)
-    {
-      fix_broken_state (xsmp, "Interact", TRUE, TRUE);
-      return;
-    }
-
-  xsmp->state = XSMP_STATE_INTERACT;
-  egg_sm_client_quit_requested (client);
-}
-
-static void
-xsmp_die (SmcConn   smc_conn,
-	  SmPointer client_data)
-{
-  EggSMClientXSMP *xsmp = client_data;
-  EggSMClient *client = client_data;
-
-  g_debug ("Received Die message in state %s",
-	   EGG_SM_CLIENT_XSMP_STATE (xsmp));
-
-  sm_client_xsmp_disconnect (xsmp);
-  egg_sm_client_quit (client);
-}
-
-static void
-xsmp_save_complete (SmcConn   smc_conn,
-		    SmPointer client_data)
-{
-  EggSMClientXSMP *xsmp = client_data;
-
-  g_debug ("Received SaveComplete message in state %s",
-	   EGG_SM_CLIENT_XSMP_STATE (xsmp));
-
-  if (xsmp->state == XSMP_STATE_SAVE_YOURSELF_DONE)
-    xsmp->state = XSMP_STATE_IDLE;
-  else
-    fix_broken_state (xsmp, "SaveComplete", FALSE, FALSE);
-}
-
-static void
-xsmp_shutdown_cancelled (SmcConn   smc_conn,
-			 SmPointer client_data)
-{
-  EggSMClientXSMP *xsmp = client_data;
-  EggSMClient *client = client_data;
-
-  g_debug ("Received ShutdownCancelled message in state %s",
-	   EGG_SM_CLIENT_XSMP_STATE (xsmp));
-
-  xsmp->shutting_down = FALSE;
-
-  if (xsmp->state == XSMP_STATE_SAVE_YOURSELF_DONE)
-    {
-      /* We've finished interacting and now the SM has agreed to
-       * cancel the shutdown.
-       */
-      xsmp->state = XSMP_STATE_IDLE;
-      egg_sm_client_quit_cancelled (client);
-    }
-  else if (xsmp->state == XSMP_STATE_SHUTDOWN_CANCELLED)
-    {
-      /* Hm... ok, so we got a shutdown SaveYourself, which got
-       * cancelled, but the application was still interacting, so we
-       * didn't tell it yet, and then *another* SaveYourself arrived,
-       * which we must still be waiting to tell the app about, except
-       * that now that SaveYourself has been cancelled too! Dizzy yet?
-       */
-      xsmp->waiting_to_save_myself = FALSE;
-      update_pending_events (xsmp);
-    }
-  else
-    {
-      g_debug ("Sending SaveYourselfDone(False)");
-      SmcSaveYourselfDone (xsmp->connection, False);
-
-      if (xsmp->state == XSMP_STATE_INTERACT)
-	{
-	  /* The application is currently interacting, so we can't
-	   * tell it about the cancellation yet; we will wait until
-	   * after it calls egg_sm_client_will_quit().
-	   */
-	  xsmp->state = XSMP_STATE_SHUTDOWN_CANCELLED;
-	}
-      else
-	{
-	  /* The shutdown was cancelled before the application got a
-	   * chance to interact.
-	   */
-	  xsmp->state = XSMP_STATE_IDLE;
-	}
-    }
-}
-
-/* Utilities */
-
-/* Create a restart/clone/Exec command based on @restart_command.
- * If @client_id is non-%NULL, add "--sm-client-id @client_id".
- * If @state_file is non-%NULL, add "--sm-client-state-file @state_file".
- *
- * None of the input strings are g_strdup()ed; the caller must keep
- * them around until it is done with the returned GPtrArray, and must
- * then free the array, but not its contents.
- */
-static GPtrArray *
-generate_command (char **restart_command, const char *client_id,
-		  const char *state_file)
-{
-  GPtrArray *cmd;
-  int i;
-
-  cmd = g_ptr_array_new ();
-  g_ptr_array_add (cmd, restart_command[0]);
-
-  if (client_id)
-    {
-      g_ptr_array_add (cmd, (char *)"--sm-client-id");
-      g_ptr_array_add (cmd, (char *)client_id);
-    }
-
-  if (state_file)
-    {
-      g_ptr_array_add (cmd, (char *)"--sm-client-state-file");
-      g_ptr_array_add (cmd, (char *)state_file);
-    }
-
-  for (i = 1; restart_command[i]; i++)
-    g_ptr_array_add (cmd, restart_command[i]);
-
-  return cmd;
-}
-
-/* Takes a NULL-terminated list of SmProp * values, created by
- * array_prop, ptrarray_prop, string_prop, card8_prop, sets them, and
- * frees them.
- */
-static void
-set_properties (EggSMClientXSMP *xsmp, ...)
-{
-  GPtrArray *props;
-  SmProp *prop;
-  va_list ap;
-  guint i;
-
-  props = g_ptr_array_new ();
-
-  va_start (ap, xsmp);
-  while ((prop = va_arg (ap, SmProp *)))
-    g_ptr_array_add (props, prop);
-  va_end (ap);
-
-  if (xsmp->connection)
-    {
-      SmcSetProperties (xsmp->connection, props->len,
-			(SmProp **)props->pdata);
-    }
-
-  for (i = 0; i < props->len; i++)
-    {
-      prop = props->pdata[i];
-      g_free (prop->vals);
-      g_free (prop);
-    }
-  g_ptr_array_free (props, TRUE);
-}
-
-/* Takes a NULL-terminated list of property names and deletes them. */
-static void
-delete_properties (EggSMClientXSMP *xsmp, ...)
-{
-  GPtrArray *props;
-  char *prop;
-  va_list ap;
-
-  if (!xsmp->connection)
-    return;
-
-  props = g_ptr_array_new ();
-
-  va_start (ap, xsmp);
-  while ((prop = va_arg (ap, char *)))
-    g_ptr_array_add (props, prop);
-  va_end (ap);
-
-  SmcDeleteProperties (xsmp->connection, props->len,
-		       (char **)props->pdata);
-
-  g_ptr_array_free (props, TRUE);
-}
-
-/* Takes an array of strings and creates a LISTofARRAY8 property. The
- * strings are neither dupped nor freed; they need to remain valid
- * until you're done with the SmProp.
- */
-static SmProp *
-array_prop (const char *name, ...) 
-{
-  SmProp *prop;
-  SmPropValue pv;
-  GArray *vals;
-  char *value;
-  va_list ap;
-
-  prop = g_new (SmProp, 1);
-  prop->name = (char *)name;
-  prop->type = (char *)SmLISTofARRAY8;
-
-  vals = g_array_new (FALSE, FALSE, sizeof (SmPropValue));
-
-  va_start (ap, name);
-  while ((value = va_arg (ap, char *)))
-    {
-      pv.length = strlen (value);
-      pv.value = value;
-      g_array_append_val (vals, pv);
-    }
-
-  prop->num_vals = vals->len;
-  prop->vals = (SmPropValue *)vals->data;
-
-  g_array_free (vals, FALSE);
-
-  return prop;
-}
-
-/* Takes a GPtrArray of strings and creates a LISTofARRAY8 property.
- * The array contents are neither dupped nor freed; they need to
- * remain valid until you're done with the SmProp.
- */
-static SmProp *
-ptrarray_prop (const char *name, GPtrArray *values)
-{
-  SmProp *prop;
-  SmPropValue pv;
-  GArray *vals;
-  guint i;
-
-  prop = g_new (SmProp, 1);
-  prop->name = (char *)name;
-  prop->type = (char *)SmLISTofARRAY8;
-
-  vals = g_array_new (FALSE, FALSE, sizeof (SmPropValue));
-
-  for (i = 0; i < values->len; i++)
-    {
-      pv.length = strlen (values->pdata[i]);
-      pv.value = values->pdata[i];
-      g_array_append_val (vals, pv);
-    }
-
-  prop->num_vals = vals->len;
-  prop->vals = (SmPropValue *)vals->data;
-
-  g_array_free (vals, FALSE);
-
-  return prop;
-}
-
-/* Takes a string and creates an ARRAY8 property. The string is
- * neither dupped nor freed; it needs to remain valid until you're
- * done with the SmProp.
- */
-static SmProp *
-string_prop (const char *name, const char *value)
-{
-  SmProp *prop;
-
-  prop = g_new (SmProp, 1);
-  prop->name = (char *)name;
-  prop->type = (char *)SmARRAY8;
-
-  prop->num_vals = 1;
-  prop->vals = g_new (SmPropValue, 1);
-
-  prop->vals[0].length = strlen (value);
-  prop->vals[0].value = (char *)value;
-
-  return prop;
-}
-
-/* Takes a char and creates a CARD8 property. */
-static SmProp *
-card8_prop (const char *name, unsigned char value)
-{
-  SmProp *prop;
-  char *card8val;
-
-  /* To avoid having to allocate and free prop->vals[0], we cheat and
-   * make vals a 2-element-long array and then use the second element
-   * to store value.
-   */
-
-  prop = g_new (SmProp, 1);
-  prop->name = (char *)name;
-  prop->type = (char *)SmCARD8;
-
-  prop->num_vals = 1;
-  prop->vals = g_new (SmPropValue, 2);
-  card8val = (char *)(&prop->vals[1]);
-  card8val[0] = value;
-
-  prop->vals[0].length = 1;
-  prop->vals[0].value = card8val;
-
-  return prop;
-}
-
-/* ICE code. This makes no effort to play nice with anyone else trying
- * to use libICE. Fortunately, no one uses libICE for anything other
- * than SM. (DCOP uses ICE, but it has its own private copy of
- * libICE.)
- *
- * When this moves to gtk, it will need to be cleverer, to avoid
- * tripping over old apps that use GnomeClient or that use libSM
- * directly.
- */
-
-#include <X11/ICE/ICElib.h>
-#include <fcntl.h>
-
-static void        ice_error_handler    (IceConn        ice_conn,
-					 Bool           swap,
-					 int            offending_minor_opcode,
-					 unsigned long  offending_sequence,
-					 int            error_class,
-					 int            severity,
-					 IcePointer     values);
-static void        ice_io_error_handler (IceConn        ice_conn);
-static void        ice_connection_watch (IceConn        ice_conn,
-					 IcePointer     client_data,
-					 Bool           opening,
-					 IcePointer    *watch_data);
-
-static void
-ice_init (void)
-{
-  IceSetIOErrorHandler (ice_io_error_handler);
-  IceSetErrorHandler (ice_error_handler);
-  IceAddConnectionWatch (ice_connection_watch, NULL);
-}
-
-static gboolean
-process_ice_messages (IceConn ice_conn)
-{
-  IceProcessMessagesStatus status;
-
-  gdk_threads_enter ();
-  status = IceProcessMessages (ice_conn, NULL, NULL);
-  gdk_threads_leave ();
-
-  switch (status)
-    {
-    case IceProcessMessagesSuccess:
-      return TRUE;
-
-    case IceProcessMessagesIOError:
-      sm_client_xsmp_disconnect (IceGetConnectionContext (ice_conn));
-      return FALSE;
-
-    case IceProcessMessagesConnectionClosed:
-      return FALSE;
-
-    default:
-      g_assert_not_reached ();
-    }
-}
-
-static gboolean
-ice_iochannel_watch (GIOChannel   *channel,
-		     GIOCondition  condition,
-		     gpointer      client_data)
-{
-  return process_ice_messages (client_data);
-}
-
-static void
-ice_connection_watch (IceConn     ice_conn,
-		      IcePointer  client_data,
-		      Bool        opening,
-		      IcePointer *watch_data)
-{
-  guint watch_id;
-
-  if (opening)
-    {
-      GIOChannel *channel;
-      int fd = IceConnectionNumber (ice_conn);
-
-      fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);
-      channel = g_io_channel_unix_new (fd);
-      watch_id = g_io_add_watch (channel, G_IO_IN | G_IO_ERR,
-				 ice_iochannel_watch, ice_conn);
-      g_io_channel_unref (channel);
-
-      *watch_data = GUINT_TO_POINTER (watch_id);
-    }
-  else
-    {
-      watch_id = GPOINTER_TO_UINT (*watch_data);
-      g_source_remove (watch_id);
-    }
-}
-
-static void
-ice_error_handler (IceConn       ice_conn,
-		   Bool          swap,
-		   int           offending_minor_opcode,
-		   unsigned long offending_sequence,
-		   int           error_class,
-		   int           severity,
-		   IcePointer    values)
-{
-  /* Do nothing */
-} 
-
-static void
-ice_io_error_handler (IceConn ice_conn)
-{
-  /* Do nothing */
-} 
-
-static void
-smc_error_handler (SmcConn       smc_conn,
-                   Bool          swap,
-                   int           offending_minor_opcode,
-                   unsigned long offending_sequence,
-                   int           error_class,
-                   int           severity,
-                   SmPointer     values)
-{
-  /* Do nothing */
-}
diff --git a/egg/eggsmclient.c b/egg/eggsmclient.c
deleted file mode 100644
index 92be8a7..0000000
--- a/egg/eggsmclient.c
+++ /dev/null
@@ -1,604 +0,0 @@
-/*
- * Copyright (C) 2007 Novell, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-
-#include <string.h>
-#include <glib/gi18n.h>
-
-#include "eggsmclient.h"
-#include "eggsmclient-private.h"
-
-static void egg_sm_client_debug_handler (const char *log_domain,
-					 GLogLevelFlags log_level,
-					 const char *message,
-					 gpointer user_data);
-
-enum {
-  SAVE_STATE,
-  QUIT_REQUESTED,
-  QUIT_CANCELLED,
-  QUIT,
-  LAST_SIGNAL
-};
-
-static guint signals[LAST_SIGNAL];
-
-struct _EggSMClientPrivate {
-  GKeyFile *state_file;
-};
-
-#define EGG_SM_CLIENT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EGG_TYPE_SM_CLIENT, EggSMClientPrivate))
-
-G_DEFINE_TYPE (EggSMClient, egg_sm_client, G_TYPE_OBJECT)
-
-static EggSMClient *global_client;
-static EggSMClientMode global_client_mode = EGG_SM_CLIENT_MODE_NORMAL;
-
-static void
-egg_sm_client_init (EggSMClient *client)
-{
-  ;
-}
-
-static void
-egg_sm_client_class_init (EggSMClientClass *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  g_type_class_add_private (klass, sizeof (EggSMClientPrivate));
-
-  /**
-   * EggSMClient::save_state:
-   * @client: the client
-   * @state_file: a #GKeyFile to save state information into
-   *
-   * Emitted when the session manager has requested that the
-   * application save information about its current state. The
-   * application should save its state into @state_file, and then the
-   * session manager may then restart the application in a future
-   * session and tell it to initialize itself from that state.
-   *
-   * You should not save any data into @state_file's "start group"
-   * (ie, the %NULL group). Instead, applications should save their
-   * data into groups with names that start with the application name,
-   * and libraries that connect to this signal should save their data
-   * into groups with names that start with the library name.
-   *
-   * Alternatively, rather than (or in addition to) using @state_file,
-   * the application can save its state by calling
-   * egg_sm_client_set_restart_command() during the processing of this
-   * signal (eg, to include a list of files to open).
-   **/
-  signals[SAVE_STATE] =
-    g_signal_new ("save_state",
-                  G_OBJECT_CLASS_TYPE (object_class),
-                  G_SIGNAL_RUN_LAST,
-                  G_STRUCT_OFFSET (EggSMClientClass, save_state),
-                  NULL, NULL,
-                  g_cclosure_marshal_VOID__POINTER,
-                  G_TYPE_NONE,
-                  1, G_TYPE_POINTER);
-
-  /**
-   * EggSMClient::quit_requested:
-   * @client: the client
-   *
-   * Emitted when the session manager requests that the application
-   * exit (generally because the user is logging out). The application
-   * should decide whether or not it is willing to quit (perhaps after
-   * asking the user what to do with documents that have unsaved
-   * changes) and then call egg_sm_client_will_quit(), passing %TRUE
-   * or %FALSE to give its answer to the session manager. (It does not
-   * need to give an answer before returning from the signal handler;
-   * it can interact with the user asynchronously and then give its
-   * answer later on.) If the application does not connect to this
-   * signal, then #EggSMClient will automatically return %TRUE on its
-   * behalf.
-   *
-   * The application should not save its session state as part of
-   * handling this signal; if the user has requested that the session
-   * be saved when logging out, then ::save_state will be emitted
-   * separately.
-   * 
-   * If the application agrees to quit, it should then wait for either
-   * the ::quit_cancelled or ::quit signals to be emitted.
-   **/
-  signals[QUIT_REQUESTED] =
-    g_signal_new ("quit_requested",
-                  G_OBJECT_CLASS_TYPE (object_class),
-                  G_SIGNAL_RUN_LAST,
-                  G_STRUCT_OFFSET (EggSMClientClass, quit_requested),
-                  NULL, NULL,
-                  g_cclosure_marshal_VOID__VOID,
-                  G_TYPE_NONE,
-                  0);
-
-  /**
-   * EggSMClient::quit_cancelled:
-   * @client: the client
-   *
-   * Emitted when the session manager decides to cancel a logout after
-   * the application has already agreed to quit. After receiving this
-   * signal, the application can go back to what it was doing before
-   * receiving the ::quit_requested signal.
-   **/
-  signals[QUIT_CANCELLED] =
-    g_signal_new ("quit_cancelled",
-                  G_OBJECT_CLASS_TYPE (object_class),
-                  G_SIGNAL_RUN_LAST,
-                  G_STRUCT_OFFSET (EggSMClientClass, quit_cancelled),
-                  NULL, NULL,
-                  g_cclosure_marshal_VOID__VOID,
-                  G_TYPE_NONE,
-                  0);
-
-  /**
-   * EggSMClient::quit:
-   * @client: the client
-   *
-   * Emitted when the session manager wants the application to quit
-   * (generally because the user is logging out). The application
-   * should exit as soon as possible after receiving this signal; if
-   * it does not, the session manager may choose to forcibly kill it.
-   *
-   * Normally a GUI application would only be sent a ::quit if it
-   * agreed to quit in response to a ::quit_requested signal. However,
-   * this is not guaranteed; in some situations the session manager
-   * may decide to end the session without giving applications a
-   * chance to object.
-   **/
-  signals[QUIT] =
-    g_signal_new ("quit",
-                  G_OBJECT_CLASS_TYPE (object_class),
-                  G_SIGNAL_RUN_LAST,
-                  G_STRUCT_OFFSET (EggSMClientClass, quit),
-                  NULL, NULL,
-                  g_cclosure_marshal_VOID__VOID,
-                  G_TYPE_NONE,
-                  0);
-}
-
-static gboolean sm_client_disable = FALSE;
-static char *sm_client_state_file = NULL;
-static char *sm_client_id = NULL;
-static char *sm_config_prefix = NULL;
-
-static gboolean
-sm_client_post_parse_func (GOptionContext  *context,
-			   GOptionGroup    *group,
-			   gpointer         data,
-			   GError         **error)
-{
-  EggSMClient *client = egg_sm_client_get ();
-
-  if (sm_client_id == NULL)
-    {
-      const gchar *desktop_autostart_id;
-
-      desktop_autostart_id = g_getenv ("DESKTOP_AUTOSTART_ID");
-
-      if (desktop_autostart_id != NULL)
-        sm_client_id = g_strdup (desktop_autostart_id);
-    }
-
-  /* Unset DESKTOP_AUTOSTART_ID in order to avoid child processes to
-   * use the same client id. */
-  g_unsetenv ("DESKTOP_AUTOSTART_ID");
-
-  if (global_client_mode != EGG_SM_CLIENT_MODE_DISABLED &&
-      EGG_SM_CLIENT_GET_CLASS (client)->startup)
-    EGG_SM_CLIENT_GET_CLASS (client)->startup (client, sm_client_id);
-  return TRUE;
-}
-
-/**
- * egg_sm_client_get_option_group:
- *
- * Creates a %GOptionGroup containing the session-management-related
- * options. You should add this group to the application's
- * %GOptionContext if you want to use #EggSMClient.
- *
- * Return value: the %GOptionGroup
- **/
-GOptionGroup *
-egg_sm_client_get_option_group (void)
-{
-  const GOptionEntry entries[] = {
-    { "sm-client-disable", 0, 0,
-      G_OPTION_ARG_NONE, &sm_client_disable,
-      N_("Disable connection to session manager"), NULL },
-    { "sm-client-state-file", 0, 0,
-      G_OPTION_ARG_FILENAME, &sm_client_state_file,
-      N_("Specify file containing saved configuration"), N_("FILE") },
-    { "sm-client-id", 0, 0,
-      G_OPTION_ARG_STRING, &sm_client_id,
-      N_("Specify session management ID"), N_("ID") },
-    /* GnomeClient compatibility option */
-    { "sm-disable", 0, G_OPTION_FLAG_HIDDEN,
-      G_OPTION_ARG_NONE, &sm_client_disable,
-      NULL, NULL },
-    /* GnomeClient compatibility option. This is a dummy option that only
-     * exists so that sessions saved by apps with GnomeClient can be restored
-     * later when they've switched to EggSMClient. See bug #575308.
-     */
-    { "sm-config-prefix", 0, G_OPTION_FLAG_HIDDEN,
-      G_OPTION_ARG_STRING, &sm_config_prefix,
-      NULL, NULL },
-    { NULL }
-  };
-  GOptionGroup *group;
-
-  /* Use our own debug handler for the "EggSMClient" domain. */
-  g_log_set_handler (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,
-		     egg_sm_client_debug_handler, NULL);
-
-  group = g_option_group_new ("sm-client",
-			      _("Session management options:"),
-			      _("Show session management options"),
-			      NULL, NULL);
-  g_option_group_add_entries (group, entries);
-  g_option_group_set_parse_hooks (group, NULL, sm_client_post_parse_func);
-
-  return group;
-}
-
-/**
- * egg_sm_client_set_mode:
- * @mode: an #EggSMClient mode
- *
- * Sets the "mode" of #EggSMClient as follows:
- *
- *    %EGG_SM_CLIENT_MODE_DISABLED: Session management is completely
- *    disabled, until the mode is changed again. The application will
- *    not even connect to the session manager. (egg_sm_client_get()
- *    will still return an #EggSMClient object.)
- *
- *    %EGG_SM_CLIENT_MODE_NO_RESTART: The application will connect to
- *    the session manager (and thus will receive notification when the
- *    user is logging out, etc), but will request to not be
- *    automatically restarted with saved state in future sessions.
- *
- *    %EGG_SM_CLIENT_MODE_NORMAL: The default. #EggSMCLient will
- *    function normally.
- *
- * This must be called before the application's main loop begins and
- * before any call to egg_sm_client_get(), unless the mode was set
- * earlier to %EGG_SM_CLIENT_MODE_DISABLED and this call enables
- * session management. Note that option parsing will call
- * egg_sm_client_get().
- **/
-void
-egg_sm_client_set_mode (EggSMClientMode mode)
-{
-  EggSMClientMode old_mode = global_client_mode;
-
-  g_return_if_fail (global_client == NULL || global_client_mode == EGG_SM_CLIENT_MODE_DISABLED);
-  g_return_if_fail (!(global_client != NULL && mode == EGG_SM_CLIENT_MODE_DISABLED));
-
-  global_client_mode = mode;
-
-  if (global_client != NULL && old_mode == EGG_SM_CLIENT_MODE_DISABLED)
-    {
-      if (EGG_SM_CLIENT_GET_CLASS (global_client)->startup)
-        EGG_SM_CLIENT_GET_CLASS (global_client)->startup (global_client, sm_client_id);
-    }
-}
-
-/**
- * egg_sm_client_get_mode:
- *
- * Gets the global #EggSMClientMode. See egg_sm_client_set_mode()
- * for details.
- *
- * Return value: the global #EggSMClientMode
- **/
-EggSMClientMode
-egg_sm_client_get_mode (void)
-{
-  return global_client_mode;
-}
-
-/**
- * egg_sm_client_get:
- *
- * Returns the master #EggSMClient for the application.
- *
- * On platforms that support saved sessions (ie, POSIX/X11), the
- * application will only request to be restarted by the session
- * manager if you call egg_set_desktop_file() to set an application
- * desktop file. In particular, if the desktop file contains the key
- * "X
- *
- * Return value: the master #EggSMClient.
- **/
-EggSMClient *
-egg_sm_client_get (void)
-{
-  if (!global_client)
-    {
-      if (!sm_client_disable)
-	{
-#if defined (GDK_WINDOWING_WIN32)
-	  global_client = egg_sm_client_win32_new ();
-#elif defined (GDK_WINDOWING_QUARTZ)
-	  global_client = egg_sm_client_osx_new ();
-#else
-	  /* If both D-Bus and XSMP are compiled in, try XSMP first
-	   * (since it supports state saving) and fall back to D-Bus
-	   * if XSMP isn't available.
-	   */
-# ifdef EGG_SM_CLIENT_BACKEND_XSMP
-	  global_client = egg_sm_client_xsmp_new ();
-# endif
-# ifdef EGG_SM_CLIENT_BACKEND_DBUS
-	  if (!global_client)
-	    global_client = egg_sm_client_dbus_new ();
-# endif
-#endif
-	}
-
-      /* Fallback: create a dummy client, so that callers don't have
-       * to worry about a %NULL return value.
-       */
-      if (!global_client)
-	global_client = g_object_new (EGG_TYPE_SM_CLIENT, NULL);
-    }
-
-  return global_client;
-}
-
-/**
- * egg_sm_client_is_resumed:
- * @client: the client
- *
- * Checks whether or not the current session has been resumed from
- * a previous saved session. If so, the application should call
- * egg_sm_client_get_state_file() and restore its state from the
- * returned #GKeyFile.
- *
- * Return value: %TRUE if the session has been resumed
- **/
-gboolean
-egg_sm_client_is_resumed (EggSMClient *client)
-{
-  g_return_val_if_fail (client == global_client, FALSE);
-
-  return sm_client_state_file != NULL;
-}
-
-/**
- * egg_sm_client_get_state_file:
- * @client: the client
- *
- * If the application was resumed by the session manager, this will
- * return the #GKeyFile containing its state from the previous
- * session.
- *
- * Note that other libraries and #EggSMClient itself may also store
- * state in the key file, so if you call egg_sm_client_get_groups(),
- * on it, the return value will likely include groups that you did not
- * put there yourself. (It is also not guaranteed that the first
- * group created by the application will still be the "start group"
- * when it is resumed.)
- *
- * Return value: the #GKeyFile containing the application's earlier
- * state, or %NULL on error. You should not free this key file; it
- * is owned by @client.
- **/
-GKeyFile *
-egg_sm_client_get_state_file (EggSMClient *client)
-{
-  EggSMClientPrivate *priv = EGG_SM_CLIENT_GET_PRIVATE (client);
-  char *state_file_path;
-  GError *err = NULL;
-
-  g_return_val_if_fail (client == global_client, NULL);
-
-  if (!sm_client_state_file)
-    return NULL;
-  if (priv->state_file)
-    return priv->state_file;
-
-  if (!strncmp (sm_client_state_file, "file://", 7))
-    state_file_path = g_filename_from_uri (sm_client_state_file, NULL, NULL);
-  else
-    state_file_path = g_strdup (sm_client_state_file);
-
-  priv->state_file = g_key_file_new ();
-  if (!g_key_file_load_from_file (priv->state_file, state_file_path, 0, &err))
-    {
-      g_warning ("Could not load SM state file '%s': %s",
-		 sm_client_state_file, err->message);
-      g_clear_error (&err);
-      g_key_file_free (priv->state_file);
-      priv->state_file = NULL;
-    }
-
-  g_free (state_file_path);
-  return priv->state_file;
-}
-
-/**
- * egg_sm_client_set_restart_command:
- * @client: the client
- * @argc: the length of @argv
- * @argv: argument vector
- *
- * Sets the command used to restart @client if it does not have a
- * .desktop file that can be used to find its restart command.
- *
- * This can also be used when handling the ::save_state signal, to
- * save the current state via an updated command line. (Eg, providing
- * a list of filenames to open when the application is resumed.)
- **/
-void
-egg_sm_client_set_restart_command (EggSMClient  *client,
-				   int           argc,
-				   const char  **argv)
-{
-  g_return_if_fail (EGG_IS_SM_CLIENT (client));
-
-  if (EGG_SM_CLIENT_GET_CLASS (client)->set_restart_command)
-    EGG_SM_CLIENT_GET_CLASS (client)->set_restart_command (client, argc, argv);
-}
-
-/**
- * egg_sm_client_will_quit:
- * @client: the client
- * @will_quit: whether or not the application is willing to quit
- *
- * This MUST be called in response to the ::quit_requested signal, to
- * indicate whether or not the application is willing to quit. The
- * application may call it either directly from the signal handler, or
- * at some later point (eg, after asynchronously interacting with the
- * user).
- *
- * If the application does not connect to ::quit_requested,
- * #EggSMClient will call this method on its behalf (passing %TRUE
- * for @will_quit).
- *
- * After calling this method, the application should wait to receive
- * either ::quit_cancelled or ::quit.
- **/
-void
-egg_sm_client_will_quit (EggSMClient *client,
-			 gboolean     will_quit)
-{
-  g_return_if_fail (EGG_IS_SM_CLIENT (client));
-
-  if (EGG_SM_CLIENT_GET_CLASS (client)->will_quit)
-    EGG_SM_CLIENT_GET_CLASS (client)->will_quit (client, will_quit);
-}
-
-/**
- * egg_sm_client_end_session:
- * @style: a hint at how to end the session
- * @request_confirmation: whether or not the user should get a chance
- * to confirm the action
- *
- * Requests that the session manager end the current session. @style
- * indicates how the session should be ended, and
- * @request_confirmation indicates whether or not the user should be
- * given a chance to confirm the logout/reboot/shutdown. Both of these
- * flags are merely hints though; the session manager may choose to
- * ignore them.
- *
- * Return value: %TRUE if the request was sent; %FALSE if it could not
- * be (eg, because it could not connect to the session manager).
- **/
-gboolean
-egg_sm_client_end_session (EggSMClientEndStyle  style,
-			   gboolean             request_confirmation)
-{
-  EggSMClient *client = egg_sm_client_get ();
-
-  g_return_val_if_fail (EGG_IS_SM_CLIENT (client), FALSE);
-
-  if (EGG_SM_CLIENT_GET_CLASS (client)->end_session)
-    {
-      return EGG_SM_CLIENT_GET_CLASS (client)->end_session (client, style,
-							    request_confirmation);
-    }
-  else
-    return FALSE;
-}
-
-/* Signal-emitting callbacks from platform-specific code */
-
-GKeyFile *
-egg_sm_client_save_state (EggSMClient *client)
-{
-  GKeyFile *state_file;
-  char *group;
-
-  g_return_val_if_fail (client == global_client, NULL);
-
-  state_file = g_key_file_new ();
-
-  g_debug ("Emitting save_state");
-  g_signal_emit (client, signals[SAVE_STATE], 0, state_file);
-  g_debug ("Done emitting save_state");
-
-  group = g_key_file_get_start_group (state_file);
-  if (group)
-    {
-      g_free (group);
-      return state_file;
-    }
-  else
-    {
-      g_key_file_free (state_file);
-      return NULL;
-    }
-}
-
-void
-egg_sm_client_quit_requested (EggSMClient *client)
-{
-  g_return_if_fail (client == global_client);
-
-  if (!g_signal_has_handler_pending (client, signals[QUIT_REQUESTED], 0, FALSE))
-    {
-      g_debug ("Not emitting quit_requested because no one is listening");
-      egg_sm_client_will_quit (client, TRUE);
-      return;
-    }
-
-  g_debug ("Emitting quit_requested");
-  g_signal_emit (client, signals[QUIT_REQUESTED], 0);
-  g_debug ("Done emitting quit_requested");
-}
-
-void
-egg_sm_client_quit_cancelled (EggSMClient *client)
-{
-  g_return_if_fail (client == global_client);
-
-  g_debug ("Emitting quit_cancelled");
-  g_signal_emit (client, signals[QUIT_CANCELLED], 0);
-  g_debug ("Done emitting quit_cancelled");
-}
-
-void
-egg_sm_client_quit (EggSMClient *client)
-{
-  g_return_if_fail (client == global_client);
-
-  g_debug ("Emitting quit");
-  g_signal_emit (client, signals[QUIT], 0);
-  g_debug ("Done emitting quit");
-
-  /* FIXME: should we just call gtk_main_quit() here? */
-}
-
-static void
-egg_sm_client_debug_handler (const char *log_domain,
-			     GLogLevelFlags log_level,
-			     const char *message,
-			     gpointer user_data)
-{
-  static int debug = -1;
-
-  if (debug < 0)
-    debug = (g_getenv ("EGG_SM_CLIENT_DEBUG") != NULL);
-
-  if (debug)
-    g_log_default_handler (log_domain, log_level, message, NULL);
-}
diff --git a/egg/eggsmclient.h b/egg/eggsmclient.h
deleted file mode 100644
index e620b75..0000000
--- a/egg/eggsmclient.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/* eggsmclient.h
- * Copyright (C) 2007 Novell, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef __EGG_SM_CLIENT_H__
-#define __EGG_SM_CLIENT_H__
-
-#include <glib-object.h>
-
-G_BEGIN_DECLS
-
-#define EGG_TYPE_SM_CLIENT            (egg_sm_client_get_type ())
-#define EGG_SM_CLIENT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), EGG_TYPE_SM_CLIENT, EggSMClient))
-#define EGG_SM_CLIENT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), EGG_TYPE_SM_CLIENT, EggSMClientClass))
-#define EGG_IS_SM_CLIENT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EGG_TYPE_SM_CLIENT))
-#define EGG_IS_SM_CLIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EGG_TYPE_SM_CLIENT))
-#define EGG_SM_CLIENT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), EGG_TYPE_SM_CLIENT, EggSMClientClass))
-
-typedef struct _EggSMClient        EggSMClient;
-typedef struct _EggSMClientClass   EggSMClientClass;
-typedef struct _EggSMClientPrivate EggSMClientPrivate;
-
-typedef enum {
-  EGG_SM_CLIENT_END_SESSION_DEFAULT,
-  EGG_SM_CLIENT_LOGOUT,
-  EGG_SM_CLIENT_REBOOT,
-  EGG_SM_CLIENT_SHUTDOWN
-} EggSMClientEndStyle;
-
-typedef enum {
-  EGG_SM_CLIENT_MODE_DISABLED,
-  EGG_SM_CLIENT_MODE_NO_RESTART,
-  EGG_SM_CLIENT_MODE_NORMAL
-} EggSMClientMode;
-
-struct _EggSMClient
-{
-  GObject parent;
-
-};
-
-struct _EggSMClientClass
-{
-  GObjectClass parent_class;
-
-  /* signals */
-  void (*save_state)       (EggSMClient *client,
-			    GKeyFile    *state_file);
-
-  void (*quit_requested)   (EggSMClient *client);
-  void (*quit_cancelled)   (EggSMClient *client);
-  void (*quit)             (EggSMClient *client);
-
-  /* virtual methods */
-  void	   (*startup)             (EggSMClient          *client,
-				   const char           *client_id);
-  void	   (*set_restart_command) (EggSMClient          *client,
-				   int                   argc,
-				   const char          **argv);
-  void	   (*will_quit)           (EggSMClient          *client,
-				   gboolean              will_quit);
-  gboolean (*end_session)         (EggSMClient          *client,
-				   EggSMClientEndStyle   style,
-				   gboolean              request_confirmation);
-
-  /* Padding for future expansion */
-  void (*_egg_reserved1) (void);
-  void (*_egg_reserved2) (void);
-  void (*_egg_reserved3) (void);
-  void (*_egg_reserved4) (void);
-};
-
-GType            egg_sm_client_get_type            (void) G_GNUC_CONST;
-
-GOptionGroup    *egg_sm_client_get_option_group    (void);
-
-/* Initialization */
-void             egg_sm_client_set_mode            (EggSMClientMode mode);
-EggSMClientMode  egg_sm_client_get_mode            (void);
-EggSMClient     *egg_sm_client_get                 (void);
-
-/* Resuming a saved session */
-gboolean         egg_sm_client_is_resumed          (EggSMClient *client);
-GKeyFile        *egg_sm_client_get_state_file      (EggSMClient *client);
-
-/* Alternate means of saving state */
-void             egg_sm_client_set_restart_command (EggSMClient  *client,
-						    int           argc,
-						    const char  **argv);
-
-/* Handling "quit_requested" signal */
-void             egg_sm_client_will_quit           (EggSMClient *client,
-						    gboolean     will_quit);
-
-/* Initiate a logout/reboot/shutdown */
-gboolean         egg_sm_client_end_session         (EggSMClientEndStyle  style,
-						    gboolean             request_confirmation);
-
-G_END_DECLS
-
-
-#endif /* __EGG_SM_CLIENT_H__ */
diff --git a/gnome-session/Makefile.am b/gnome-session/Makefile.am
index 6392653..4ebd790 100644
--- a/gnome-session/Makefile.am
+++ b/gnome-session/Makefile.am
@@ -1,11 +1,5 @@
 NULL =
-bin_PROGRAMS = gnome-session
-libexec_PROGRAMS = gnome-session-failed
 noinst_LTLIBRARIES = libgsmutil.la
-noinst_PROGRAMS = 		\
-	test-client-dbus	\
-	test-inhibit		\
-	test-process-helper
 
 AM_CPPFLAGS =					\
 	$(GTK3_CFLAGS)				\
@@ -14,83 +8,6 @@ AM_CPPFLAGS =					\
 
 AM_CFLAGS = $(WARN_CFLAGS)
 
-gnome_session_SOURCES =				\
-	gsm-app.h				\
-	gsm-app.c				\
-	gsm-autostart-app.h			\
-	gsm-autostart-app.c			\
-	gsm-client.c				\
-	gsm-client.h				\
-	gsm-xsmp-client.h			\
-	gsm-xsmp-client.c			\
-	gsm-dbus-client.h			\
-	gsm-dbus-client.c			\
-	gsm-fail-whale.h			\
-	gsm-fail-whale.c			\
-	gsm-system.h				\
-	gsm-system.c				\
-	gsm-consolekit.c			\
-	gsm-consolekit.h			\
-	gsm-systemd.h				\
-	gsm-systemd.c				\
-	gsm-presence.h				\
-	gsm-presence-flag.h			\
-	gsm-presence.c				\
-	gdm-log.h				\
-	gdm-log.c				\
-	main.c					\
-	gsm-store.h				\
-	gsm-store.c				\
-	gsm-inhibitor.h				\
-	gsm-inhibitor.c				\
-	gsm-inhibitor-flag.h			\
-	gsm-manager.c				\
-	gsm-manager.h				\
-	gsm-manager-logout-mode.h		\
-	gsm-process-helper.c			\
-	gsm-process-helper.h			\
-	gsm-session-fill.c			\
-	gsm-session-fill.h			\
-	gsm-session-save.c			\
-	gsm-session-save.h			\
-	gsm-shell-extensions.c			\
-	gsm-shell-extensions.h			\
-	gsm-shell.c				\
-	gsm-shell.h				\
-	gsm-xsmp-server.c			\
-	gsm-xsmp-server.h
-
-gnome_session_CPPFLAGS =			\
-	$(AM_CPPFLAGS)				\
-	$(X11_CFLAGS)				\
-	$(SM_CFLAGS)				\
-	$(ICE_CFLAGS)				\
-	$(XEXT_CFLAGS)				\
-	$(GCONF_CFLAGS)				\
-	$(SYSTEMD_CFLAGS)			\
-	$(GIOUNIX_CFLAGS)			\
-	-I$(top_srcdir)/egg			\
-	-DLOCALE_DIR=\""$(datadir)/locale"\"	\
-	-DDATA_DIR=\""$(datadir)/gnome-session"\" \
-        -DLIBEXECDIR=\"$(libexecdir)\"		\
-	-DGTKBUILDER_DIR=\""$(pkgdatadir)"\"	\
-	-DGCONF_SANITY_CHECK=\""$(GCONF_SANITY_CHECK)"\" \
-	-DGCONFTOOL_CMD=\"$(GCONFTOOL)\"
-
-gnome_session_LDADD =				\
-	libgsmutil.la 				\
-	$(X11_LIBS)				\
-	$(SM_LIBS)				\
-	$(ICE_LIBS)				\
-	$(XRENDER_LIBS)				\
-	$(XTEST_LIBS)				\
-	$(XEXT_LIBS)				\
-	$(GNOME_SESSION_LIBS)			\
-	$(GCONF_LIBS)				\
-	$(SYSTEMD_LIBS)				\
-	$(GIOUNIX_LIBS)				\
-	$(EXECINFO_LIBS)
-
 libgsmutil_la_SOURCES =				\
 	gsm-util.c				\
 	gsm-util.h
@@ -102,59 +19,4 @@ libgsmutil_la_LIBADD = 				\
 	$(GNOME_SESSION_LIBS)			\
 	$(NULL)
 
-gnome_session_failed_SOURCES =         \
-       gsm-fail-whale-dialog.c \
-       gsm-fail-whale-dialog.h \
-       gsm-icon-names.h
-
-gnome_session_failed_CPPFLAGS = \
-       $(GTK3_CFLAGS)          \
-       -DLOCALE_DIR=\""$(datadir)/locale"\"
-
-gnome_session_failed_LDADD =   \
-       $(GTK3_LIBS)
-
-test_inhibit_SOURCES = test-inhibit.c
-test_inhibit_LDADD = $(GTK3_LIBS) $(GNOME_SESSION_LIBS)
-
-test_client_dbus_SOURCES = test-client-dbus.c
-test_client_dbus_LDADD = $(DBUS_GLIB_LIBS)
-
-test_process_helper_SOURCES = test-process-helper.c gsm-process-helper.c gsm-process-helper.h
-test_process_helper_LDADD = $(DBUS_GLIB_LIBS)
-
-gsm-manager-glue.h: org.gnome.SessionManager.xml Makefile.am
-	$(AM_V_GEN)dbus-binding-tool --prefix=gsm_manager --mode=glib-server --output=gsm-manager-glue.h $(srcdir)/org.gnome.SessionManager.xml
-
-gsm-client-glue.h: org.gnome.SessionManager.Client.xml Makefile.am
-	$(AM_V_GEN)dbus-binding-tool --prefix=gsm_client --mode=glib-server --output=gsm-client-glue.h $(srcdir)/org.gnome.SessionManager.Client.xml
-
-gsm-app-glue.h: org.gnome.SessionManager.App.xml Makefile.am
-	$(AM_V_GEN)dbus-binding-tool --prefix=gsm_app --mode=glib-server --output=gsm-app-glue.h $(srcdir)/org.gnome.SessionManager.App.xml
-
-gsm-inhibitor-glue.h: org.gnome.SessionManager.Inhibitor.xml Makefile.am
-	$(AM_V_GEN)dbus-binding-tool --prefix=gsm_inhibitor --mode=glib-server --output=gsm-inhibitor-glue.h $(srcdir)/org.gnome.SessionManager.Inhibitor.xml
-
-gsm-presence-glue.h: org.gnome.SessionManager.Presence.xml Makefile.am
-	$(AM_V_GEN)dbus-binding-tool --prefix=gsm_presence --mode=glib-server --output=gsm-presence-glue.h $(srcdir)/org.gnome.SessionManager.Presence.xml
-
-BUILT_SOURCES =			\
-	gsm-manager-glue.h	\
-	gsm-presence-glue.h	\
-	gsm-inhibitor-glue.h	\
-	gsm-client-glue.h	\
-	gsm-app-glue.h
-
-EXTRA_DIST =						\
-	README						\
-	org.gnome.SessionManager.xml			\
-	org.gnome.SessionManager.App.xml		\
-	org.gnome.SessionManager.Client.xml		\
-	org.gnome.SessionManager.ClientPrivate.xml	\
-	org.gnome.SessionManager.Inhibitor.xml		\
-	org.gnome.SessionManager.Presence.xml
-
-CLEANFILES =	\
-	$(BUILT_SOURCES)
-
 -include $(top_srcdir)/git.mk
diff --git a/gnome-session/README b/gnome-session/README
deleted file mode 100644
index 5da6e3d..0000000
--- a/gnome-session/README
+++ /dev/null
@@ -1,69 +0,0 @@
-See also http://live.gnome.org/SessionManagement/NewGnomeSession
-
-Startup
--------
-
-main() creates the GsmSession object representing the session (either
-failsafe or normal). gsm_session_new() reads the appropriate autostart
-and session files to create a list of GsmApps to be started.
-(GsmAppAutostart represents an autostarted app, and GsmAppResumed
-represents an app resumed from the previous saved session.)
-
-Startup is divided into 7 phases (GsmManagerPhase):
-
-    * GSM_MANAGER_PHASE_STARTUP covers gnome-session's internal
-      startup, which also includes starting gconfd and dbus-daemon (if
-      it's not already running). Gnome-session starts up those
-      explicitly because it needs them for its own purposes.
-
-    * GSM_MANAGER_PHASE_EARLY_INITIALIZATION is the first phase of
-      "normal" startup (ie, startup controlled by .desktop files
-      rather than hardcoding). It covers the possible installation of
-      files in $HOME by gnome-initial-setup and must be done before
-      other components such as gnome-keyring use those files.
-
-    * GSM_MANAGER_PHASE_INITIALIZATION covers low-level stuff like
-      gnome-settings-daemon and at-spi-registryd, that need to be
-      running very early (before any windows are displayed).
-
-      Apps in this phase can make use of a D-Bus interface
-      (org.gnome.SessionManager.Setenv) to set environment variables
-      in gnome-session's environment. This can be used for things like
-      $GTK_MODULES, $GNOME_KEYRING_SOCKET, etc
-
-    * GSM_MANAGER_PHASE_WINDOW_MANAGER includes window managers and
-      compositing managers, and anything else that has to be running
-      before any windows are mapped
-
-    * GSM_MANAGER_PHASE_PANEL includes anything that permanently takes
-      up screen real estate (via EWMH struts). This is the first phase
-      where things actually appear on the screen.
-
-    * GSM_MANAGER_PHASE_DESKTOP includes anything that draws directly
-      on the desktop (eg, nautilus).
-
-    * GSM_MANAGER_PHASE_APPLICATION is everything else (normal apps,
-      tray icons, etc)
-
-For each startup phase, GsmSession launches the appropriate GsmApps.
-When apps connect to the XSMP or D-Bus servers, GsmClients are created
-and added to the session. The session tries to map these clients to
-GsmApps. GsmApps signal when they register (via XSMP or SN) or exit,
-and GsmSession uses this to decide when the phase is complete.
-
-FIXME: after starting the session, we need to run the DiscardCommands
-of resumed apps.
-
-
-Running/Shutdown
-----------------
-
-GSM_MANAGER_PHASE_RUNNING is pretty similar to the old gnome-session;
-mostly it just tracks XSMP clients, and watches for
-SmRestartImmediately clients exiting (NOTE: THIS DOESN'T HAPPEN YET).
-
-GsmClient is in theory not XSMP-specific, but it's very very
-XSMP-like, and the shutdown procedure is also very XSMP-like. This is
-just because there's no way to do XSMP shutdown correctly otherwise.
-However, GsmClientDBus will still be able to present a more sane
-protocol to its clients than GsmClient presents to it.
diff --git a/gnome-session/gdm-log.c b/gnome-session/gdm-log.c
deleted file mode 100644
index e03d90e..0000000
--- a/gnome-session/gdm-log.c
+++ /dev/null
@@ -1,206 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2007 William Jon McCann <mccann@jhu.edu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: William Jon McCann <mccann@jhu.edu>
- *
- */
-
-#include "config.h"
-
-#include <stdio.h>
-#include <string.h>
-#include <stdarg.h>
-#include <signal.h>
-#include <time.h>
-#include <unistd.h>
-
-#include <syslog.h>
-
-#include <glib.h>
-#include <glib/gstdio.h>
-
-#include "gdm-log.h"
-
-static gboolean initialized = FALSE;
-static int      syslog_levels = (G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING);
-
-static void
-log_level_to_priority_and_prefix (GLogLevelFlags log_level,
-                                  int           *priorityp,
-                                  const char   **prefixp)
-{
-        int         priority;
-        const char *prefix;
-
-        /* Process the message prefix and priority */
-        switch (log_level & G_LOG_LEVEL_MASK) {
-        case G_LOG_FLAG_FATAL:
-                priority = LOG_EMERG;
-                prefix = "FATAL";
-                break;
-        case G_LOG_LEVEL_ERROR:
-                priority = LOG_ERR;
-                prefix = "ERROR";
-                break;
-        case G_LOG_LEVEL_CRITICAL:
-                priority = LOG_CRIT;
-                prefix = "CRITICAL";
-                break;
-        case G_LOG_LEVEL_WARNING:
-                priority = LOG_WARNING;
-                prefix = "WARNING";
-                break;
-        case G_LOG_LEVEL_MESSAGE:
-                priority = LOG_NOTICE;
-                prefix = "MESSAGE";
-                break;
-        case G_LOG_LEVEL_INFO:
-                priority = LOG_INFO;
-                prefix = "INFO";
-                break;
-        case G_LOG_LEVEL_DEBUG:
-                /* if debug was requested then bump this up to ERROR
-                 * to ensure it is seen in a log */
-                if (syslog_levels & G_LOG_LEVEL_DEBUG) {
-                        priority = LOG_WARNING;
-                        prefix = "DEBUG(+)";
-                } else {
-                        priority = LOG_DEBUG;
-                        prefix = "DEBUG";
-                }
-                break;
-        default:
-                priority = LOG_DEBUG;
-                prefix = "UNKNOWN";
-                break;
-        }
-
-        if (priorityp != NULL) {
-                *priorityp = priority;
-        }
-        if (prefixp != NULL) {
-                *prefixp = prefix;
-        }
-}
-
-void
-gdm_log_default_handler (const gchar   *log_domain,
-                         GLogLevelFlags log_level,
-                         const gchar   *message,
-                         gpointer       unused_data)
-{
-        GString     *gstring;
-        int          priority;
-        const char  *level_prefix;
-        char        *string;
-        gboolean     do_log;
-        gboolean     is_fatal;
-
-        is_fatal = (log_level & G_LOG_FLAG_FATAL) != 0;
-
-        do_log = (log_level & syslog_levels);
-        if (! do_log) {
-                return;
-        }
-
-        if (! initialized) {
-                gdm_log_init ();
-        }
-
-        log_level_to_priority_and_prefix (log_level,
-                                          &priority,
-                                          &level_prefix);
-
-        gstring = g_string_new (NULL);
-
-        if (log_domain != NULL) {
-                g_string_append (gstring, log_domain);
-                g_string_append_c (gstring, '-');
-        }
-        g_string_append (gstring, level_prefix);
-
-        g_string_append (gstring, ": ");
-        if (message == NULL) {
-                g_string_append (gstring, "(NULL) message");
-        } else {
-                g_string_append (gstring, message);
-        }
-        if (is_fatal) {
-                g_string_append (gstring, "\naborting...\n");
-        } else {
-                g_string_append (gstring, "\n");
-        }
-
-        string = g_string_free (gstring, FALSE);
-
-        syslog (priority, "%s", string);
-
-        g_free (string);
-}
-
-void
-gdm_log_toggle_debug (void)
-{
-        if (syslog_levels & G_LOG_LEVEL_DEBUG) {
-                g_debug ("Debugging disabled");
-                syslog_levels &= ~G_LOG_LEVEL_DEBUG;
-        } else {
-                syslog_levels |= G_LOG_LEVEL_DEBUG;
-                g_debug ("Debugging enabled");
-        }
-}
-
-void
-gdm_log_set_debug (gboolean debug)
-{
-        if (debug) {
-                syslog_levels |= G_LOG_LEVEL_DEBUG;
-                g_debug ("Enabling debugging");
-        } else {
-                g_debug ("Disabling debugging");
-                syslog_levels &= ~G_LOG_LEVEL_DEBUG;
-        }
-}
-
-void
-gdm_log_init (void)
-{
-        const char *prg_name;
-        int         options;
-
-        g_log_set_default_handler (gdm_log_default_handler, NULL);
-
-        prg_name = g_get_prgname ();
-
-        options = LOG_PID;
-#ifdef LOG_PERROR
-        options |= LOG_PERROR;
-#endif
-
-        openlog (prg_name, options, LOG_DAEMON);
-
-        initialized = TRUE;
-}
-
-void
-gdm_log_shutdown (void)
-{
-        closelog ();
-        initialized = FALSE;
-}
-
diff --git a/gnome-session/gdm-log.h b/gnome-session/gdm-log.h
deleted file mode 100644
index 2b52ccd..0000000
--- a/gnome-session/gdm-log.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2007 William Jon McCann <mccann@jhu.edu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Authors: William Jon McCann <mccann@jhu.edu>
- *
- */
-
-#ifndef __GDM_LOG_H
-#define __GDM_LOG_H
-
-#include <stdarg.h>
-#include <glib.h>
-
-G_BEGIN_DECLS
-
-void      gdm_log_default_handler (const gchar   *log_domain,
-                                   GLogLevelFlags log_level,
-                                   const gchar   *message,
-                                   gpointer      unused_data);
-void      gdm_log_set_debug       (gboolean       debug);
-void      gdm_log_toggle_debug    (void);
-void      gdm_log_init            (void);
-void      gdm_log_shutdown        (void);
-
-/* compatibility */
-#define   gdm_fail               g_critical
-#define   gdm_error              g_warning
-#define   gdm_info               g_message
-#define   gdm_debug              g_debug
-
-#define   gdm_assert             g_assert
-#define   gdm_assert_not_reached g_assert_not_reached
-
-G_END_DECLS
-
-#endif /* __GDM_LOG_H */
diff --git a/gnome-session/gsm-app.c b/gnome-session/gsm-app.c
deleted file mode 100644
index 7d863e7..0000000
--- a/gnome-session/gsm-app.c
+++ /dev/null
@@ -1,516 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2007 Novell, Inc.
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <glib.h>
-#include <string.h>
-
-#include "gsm-app.h"
-#include "gsm-app-glue.h"
-
-#define GSM_APP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSM_TYPE_APP, GsmAppPrivate))
-
-/* If a component crashes twice within a minute, we count that as a fatal error */
-#define _GSM_APP_RESPAWN_RATELIMIT_SECONDS 60
-
-struct _GsmAppPrivate
-{
-        char            *id;
-        char            *app_id;
-        int              phase;
-        char            *startup_id;
-        gboolean         ever_started;
-        GTimeVal         last_restart_time;
-        DBusGConnection *connection;
-};
-
-
-enum {
-        EXITED,
-        DIED,
-        REGISTERED,
-        LAST_SIGNAL
-};
-
-static guint32 app_serial = 1;
-
-static guint signals[LAST_SIGNAL] = { 0 };
-
-enum {
-        PROP_0,
-        PROP_ID,
-        PROP_STARTUP_ID,
-        PROP_PHASE,
-        LAST_PROP
-};
-
-G_DEFINE_TYPE (GsmApp, gsm_app, G_TYPE_OBJECT)
-
-GQuark
-gsm_app_error_quark (void)
-{
-        static GQuark ret = 0;
-        if (ret == 0) {
-                ret = g_quark_from_static_string ("gsm_app_error");
-        }
-
-        return ret;
-
-}
-
-static guint32
-get_next_app_serial (void)
-{
-        guint32 serial;
-
-        serial = app_serial++;
-
-        if ((gint32)app_serial < 0) {
-                app_serial = 1;
-        }
-
-        return serial;
-}
-
-static gboolean
-register_app (GsmApp *app)
-{
-        GError *error;
-
-        error = NULL;
-        app->priv->connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
-        if (app->priv->connection == NULL) {
-                if (error != NULL) {
-                        g_critical ("error getting session bus: %s", error->message);
-                        g_error_free (error);
-                }
-                return FALSE;
-        }
-
-        dbus_g_connection_register_g_object (app->priv->connection, app->priv->id, G_OBJECT (app));
-
-        return TRUE;
-}
-
-static GObject *
-gsm_app_constructor (GType                  type,
-                     guint                  n_construct_properties,
-                     GObjectConstructParam *construct_properties)
-{
-        GsmApp    *app;
-        gboolean   res;
-
-        app = GSM_APP (G_OBJECT_CLASS (gsm_app_parent_class)->constructor (type,
-                                                                           n_construct_properties,
-                                                                           construct_properties));
-
-        g_free (app->priv->id);
-        app->priv->id = g_strdup_printf ("/org/gnome/SessionManager/App%u", get_next_app_serial ());
-
-        res = register_app (app);
-        if (! res) {
-                g_warning ("Unable to register app with session bus");
-        }
-
-        return G_OBJECT (app);
-}
-
-static void
-gsm_app_init (GsmApp *app)
-{
-        app->priv = GSM_APP_GET_PRIVATE (app);
-}
-
-static void
-gsm_app_set_phase (GsmApp *app,
-                   int     phase)
-{
-        g_return_if_fail (GSM_IS_APP (app));
-
-        app->priv->phase = phase;
-}
-
-static void
-gsm_app_set_id (GsmApp     *app,
-                const char *id)
-{
-        g_return_if_fail (GSM_IS_APP (app));
-
-        g_free (app->priv->id);
-
-        app->priv->id = g_strdup (id);
-        g_object_notify (G_OBJECT (app), "id");
-
-}
-static void
-gsm_app_set_startup_id (GsmApp     *app,
-                        const char *startup_id)
-{
-        g_return_if_fail (GSM_IS_APP (app));
-
-        g_free (app->priv->startup_id);
-
-        app->priv->startup_id = g_strdup (startup_id);
-        g_object_notify (G_OBJECT (app), "startup-id");
-
-}
-
-static void
-gsm_app_set_property (GObject      *object,
-                      guint         prop_id,
-                      const GValue *value,
-                      GParamSpec   *pspec)
-{
-        GsmApp *app = GSM_APP (object);
-
-        switch (prop_id) {
-        case PROP_STARTUP_ID:
-                gsm_app_set_startup_id (app, g_value_get_string (value));
-                break;
-        case PROP_ID:
-                gsm_app_set_id (app, g_value_get_string (value));
-                break;
-        case PROP_PHASE:
-                gsm_app_set_phase (app, g_value_get_int (value));
-                break;
-        default:
-                break;
-        }
-}
-
-static void
-gsm_app_get_property (GObject    *object,
-                      guint       prop_id,
-                      GValue     *value,
-                      GParamSpec *pspec)
-{
-        GsmApp *app = GSM_APP (object);
-
-        switch (prop_id) {
-        case PROP_STARTUP_ID:
-                g_value_set_string (value, app->priv->startup_id);
-                break;
-        case PROP_ID:
-                g_value_set_string (value, app->priv->id);
-                break;
-        case PROP_PHASE:
-                g_value_set_int (value, app->priv->phase);
-                break;
-        default:
-                break;
-        }
-}
-
-static void
-gsm_app_dispose (GObject *object)
-{
-        GsmApp *app = GSM_APP (object);
-
-        g_free (app->priv->startup_id);
-        app->priv->startup_id = NULL;
-
-        g_free (app->priv->id);
-        app->priv->id = NULL;
-
-        G_OBJECT_CLASS (gsm_app_parent_class)->dispose (object);
-}
-
-static void
-gsm_app_class_init (GsmAppClass *klass)
-{
-        GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-        object_class->set_property = gsm_app_set_property;
-        object_class->get_property = gsm_app_get_property;
-        object_class->dispose = gsm_app_dispose;
-        object_class->constructor = gsm_app_constructor;
-
-        klass->impl_start = NULL;
-        klass->impl_get_app_id = NULL;
-        klass->impl_get_autorestart = NULL;
-        klass->impl_provides = NULL;
-        klass->impl_get_provides = NULL;
-        klass->impl_is_running = NULL;
-
-        g_object_class_install_property (object_class,
-                                         PROP_PHASE,
-                                         g_param_spec_int ("phase",
-                                                           "Phase",
-                                                           "Phase",
-                                                           -1,
-                                                           G_MAXINT,
-                                                           -1,
-                                                           G_PARAM_READWRITE));
-        g_object_class_install_property (object_class,
-                                         PROP_ID,
-                                         g_param_spec_string ("id",
-                                                              "ID",
-                                                              "ID",
-                                                              NULL,
-                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-        g_object_class_install_property (object_class,
-                                         PROP_STARTUP_ID,
-                                         g_param_spec_string ("startup-id",
-                                                              "startup ID",
-                                                              "Session management startup ID",
-                                                              NULL,
-                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-
-        signals[EXITED] =
-                g_signal_new ("exited",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmAppClass, exited),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE,
-                              1, G_TYPE_UCHAR);
-        signals[DIED] =
-                g_signal_new ("died",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmAppClass, died),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE,
-                              1, G_TYPE_INT);
-
-        signals[REGISTERED] =
-                g_signal_new ("registered",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmAppClass, registered),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE,
-                              0);
-
-        g_type_class_add_private (klass, sizeof (GsmAppPrivate));
-        dbus_g_object_type_install_info (GSM_TYPE_APP, &dbus_glib_gsm_app_object_info);
-}
-
-const char *
-gsm_app_peek_id (GsmApp *app)
-{
-        return app->priv->id;
-}
-
-const char *
-gsm_app_peek_app_id (GsmApp *app)
-{
-        return GSM_APP_GET_CLASS (app)->impl_get_app_id (app);
-}
-
-const char *
-gsm_app_peek_startup_id (GsmApp *app)
-{
-        return app->priv->startup_id;
-}
-
-/**
- * gsm_app_peek_phase:
- * @app: a %GsmApp
- *
- * Returns @app's startup phase.
- *
- * Return value: @app's startup phase
- **/
-GsmManagerPhase
-gsm_app_peek_phase (GsmApp *app)
-{
-        g_return_val_if_fail (GSM_IS_APP (app), GSM_MANAGER_PHASE_APPLICATION);
-
-        return app->priv->phase;
-}
-
-gboolean
-gsm_app_peek_is_disabled (GsmApp *app)
-{
-        g_return_val_if_fail (GSM_IS_APP (app), FALSE);
-
-        if (GSM_APP_GET_CLASS (app)->impl_is_disabled) {
-                return GSM_APP_GET_CLASS (app)->impl_is_disabled (app);
-        } else {
-                return FALSE;
-        }
-}
-
-gboolean
-gsm_app_peek_is_conditionally_disabled (GsmApp *app)
-{
-        g_return_val_if_fail (GSM_IS_APP (app), FALSE);
-
-        if (GSM_APP_GET_CLASS (app)->impl_is_conditionally_disabled) {
-                return GSM_APP_GET_CLASS (app)->impl_is_conditionally_disabled (app);
-        } else {
-                return FALSE;
-        }
-}
-
-gboolean
-gsm_app_is_running (GsmApp *app)
-{
-        g_return_val_if_fail (GSM_IS_APP (app), FALSE);
-
-        if (GSM_APP_GET_CLASS (app)->impl_is_running) {
-                return GSM_APP_GET_CLASS (app)->impl_is_running (app);
-        } else {
-                return FALSE;
-        }
-}
-
-gboolean
-gsm_app_peek_autorestart (GsmApp *app)
-{
-        g_return_val_if_fail (GSM_IS_APP (app), FALSE);
-
-        if (GSM_APP_GET_CLASS (app)->impl_get_autorestart) {
-                return GSM_APP_GET_CLASS (app)->impl_get_autorestart (app);
-        } else {
-                return FALSE;
-        }
-}
-
-gboolean
-gsm_app_provides (GsmApp *app, const char *service)
-{
-        if (GSM_APP_GET_CLASS (app)->impl_provides) {
-                return GSM_APP_GET_CLASS (app)->impl_provides (app, service);
-        } else {
-                return FALSE;
-        }
-}
-
-char **
-gsm_app_get_provides (GsmApp *app)
-{
-        if (GSM_APP_GET_CLASS (app)->impl_get_provides) {
-                return GSM_APP_GET_CLASS (app)->impl_get_provides (app);
-        } else {
-                return NULL;
-        }
-}
-
-gboolean
-gsm_app_has_autostart_condition (GsmApp     *app,
-                                 const char *condition)
-{
-
-        if (GSM_APP_GET_CLASS (app)->impl_has_autostart_condition) {
-                return GSM_APP_GET_CLASS (app)->impl_has_autostart_condition (app, condition);
-        } else {
-                return FALSE;
-        }
-}
-
-gboolean
-gsm_app_start (GsmApp  *app,
-               GError **error)
-{
-        g_debug ("Starting app: %s", app->priv->id);
-        return GSM_APP_GET_CLASS (app)->impl_start (app, error);
-}
-
-gboolean
-gsm_app_restart (GsmApp  *app,
-                 GError **error)
-{
-        GTimeVal current_time;
-        g_debug ("Re-starting app: %s", app->priv->id);
-
-        g_get_current_time (&current_time);
-        if (app->priv->last_restart_time.tv_sec > 0
-            && (current_time.tv_sec - app->priv->last_restart_time.tv_sec) < _GSM_APP_RESPAWN_RATELIMIT_SECONDS) {
-                g_warning ("App '%s' respawning too quickly", gsm_app_peek_app_id (app));
-                g_set_error (error,
-                             GSM_APP_ERROR,
-                             GSM_APP_ERROR_RESTART_LIMIT,
-                             "Component '%s' crashing too quickly",
-                             gsm_app_peek_app_id (app));
-                return FALSE;
-        }
-        app->priv->last_restart_time = current_time;
-
-        return GSM_APP_GET_CLASS (app)->impl_restart (app, error);
-}
-
-gboolean
-gsm_app_stop (GsmApp  *app,
-              GError **error)
-{
-        return GSM_APP_GET_CLASS (app)->impl_stop (app, error);
-}
-
-void
-gsm_app_registered (GsmApp *app)
-{
-        g_return_if_fail (GSM_IS_APP (app));
-
-        g_signal_emit (app, signals[REGISTERED], 0);
-}
-
-void
-gsm_app_exited (GsmApp *app,
-                guchar  exit_code)
-{
-        g_return_if_fail (GSM_IS_APP (app));
-
-        g_signal_emit (app, signals[EXITED], 0, exit_code);
-}
-
-void
-gsm_app_died (GsmApp *app,
-              int     signal)
-{
-        g_return_if_fail (GSM_IS_APP (app));
-
-        g_signal_emit (app, signals[DIED], 0, signal);
-}
-
-gboolean
-gsm_app_get_app_id (GsmApp     *app,
-                    char      **id,
-                    GError    **error)
-{
-        g_return_val_if_fail (GSM_IS_APP (app), FALSE);
-        *id = g_strdup (GSM_APP_GET_CLASS (app)->impl_get_app_id (app));
-        return TRUE;
-}
-
-gboolean
-gsm_app_get_startup_id (GsmApp     *app,
-                        char      **id,
-                        GError    **error)
-{
-        g_return_val_if_fail (GSM_IS_APP (app), FALSE);
-        *id = g_strdup (app->priv->startup_id);
-        return TRUE;
-}
-
-gboolean
-gsm_app_get_phase (GsmApp     *app,
-                   guint      *phase,
-                   GError    **error)
-{
-        g_return_val_if_fail (GSM_IS_APP (app), FALSE);
-        *phase = app->priv->phase;
-        return TRUE;
-}
diff --git a/gnome-session/gsm-app.h b/gnome-session/gsm-app.h
deleted file mode 100644
index 41e5ccf..0000000
--- a/gnome-session/gsm-app.h
+++ /dev/null
@@ -1,138 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2007 Novell, Inc.
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#ifndef __GSM_APP_H__
-#define __GSM_APP_H__
-
-#include <glib-object.h>
-#include <sys/types.h>
-
-
-#include "gsm-manager.h"
-#include "gsm-client.h"
-
-G_BEGIN_DECLS
-
-#define GSM_TYPE_APP            (gsm_app_get_type ())
-#define GSM_APP(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSM_TYPE_APP, GsmApp))
-#define GSM_APP_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GSM_TYPE_APP, GsmAppClass))
-#define GSM_IS_APP(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSM_TYPE_APP))
-#define GSM_IS_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GSM_TYPE_APP))
-#define GSM_APP_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GSM_TYPE_APP, GsmAppClass))
-
-typedef struct _GsmApp        GsmApp;
-typedef struct _GsmAppClass   GsmAppClass;
-typedef struct _GsmAppPrivate GsmAppPrivate;
-
-struct _GsmApp
-{
-        GObject        parent;
-        GsmAppPrivate *priv;
-};
-
-struct _GsmAppClass
-{
-        GObjectClass parent_class;
-
-        /* signals */
-        void        (*exited)       (GsmApp *app,
-                                     guchar  exit_code);
-        void        (*died)         (GsmApp *app,
-                                     int     signal);
-        void        (*registered)   (GsmApp *app);
-
-        /* virtual methods */
-        gboolean    (*impl_start)                     (GsmApp     *app,
-                                                       GError    **error);
-        gboolean    (*impl_restart)                   (GsmApp     *app,
-                                                       GError    **error);
-        gboolean    (*impl_stop)                      (GsmApp     *app,
-                                                       GError    **error);
-        gboolean    (*impl_provides)                  (GsmApp     *app,
-                                                       const char *service);
-        char **     (*impl_get_provides)              (GsmApp     *app);
-        gboolean    (*impl_has_autostart_condition)   (GsmApp     *app,
-                                                       const char *service);
-        gboolean    (*impl_is_running)                (GsmApp     *app);
-
-        gboolean    (*impl_get_autorestart)           (GsmApp     *app);
-        const char *(*impl_get_app_id)                (GsmApp     *app);
-        gboolean    (*impl_is_disabled)               (GsmApp     *app);
-        gboolean    (*impl_is_conditionally_disabled) (GsmApp     *app);
-};
-
-typedef enum
-{
-        GSM_APP_ERROR_GENERAL = 0,
-        GSM_APP_ERROR_RESTART_LIMIT,
-        GSM_APP_ERROR_START,
-        GSM_APP_ERROR_STOP,
-        GSM_APP_NUM_ERRORS
-} GsmAppError;
-
-#define GSM_APP_ERROR gsm_app_error_quark ()
-
-GQuark           gsm_app_error_quark                    (void);
-GType            gsm_app_get_type                       (void) G_GNUC_CONST;
-
-gboolean         gsm_app_peek_autorestart               (GsmApp     *app);
-
-const char      *gsm_app_peek_id                        (GsmApp     *app);
-const char      *gsm_app_peek_app_id                    (GsmApp     *app);
-const char      *gsm_app_peek_startup_id                (GsmApp     *app);
-GsmManagerPhase  gsm_app_peek_phase                     (GsmApp     *app);
-gboolean         gsm_app_peek_is_disabled               (GsmApp     *app);
-gboolean         gsm_app_peek_is_conditionally_disabled (GsmApp     *app);
-
-gboolean         gsm_app_start                          (GsmApp     *app,
-                                                         GError    **error);
-gboolean         gsm_app_restart                        (GsmApp     *app,
-                                                         GError    **error);
-gboolean         gsm_app_stop                           (GsmApp     *app,
-                                                         GError    **error);
-gboolean         gsm_app_is_running                     (GsmApp     *app);
-
-void             gsm_app_exited                         (GsmApp     *app,
-                                                         guchar      exit_code);
-void             gsm_app_died                           (GsmApp     *app,
-                                                         int         signal);
-
-gboolean         gsm_app_provides                       (GsmApp     *app,
-                                                         const char *service);
-char           **gsm_app_get_provides                   (GsmApp     *app);
-gboolean         gsm_app_has_autostart_condition        (GsmApp     *app,
-                                                         const char *condition);
-void             gsm_app_registered                     (GsmApp     *app);
-
-/* exported to bus */
-gboolean         gsm_app_get_app_id                     (GsmApp     *app,
-                                                         char      **id,
-                                                         GError    **error);
-gboolean         gsm_app_get_startup_id                 (GsmApp     *app,
-                                                         char      **id,
-                                                         GError    **error);
-gboolean         gsm_app_get_phase                      (GsmApp     *app,
-                                                         guint      *phase,
-                                                         GError    **error);
-
-G_END_DECLS
-
-#endif /* __GSM_APP_H__ */
diff --git a/gnome-session/gsm-autostart-app.c b/gnome-session/gsm-autostart-app.c
deleted file mode 100644
index a1109f7..0000000
--- a/gnome-session/gsm-autostart-app.c
+++ /dev/null
@@ -1,1443 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2007 Novell, Inc.
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#include <config.h>
-
-#include <ctype.h>
-#include <string.h>
-#include <sys/wait.h>
-#include <errno.h>
-
-#include <glib.h>
-#include <gio/gio.h>
-#include <gio/gdesktopappinfo.h>
-
-#ifdef HAVE_GCONF
-#include <gconf/gconf-client.h>
-#endif
-
-#include "gsm-autostart-app.h"
-#include "gsm-util.h"
-
-enum {
-        AUTOSTART_LAUNCH_SPAWN = 0,
-        AUTOSTART_LAUNCH_ACTIVATE
-};
-
-enum {
-        GSM_CONDITION_NONE           = 0,
-        GSM_CONDITION_IF_EXISTS      = 1,
-        GSM_CONDITION_UNLESS_EXISTS  = 2,
-#ifdef HAVE_GCONF
-        GSM_CONDITION_GNOME          = 3,
-#endif
-        GSM_CONDITION_GSETTINGS      = 4,
-        GSM_CONDITION_IF_SESSION     = 5,
-        GSM_CONDITION_UNLESS_SESSION = 6,
-        GSM_CONDITION_UNKNOWN        = 7
-};
-
-#define GSM_SESSION_CLIENT_DBUS_INTERFACE "org.gnome.SessionClient"
-
-struct _GsmAutostartAppPrivate {
-        char                 *desktop_filename;
-        char                 *desktop_id;
-        char                 *startup_id;
-
-        GDesktopAppInfo      *app_info;
-        /* provides defined in session definition */
-        GSList               *session_provides;
-
-        /* desktop file state */
-        char                 *condition_string;
-        gboolean              condition;
-        gboolean              autorestart;
-
-        GFileMonitor         *condition_monitor;
-        guint                 condition_notify_id;
-        GSettings            *condition_settings;
-
-        int                   launch_type;
-        GPid                  pid;
-        guint                 child_watch_id;
-
-        DBusGProxy           *proxy;
-        DBusGProxyCall       *proxy_call;
-};
-
-enum {
-        CONDITION_CHANGED,
-        LAST_SIGNAL
-};
-
-enum {
-        PROP_0,
-        PROP_DESKTOP_FILENAME
-};
-
-static guint signals[LAST_SIGNAL] = { 0 };
-
-#define GSM_AUTOSTART_APP_GET_PRIVATE(object) (G_TYPE_INSTANCE_GET_PRIVATE ((object), GSM_TYPE_AUTOSTART_APP, GsmAutostartAppPrivate))
-
-static void gsm_autostart_app_initable_iface_init (GInitableIface  *iface);
-
-G_DEFINE_TYPE_WITH_CODE (GsmAutostartApp, gsm_autostart_app, GSM_TYPE_APP,
-                         G_IMPLEMENT_INTERFACE (G_TYPE_INITABLE, gsm_autostart_app_initable_iface_init))
-
-static void
-gsm_autostart_app_init (GsmAutostartApp *app)
-{
-        app->priv = GSM_AUTOSTART_APP_GET_PRIVATE (app);
-
-        app->priv->pid = -1;
-        app->priv->condition_monitor = NULL;
-        app->priv->condition = FALSE;
-}
-
-static gboolean
-is_disabled (GsmApp *app)
-{
-        GsmAutostartAppPrivate *priv;
-        const char *current_desktop;
-
-        priv = GSM_AUTOSTART_APP (app)->priv;
-
-        /* GSM_AUTOSTART_APP_ENABLED_KEY key, used by old gnome-session */
-        if (g_desktop_app_info_has_key (priv->app_info,
-                                        GSM_AUTOSTART_APP_ENABLED_KEY) &&
-            !g_desktop_app_info_get_boolean (priv->app_info,
-                                             GSM_AUTOSTART_APP_ENABLED_KEY)) {
-                g_debug ("app %s is disabled by " GSM_AUTOSTART_APP_ENABLED_KEY,
-                         gsm_app_peek_id (app));
-                return TRUE;
-        }
-
-        /* Hidden key, used by autostart spec */
-        if (g_desktop_app_info_get_is_hidden (priv->app_info)) {
-                g_debug ("app %s is disabled by Hidden",
-                         gsm_app_peek_id (app));
-                return TRUE;
-        }
-
-        /* Check OnlyShowIn/NotShowIn/TryExec */
-        current_desktop = gsm_util_get_current_desktop ();
-        g_desktop_app_info_set_desktop_env (current_desktop);
-        if (current_desktop != NULL &&
-            !g_desktop_app_info_get_show_in (G_DESKTOP_APP_INFO (priv->app_info),
-                                             current_desktop)) {
-                        g_debug ("app %s not for %s",
-                                 gsm_app_peek_id (app), current_desktop);
-                return TRUE;
-        }
-
-        /* Do not check AutostartCondition - this method is only to determine
-         if the app is unconditionally disabled */
-
-        return FALSE;
-}
-
-static gboolean
-parse_condition_string (const char *condition_string,
-                        guint      *condition_kindp,
-                        char      **keyp)
-{
-        const char *space;
-        const char *key;
-        int         len;
-        guint       kind;
-
-        space = condition_string + strcspn (condition_string, " ");
-        len = space - condition_string;
-        key = space;
-        while (isspace ((unsigned char)*key)) {
-                key++;
-        }
-
-        kind = GSM_CONDITION_UNKNOWN;
-
-        if (!g_ascii_strncasecmp (condition_string, "if-exists", len) && key) {
-                kind = GSM_CONDITION_IF_EXISTS;
-        } else if (!g_ascii_strncasecmp (condition_string, "unless-exists", len) && key) {
-                kind = GSM_CONDITION_UNLESS_EXISTS;
-#ifdef HAVE_GCONF
-        } else if (!g_ascii_strncasecmp (condition_string, "GNOME", len)) {
-                kind = GSM_CONDITION_GNOME;
-#endif
-        } else if (!g_ascii_strncasecmp (condition_string, "GSettings", len)) {
-                kind = GSM_CONDITION_GSETTINGS;
-        } else if (!g_ascii_strncasecmp (condition_string, "GNOME3", len)) {
-                condition_string = key;
-                space = condition_string + strcspn (condition_string, " ");
-                len = space - condition_string;
-                key = space;
-                while (isspace ((unsigned char)*key)) {
-                        key++;
-                }
-                if (!g_ascii_strncasecmp (condition_string, "if-session", len) && key) {
-                        kind = GSM_CONDITION_IF_SESSION;
-                } else if (!g_ascii_strncasecmp (condition_string, "unless-session", len) && key) {
-                        kind = GSM_CONDITION_UNLESS_SESSION;
-                }
-        }
-
-        if (kind == GSM_CONDITION_UNKNOWN) {
-                key = NULL;
-        }
-
-        if (keyp != NULL) {
-                *keyp = g_strdup (key);
-        }
-
-        if (condition_kindp != NULL) {
-                *condition_kindp = kind;
-        }
-
-        return (kind != GSM_CONDITION_UNKNOWN);
-}
-
-static void
-if_exists_condition_cb (GFileMonitor     *monitor,
-                        GFile            *file,
-                        GFile            *other_file,
-                        GFileMonitorEvent event,
-                        GsmApp           *app)
-{
-        GsmAutostartAppPrivate *priv;
-        gboolean                condition = FALSE;
-
-        priv = GSM_AUTOSTART_APP (app)->priv;
-
-        switch (event) {
-        case G_FILE_MONITOR_EVENT_CREATED:
-                condition = TRUE;
-                break;
-        case G_FILE_MONITOR_EVENT_DELETED:
-                condition = FALSE;
-                break;
-        default:
-                /* Ignore any other monitor event */
-                return;
-        }
-
-        /* Emit only if the condition actually changed */
-        if (condition != priv->condition) {
-                priv->condition = condition;
-                g_signal_emit (app, signals[CONDITION_CHANGED], 0, condition);
-        }
-}
-
-static void
-unless_exists_condition_cb (GFileMonitor     *monitor,
-                            GFile            *file,
-                            GFile            *other_file,
-                            GFileMonitorEvent event,
-                            GsmApp           *app)
-{
-        GsmAutostartAppPrivate *priv;
-        gboolean                condition = FALSE;
-
-        priv = GSM_AUTOSTART_APP (app)->priv;
-
-        switch (event) {
-        case G_FILE_MONITOR_EVENT_CREATED:
-                condition = FALSE;
-                break;
-        case G_FILE_MONITOR_EVENT_DELETED:
-                condition = TRUE;
-                break;
-        default:
-                /* Ignore any other monitor event */
-                return;
-        }
-
-        /* Emit only if the condition actually changed */
-        if (condition != priv->condition) {
-                priv->condition = condition;
-                g_signal_emit (app, signals[CONDITION_CHANGED], 0, condition);
-        }
-}
-
-#ifdef HAVE_GCONF
-static void
-gconf_condition_cb (GConfClient *client,
-                    guint        cnxn_id,
-                    GConfEntry  *entry,
-                    gpointer     user_data)
-{
-        GsmApp                 *app;
-        GsmAutostartAppPrivate *priv;
-        gboolean                condition;
-
-        g_return_if_fail (GSM_IS_APP (user_data));
-
-        app = GSM_APP (user_data);
-
-        priv = GSM_AUTOSTART_APP (app)->priv;
-
-        condition = FALSE;
-        if (entry->value != NULL && entry->value->type == GCONF_VALUE_BOOL) {
-                condition = gconf_value_get_bool (entry->value);
-        }
-
-        g_debug ("GsmAutostartApp: app:%s condition changed condition:%d",
-                 gsm_app_peek_id (app),
-                 condition);
-
-        /* Emit only if the condition actually changed */
-        if (condition != priv->condition) {
-                priv->condition = condition;
-                g_signal_emit (app, signals[CONDITION_CHANGED], 0, condition);
-        }
-}
-#endif
-
-static void
-gsettings_condition_cb (GSettings  *settings,
-                        const char *key,
-                        gpointer    user_data)
-{
-        GsmApp                 *app;
-        GsmAutostartAppPrivate *priv;
-        gboolean                condition;
-
-        g_return_if_fail (GSM_IS_APP (user_data));
-
-        app = GSM_APP (user_data);
-
-        priv = GSM_AUTOSTART_APP (app)->priv;
-
-        condition = g_settings_get_boolean (settings, key);
-
-        g_debug ("GsmAutostartApp: app:%s condition changed condition:%d",
-                 gsm_app_peek_id (app),
-                 condition);
-
-        /* Emit only if the condition actually changed */
-        if (condition != priv->condition) {
-                priv->condition = condition;
-                g_signal_emit (app, signals[CONDITION_CHANGED], 0, condition);
-        }
-}
-
-static gboolean
-setup_gsettings_condition_monitor (GsmAutostartApp *app,
-                                   const char      *key)
-{
-        GSettings *settings;
-        const char * const *schemas;
-        char **elems;
-        gboolean schema_exists;
-        guint i;
-        gboolean retval;
-        char *signal;
-
-        elems = g_strsplit (key, " ", 2);
-        if (elems == NULL)
-                return FALSE;
-        if (elems[0] == NULL || elems[1] == NULL) {
-                g_strfreev (elems);
-                return FALSE;
-        }
-
-        schemas = g_settings_list_schemas ();
-        schema_exists = FALSE;
-        for (i = 0; schemas[i] != NULL; i++) {
-                if (g_str_equal (schemas[i], elems[0])) {
-                        schema_exists = TRUE;
-                        break;
-                }
-        }
-
-        if (schema_exists == FALSE)
-                return FALSE;
-
-        settings = g_settings_new (elems[0]);
-        retval = g_settings_get_boolean (settings, elems[1]);
-
-        signal = g_strdup_printf ("changed::%s", elems[1]);
-        g_signal_connect (G_OBJECT (settings), signal,
-                          G_CALLBACK (gsettings_condition_cb), app);
-        g_free (signal);
-
-        app->priv->condition_settings = settings;
-
-        g_strfreev (elems);
-
-        return retval;
-}
-
-static void
-if_session_condition_cb (GObject    *object,
-                         GParamSpec *pspec,
-                         gpointer    user_data)
-{
-        GsmApp                 *app;
-        GsmAutostartAppPrivate *priv;
-        char                   *session_name;
-        char                   *key;
-        gboolean                condition;
-
-        g_return_if_fail (GSM_IS_APP (user_data));
-
-        app = GSM_APP (user_data);
-
-        priv = GSM_AUTOSTART_APP (app)->priv;
-
-        parse_condition_string (priv->condition_string, NULL, &key);
-
-        g_object_get (object, "session-name", &session_name, NULL);
-        condition = strcmp (session_name, key) == 0;
-        g_free (session_name);
-
-        g_free (key);
-
-        g_debug ("GsmAutostartApp: app:%s condition changed condition:%d",
-                 gsm_app_peek_id (app),
-                 condition);
-
-        /* Emit only if the condition actually changed */
-        if (condition != priv->condition) {
-                priv->condition = condition;
-                g_signal_emit (app, signals[CONDITION_CHANGED], 0, condition);
-        }
-}
-
-static void
-unless_session_condition_cb (GObject    *object,
-                             GParamSpec *pspec,
-                             gpointer    user_data)
-{
-        GsmApp                 *app;
-        GsmAutostartAppPrivate *priv;
-        char                   *session_name;
-        char                   *key;
-        gboolean                condition;
-
-        g_return_if_fail (GSM_IS_APP (user_data));
-
-        app = GSM_APP (user_data);
-
-        priv = GSM_AUTOSTART_APP (app)->priv;
-
-        parse_condition_string (priv->condition_string, NULL, &key);
-
-        g_object_get (object, "session-name", &session_name, NULL);
-        condition = strcmp (session_name, key) != 0;
-        g_free (session_name);
-
-        g_free (key);
-
-        g_debug ("GsmAutostartApp: app:%s condition changed condition:%d",
-                 gsm_app_peek_id (app),
-                 condition);
-
-        /* Emit only if the condition actually changed */
-        if (condition != priv->condition) {
-                priv->condition = condition;
-                g_signal_emit (app, signals[CONDITION_CHANGED], 0, condition);
-        }
-}
-
-static void
-setup_condition_monitor (GsmAutostartApp *app)
-{
-        guint    kind;
-        char    *key;
-        gboolean res;
-        gboolean disabled;
-
-        if (app->priv->condition_monitor != NULL) {
-                g_file_monitor_cancel (app->priv->condition_monitor);
-        }
-
-#ifdef HAVE_GCONF
-        if (app->priv->condition_notify_id > 0) {
-                GConfClient *client;
-                client = gconf_client_get_default ();
-                gconf_client_notify_remove (client,
-                                            app->priv->condition_notify_id);
-                app->priv->condition_notify_id = 0;
-        }
-#endif
-
-        if (app->priv->condition_string == NULL) {
-                return;
-        }
-
-        /* if it is disabled outright there is no point in monitoring */
-        if (is_disabled (GSM_APP (app))) {
-                return;
-        }
-
-        key = NULL;
-        res = parse_condition_string (app->priv->condition_string, &kind, &key);
-        if (! res) {
-                g_free (key);
-                return;
-        }
-
-        if (key == NULL) {
-                return;
-        }
-
-        if (kind == GSM_CONDITION_IF_EXISTS) {
-                char  *file_path;
-                GFile *file;
-
-                file_path = g_build_filename (g_get_user_config_dir (), key, NULL);
-
-                disabled = !g_file_test (file_path, G_FILE_TEST_EXISTS);
-
-                file = g_file_new_for_path (file_path);
-                app->priv->condition_monitor = g_file_monitor_file (file, 0, NULL, NULL);
-
-                g_signal_connect (app->priv->condition_monitor, "changed",
-                                  G_CALLBACK (if_exists_condition_cb),
-                                  app);
-
-                g_object_unref (file);
-                g_free (file_path);
-        } else if (kind == GSM_CONDITION_UNLESS_EXISTS) {
-                char  *file_path;
-                GFile *file;
-
-                file_path = g_build_filename (g_get_user_config_dir (), key, NULL);
-
-                disabled = g_file_test (file_path, G_FILE_TEST_EXISTS);
-
-                file = g_file_new_for_path (file_path);
-                app->priv->condition_monitor = g_file_monitor_file (file, 0, NULL, NULL);
-
-                g_signal_connect (app->priv->condition_monitor, "changed",
-                                  G_CALLBACK (unless_exists_condition_cb),
-                                  app);
-
-                g_object_unref (file);
-                g_free (file_path);
-#ifdef HAVE_GCONF
-        } else if (kind == GSM_CONDITION_GNOME) {
-                GConfClient *client;
-                char        *dir;
-
-                client = gconf_client_get_default ();
-                g_assert (GCONF_IS_CLIENT (client));
-
-                disabled = !gconf_client_get_bool (client, key, NULL);
-
-                dir = g_path_get_dirname (key);
-
-                gconf_client_add_dir (client,
-                                      dir,
-                                      GCONF_CLIENT_PRELOAD_NONE, NULL);
-                g_free (dir);
-
-                app->priv->condition_notify_id = gconf_client_notify_add (client,
-                                                                          key,
-                                                                          gconf_condition_cb,
-                                                                          app, NULL, NULL);
-                g_object_unref (client);
-#endif
-        } else if (kind == GSM_CONDITION_GSETTINGS) {
-                disabled = !setup_gsettings_condition_monitor (app, key);
-        } else if (kind == GSM_CONDITION_IF_SESSION) {
-                GsmManager *manager;
-                char *session_name;
-
-                /* get the singleton */
-                manager = gsm_manager_get ();
-
-                g_object_get (manager, "session-name", &session_name, NULL);
-                disabled = strcmp (session_name, key) != 0;
-
-                g_signal_connect (manager, "notify::session-name",
-                                  G_CALLBACK (if_session_condition_cb), app);
-                g_free (session_name);
-        } else if (kind == GSM_CONDITION_UNLESS_SESSION) {
-                GsmManager *manager;
-                char *session_name;
-
-                /* get the singleton */
-                manager = gsm_manager_get ();
-
-                g_object_get (manager, "session-name", &session_name, NULL);
-                disabled = strcmp (session_name, key) == 0;
-
-                g_signal_connect (manager, "notify::session-name",
-                                  G_CALLBACK (unless_session_condition_cb), app);
-                g_free (session_name);
-        } else {
-                disabled = TRUE;
-        }
-
-        g_free (key);
-
-        if (disabled) {
-                /* FIXME: cache the disabled value? */
-        }
-}
-
-static void
-load_desktop_file (GsmAutostartApp  *app)
-{
-        char    *dbus_name;
-        char    *startup_id;
-        char    *phase_str;
-        int      phase;
-        gboolean res;
-
-        g_assert (app->priv->app_info != NULL);
-
-        phase_str = g_desktop_app_info_get_string (app->priv->app_info,
-                                                   GSM_AUTOSTART_APP_PHASE_KEY);
-        if (phase_str != NULL) {
-                if (strcmp (phase_str, "EarlyInitialization") == 0) {
-                        phase = GSM_MANAGER_PHASE_EARLY_INITIALIZATION;
-                } else if (strcmp (phase_str, "DisplayServer") == 0) {
-                        phase = GSM_MANAGER_PHASE_DISPLAY_SERVER;
-                } else if (strcmp (phase_str, "Initialization") == 0) {
-                        phase = GSM_MANAGER_PHASE_INITIALIZATION;
-                } else if (strcmp (phase_str, "WindowManager") == 0) {
-                        phase = GSM_MANAGER_PHASE_WINDOW_MANAGER;
-                } else if (strcmp (phase_str, "Panel") == 0) {
-                        phase = GSM_MANAGER_PHASE_PANEL;
-                } else if (strcmp (phase_str, "Desktop") == 0) {
-                        phase = GSM_MANAGER_PHASE_DESKTOP;
-                } else {
-                        phase = GSM_MANAGER_PHASE_APPLICATION;
-                }
-
-                g_free (phase_str);
-        } else {
-                phase = GSM_MANAGER_PHASE_APPLICATION;
-        }
-
-        dbus_name = g_desktop_app_info_get_string (app->priv->app_info,
-                                                   GSM_AUTOSTART_APP_DBUS_NAME_KEY);
-        if (dbus_name != NULL) {
-                app->priv->launch_type = AUTOSTART_LAUNCH_ACTIVATE;
-        } else {
-                app->priv->launch_type = AUTOSTART_LAUNCH_SPAWN;
-        }
-
-        /* this must only be done on first load */
-        switch (app->priv->launch_type) {
-        case AUTOSTART_LAUNCH_SPAWN:
-                startup_id =
-                        g_desktop_app_info_get_string (app->priv->app_info,
-                                                       GSM_AUTOSTART_APP_STARTUP_ID_KEY);
-
-                if (startup_id == NULL) {
-                        startup_id = gsm_util_generate_startup_id ();
-                }
-                break;
-        case AUTOSTART_LAUNCH_ACTIVATE:
-                startup_id = g_strdup (dbus_name);
-                break;
-        default:
-                g_assert_not_reached ();
-        }
-
-        res = g_desktop_app_info_has_key (app->priv->app_info,
-                                          GSM_AUTOSTART_APP_AUTORESTART_KEY);
-        if (res) {
-                app->priv->autorestart = g_desktop_app_info_get_boolean (app->priv->app_info,
-                                                                         GSM_AUTOSTART_APP_AUTORESTART_KEY);
-        } else {
-                app->priv->autorestart = FALSE;
-        }
-
-        g_free (app->priv->condition_string);
-        app->priv->condition_string = g_desktop_app_info_get_string (app->priv->app_info,
-                                                                   "AutostartCondition");
-        setup_condition_monitor (app);
-
-        g_object_set (app,
-                      "phase", phase,
-                      "startup-id", startup_id,
-                      NULL);
-
-        g_free (startup_id);
-        g_free (dbus_name);
-}
-
-static void
-gsm_autostart_app_set_desktop_filename (GsmAutostartApp *app,
-                                        const char      *desktop_filename)
-{
-        if (app->priv->app_info != NULL) {
-                g_clear_object (&app->priv->app_info);
-                g_clear_pointer (&app->priv->desktop_filename, g_free);
-                g_clear_pointer (&app->priv->desktop_id, g_free);
-        }
-
-        if (desktop_filename == NULL) {
-                return;
-        }
-
-        app->priv->desktop_filename = g_strdup (desktop_filename);
-        app->priv->desktop_id = g_path_get_basename (desktop_filename);
-}
-
-static void
-gsm_autostart_app_set_property (GObject      *object,
-                                guint         prop_id,
-                                const GValue *value,
-                                GParamSpec   *pspec)
-{
-        GsmAutostartApp *self;
-
-        self = GSM_AUTOSTART_APP (object);
-
-        switch (prop_id) {
-        case PROP_DESKTOP_FILENAME:
-                gsm_autostart_app_set_desktop_filename (self, g_value_get_string (value));
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_autostart_app_get_property (GObject    *object,
-                                guint       prop_id,
-                                GValue     *value,
-                                GParamSpec *pspec)
-{
-        GsmAutostartApp *self;
-
-        self = GSM_AUTOSTART_APP (object);
-
-        switch (prop_id) {
-        case PROP_DESKTOP_FILENAME:
-                if (self->priv->app_info != NULL) {
-                        g_value_set_string (value, g_desktop_app_info_get_filename (self->priv->app_info));
-                } else {
-                        g_value_set_string (value, NULL);
-                }
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_autostart_app_dispose (GObject *object)
-{
-        GsmAutostartAppPrivate *priv;
-
-        priv = GSM_AUTOSTART_APP (object)->priv;
-
-        g_clear_pointer (&priv->startup_id, g_free);
-
-        if (priv->session_provides) {
-                g_slist_free_full (priv->session_provides, g_free);
-                priv->session_provides = NULL;
-        }
-
-        g_clear_pointer (&priv->condition_string, g_free);
-        g_clear_object (&priv->condition_settings);
-        g_clear_object (&priv->app_info);
-        g_clear_pointer (&priv->desktop_filename, g_free);
-        g_clear_pointer (&priv->desktop_id, g_free);
-
-        if (priv->child_watch_id > 0) {
-                g_source_remove (priv->child_watch_id);
-                priv->child_watch_id = 0;
-        }
-
-        if (priv->proxy_call != NULL) {
-                dbus_g_proxy_cancel_call (priv->proxy, priv->proxy_call);
-                priv->proxy_call = NULL;
-        }
-
-        g_clear_object (&priv->proxy);
-
-        if (priv->condition_monitor) {
-                g_file_monitor_cancel (priv->condition_monitor);
-        }
-
-        G_OBJECT_CLASS (gsm_autostart_app_parent_class)->dispose (object);
-}
-
-static gboolean
-is_running (GsmApp *app)
-{
-        GsmAutostartAppPrivate *priv;
-        gboolean                is;
-
-        priv = GSM_AUTOSTART_APP (app)->priv;
-
-        /* is running if pid is still valid or
-         * or a client is connected
-         */
-        /* FIXME: check client */
-        is = (priv->pid != -1);
-
-        return is;
-}
-
-static gboolean
-is_conditionally_disabled (GsmApp *app)
-{
-        GsmAutostartAppPrivate *priv;
-        gboolean                res;
-        gboolean                disabled;
-        char                   *key;
-        guint                   kind;
-
-        priv = GSM_AUTOSTART_APP (app)->priv;
-
-        /* Check AutostartCondition */
-        if (priv->condition_string == NULL) {
-                return FALSE;
-        }
-
-        key = NULL;
-        res = parse_condition_string (priv->condition_string, &kind, &key);
-        if (! res) {
-                g_free (key);
-                return TRUE;
-        }
-
-        if (key == NULL) {
-                return TRUE;
-        }
-
-        if (kind == GSM_CONDITION_IF_EXISTS) {
-                char *file_path;
-
-                file_path = g_build_filename (g_get_user_config_dir (), key, NULL);
-                disabled = !g_file_test (file_path, G_FILE_TEST_EXISTS);
-                g_free (file_path);
-        } else if (kind == GSM_CONDITION_UNLESS_EXISTS) {
-                char *file_path;
-
-                file_path = g_build_filename (g_get_user_config_dir (), key, NULL);
-                disabled = g_file_test (file_path, G_FILE_TEST_EXISTS);
-                g_free (file_path);
-#ifdef HAVE_GCONF
-        } else if (kind == GSM_CONDITION_GNOME) {
-                GConfClient *client;
-                client = gconf_client_get_default ();
-                g_assert (GCONF_IS_CLIENT (client));
-                disabled = !gconf_client_get_bool (client, key, NULL);
-                g_object_unref (client);
-#endif
-        } else if (kind == GSM_CONDITION_GSETTINGS &&
-                   priv->condition_settings != NULL) {
-                char **elems;
-                elems = g_strsplit (key, " ", 2);
-                disabled = !g_settings_get_boolean (priv->condition_settings, elems[1]);
-                g_strfreev (elems);
-        } else if (kind == GSM_CONDITION_IF_SESSION) {
-                GsmManager *manager;
-                char *session_name;
-
-                /* get the singleton */
-                manager = gsm_manager_get ();
-
-                g_object_get (manager, "session-name", &session_name, NULL);
-                disabled = strcmp (session_name, key) != 0;
-                g_free (session_name);
-        } else if (kind == GSM_CONDITION_UNLESS_SESSION) {
-                GsmManager *manager;
-                char *session_name;
-
-                /* get the singleton */
-                manager = gsm_manager_get ();
-
-                g_object_get (manager, "session-name", &session_name, NULL);
-                disabled = strcmp (session_name, key) == 0;
-                g_free (session_name);
-        } else {
-                disabled = TRUE;
-        }
-
-        /* Set initial condition */
-        priv->condition = !disabled;
-
-        g_free (key);
-
-        return disabled;
-}
-
-static void
-app_exited (GPid             pid,
-            int              status,
-            GsmAutostartApp *app)
-{
-        g_debug ("GsmAutostartApp: (pid:%d) done (%s:%d)",
-                 (int) pid,
-                 WIFEXITED (status) ? "status"
-                 : WIFSIGNALED (status) ? "signal"
-                 : "unknown",
-                 WIFEXITED (status) ? WEXITSTATUS (status)
-                 : WIFSIGNALED (status) ? WTERMSIG (status)
-                 : -1);
-
-        g_spawn_close_pid (app->priv->pid);
-        app->priv->pid = -1;
-        app->priv->child_watch_id = 0;
-
-        if (WIFEXITED (status)) {
-                gsm_app_exited (GSM_APP (app), WEXITSTATUS (status));
-        } else if (WIFSIGNALED (status)) {
-                gsm_app_died (GSM_APP (app), WTERMSIG (status));
-        }
-}
-
-static int
-_signal_pid (int pid,
-             int signal)
-{
-        int status;
-
-        /* perhaps block sigchld */
-        g_debug ("GsmAutostartApp: sending signal %d to process %d", signal, pid);
-        errno = 0;
-        status = kill (pid, signal);
-
-        if (status < 0) {
-                if (errno == ESRCH) {
-                        g_warning ("Child process %d was already dead.",
-                                   (int)pid);
-                } else {
-                        g_warning ("Couldn't kill child process %d: %s",
-                                   pid,
-                                   g_strerror (errno));
-                }
-        }
-
-        /* perhaps unblock sigchld */
-
-        return status;
-}
-
-static gboolean
-autostart_app_stop_spawn (GsmAutostartApp *app,
-                          GError         **error)
-{
-        int res;
-
-        if (app->priv->pid < 1) {
-                g_set_error (error,
-                             GSM_APP_ERROR,
-                             GSM_APP_ERROR_STOP,
-                             "Not running");
-                return FALSE;
-        }
-
-        res = _signal_pid (app->priv->pid, SIGTERM);
-        if (res != 0) {
-                g_set_error (error,
-                             GSM_APP_ERROR,
-                             GSM_APP_ERROR_STOP,
-                             "Unable to stop: %s",
-                             g_strerror (errno));
-                return FALSE;
-        }
-
-        return TRUE;
-}
-
-static gboolean
-autostart_app_stop_activate (GsmAutostartApp *app,
-                             GError         **error)
-{
-        return TRUE;
-}
-
-static gboolean
-gsm_autostart_app_stop (GsmApp  *app,
-                        GError **error)
-{
-        GsmAutostartApp *aapp;
-        gboolean         ret;
-
-        aapp = GSM_AUTOSTART_APP (app);
-
-        g_return_val_if_fail (aapp->priv->app_info != NULL, FALSE);
-
-        switch (aapp->priv->launch_type) {
-        case AUTOSTART_LAUNCH_SPAWN:
-                ret = autostart_app_stop_spawn (aapp, error);
-                break;
-        case AUTOSTART_LAUNCH_ACTIVATE:
-                ret = autostart_app_stop_activate (aapp, error);
-                break;
-        default:
-                g_assert_not_reached ();
-                break;
-        }
-
-        return ret;
-}
-
-static void
-app_launched (GAppLaunchContext *ctx,
-              GAppInfo    *appinfo,
-              GVariant    *platform_data,
-              gpointer     data)
-{
-        GsmAutostartApp *app = data;
-        gint pid;
-        gchar *sn_id;
-
-        pid = 0;
-        sn_id = NULL;
-
-        g_variant_lookup (platform_data, "pid", "i", &pid);
-        g_variant_lookup (platform_data, "startup-notification-id", "s", &sn_id);
-        app->priv->pid = pid;
-        app->priv->startup_id = sn_id;
-}
-
-static gboolean
-autostart_app_start_spawn (GsmAutostartApp *app,
-                           GError         **error)
-{
-        gboolean         success;
-        GError          *local_error;
-        const char      *startup_id;
-        GAppLaunchContext *ctx;
-        guint handler;
-
-        startup_id = gsm_app_peek_startup_id (GSM_APP (app));
-        g_assert (startup_id != NULL);
-
-        g_debug ("GsmAutostartApp: starting %s: command=%s startup-id=%s", app->priv->desktop_id, g_app_info_get_commandline (G_APP_INFO (app->priv->app_info)), startup_id);
-
-        g_free (app->priv->startup_id);
-        local_error = NULL;
-        ctx = g_app_launch_context_new ();
-        g_app_launch_context_setenv (ctx, "DISPLAY", g_getenv ("DISPLAY"));
-        g_app_launch_context_setenv (ctx, "DESKTOP_AUTOSTART_ID", startup_id);
-
-        handler = g_signal_connect (ctx, "launched", G_CALLBACK (app_launched), app);
-        success = g_desktop_app_info_launch_uris_as_manager (app->priv->app_info,
-                                                             NULL,
-                                                             ctx,
-                                                             G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_SEARCH_PATH,
-                                                             NULL, NULL,
-                                                             NULL, NULL,
-                                                             &local_error);
-        g_signal_handler_disconnect (ctx, handler);
-
-        if (success) {
-                g_debug ("GsmAutostartApp: started pid:%d", app->priv->pid);
-                app->priv->child_watch_id = g_child_watch_add (app->priv->pid,
-                                                               (GChildWatchFunc)app_exited,
-                                                               app);
-        } else {
-                g_set_error (error,
-                             GSM_APP_ERROR,
-                             GSM_APP_ERROR_START,
-                             "Unable to start application: %s", local_error->message);
-                g_error_free (local_error);
-        }
-
-        return success;
-}
-
-static void
-start_notify (DBusGProxy      *proxy,
-              DBusGProxyCall  *call,
-              GsmAutostartApp *app)
-{
-        gboolean res;
-        GError  *error;
-
-        error = NULL;
-        res = dbus_g_proxy_end_call (proxy,
-                                     call,
-                                     &error,
-                                     G_TYPE_INVALID);
-        app->priv->proxy_call = NULL;
-
-        if (! res) {
-                g_warning ("GsmAutostartApp: Error starting application: %s", error->message);
-                g_error_free (error);
-        } else {
-                g_debug ("GsmAutostartApp: Started application %s", app->priv->desktop_id);
-        }
-}
-
-static gboolean
-autostart_app_start_activate (GsmAutostartApp  *app,
-                              GError          **error)
-{
-        const char      *name;
-        char            *path;
-        char            *arguments;
-        DBusGConnection *bus;
-        GError          *local_error;
-
-        local_error = NULL;
-        bus = dbus_g_bus_get (DBUS_BUS_SESSION, &local_error);
-        if (bus == NULL) {
-                if (local_error != NULL) {
-                        g_warning ("error getting session bus: %s", local_error->message);
-                }
-                g_propagate_error (error, local_error);
-                return FALSE;
-        }
-
-        name = gsm_app_peek_startup_id (GSM_APP (app));
-        g_assert (name != NULL);
-
-        path = g_desktop_app_info_get_string (app->priv->app_info,
-                                              GSM_AUTOSTART_APP_DBUS_PATH_KEY);
-        if (path == NULL) {
-                /* just pick one? */
-                path = g_strdup ("/");
-        }
-
-        arguments = g_desktop_app_info_get_string (app->priv->app_info,
-                                                   GSM_AUTOSTART_APP_DBUS_ARGS_KEY);
-
-        app->priv->proxy = dbus_g_proxy_new_for_name (bus,
-                                                      name,
-                                                      path,
-                                                      GSM_SESSION_CLIENT_DBUS_INTERFACE);
-        if (app->priv->proxy == NULL) {
-                g_set_error (error,
-                             GSM_APP_ERROR,
-                             GSM_APP_ERROR_START,
-                             "Unable to start application: unable to create proxy for client");
-                return FALSE;
-        }
-
-        app->priv->proxy_call = dbus_g_proxy_begin_call (app->priv->proxy,
-                                                         "Start",
-                                                         (DBusGProxyCallNotify)start_notify,
-                                                         app,
-                                                         NULL,
-                                                         G_TYPE_STRING, arguments,
-                                                         G_TYPE_INVALID);
-        if (app->priv->proxy_call == NULL) {
-                g_clear_object (&app->priv->proxy);
-                g_set_error (error,
-                             GSM_APP_ERROR,
-                             GSM_APP_ERROR_START,
-                             "Unable to start application: unable to call Start on client");
-                return FALSE;
-        }
-
-        return TRUE;
-}
-
-static gboolean
-gsm_autostart_app_start (GsmApp  *app,
-                         GError **error)
-{
-        GsmAutostartApp *aapp;
-        gboolean         ret;
-
-        aapp = GSM_AUTOSTART_APP (app);
-
-        g_return_val_if_fail (aapp->priv->app_info != NULL, FALSE);
-
-        switch (aapp->priv->launch_type) {
-        case AUTOSTART_LAUNCH_SPAWN:
-                ret = autostart_app_start_spawn (aapp, error);
-                break;
-        case AUTOSTART_LAUNCH_ACTIVATE:
-                ret = autostart_app_start_activate (aapp, error);
-                break;
-        default:
-                g_assert_not_reached ();
-                break;
-        }
-
-        return ret;
-}
-
-static gboolean
-gsm_autostart_app_restart (GsmApp  *app,
-                           GError **error)
-{
-        GError  *local_error;
-        gboolean res;
-
-        /* ignore stop errors - it is fine if it is already stopped */
-        local_error = NULL;
-        res = gsm_app_stop (app, &local_error);
-        if (! res) {
-                g_debug ("GsmAutostartApp: Couldn't stop app: %s", local_error->message);
-                g_error_free (local_error);
-        }
-
-        res = gsm_app_start (app, &local_error);
-        if (! res) {
-                g_propagate_error (error, local_error);
-                return FALSE;
-        }
-
-        return TRUE;
-}
-
-static gboolean
-gsm_autostart_app_provides (GsmApp     *app,
-                            const char *service)
-{
-        gchar           *provides_str;
-        char           **provides;
-        gsize            i;
-        GSList          *l;
-        GsmAutostartApp *aapp;
-
-        g_return_val_if_fail (GSM_IS_APP (app), FALSE);
-
-        aapp = GSM_AUTOSTART_APP (app);
-
-        if (aapp->priv->app_info == NULL) {
-                return FALSE;
-        }
-
-        for (l = aapp->priv->session_provides; l != NULL; l = l->next) {
-                if (!strcmp (l->data, service))
-                        return TRUE;
-        }
-
-        provides_str = g_desktop_app_info_get_string (aapp->priv->app_info,
-                                                      GSM_AUTOSTART_APP_PROVIDES_KEY);
-        if (!provides_str) {
-                return FALSE;
-        }
-        provides = g_strsplit (provides_str, ";", -1);
-        g_free (provides_str);
-
-        for (i = 0; provides[i]; i++) {
-                if (!strcmp (provides[i], service)) {
-                        g_strfreev (provides);
-                        return TRUE;
-                }
-        }
-
-        g_strfreev (provides);
-
-        return FALSE;
-}
-
-static char **
-gsm_autostart_app_get_provides (GsmApp *app)
-{
-        GsmAutostartApp  *aapp;
-        gchar            *provides_str;
-        char            **provides;
-        gsize             provides_len;
-        char            **result;
-        gsize             result_len;
-        int               i;
-        GSList           *l;
-
-        g_return_val_if_fail (GSM_IS_APP (app), NULL);
-
-        aapp = GSM_AUTOSTART_APP (app);
-
-        if (aapp->priv->app_info == NULL) {
-                return NULL;
-        }
-
-        provides_str = g_desktop_app_info_get_string (aapp->priv->app_info,
-                                                      GSM_AUTOSTART_APP_PROVIDES_KEY);
-
-        if (provides_str == NULL) {
-                return NULL;
-        }
-
-        provides = g_strsplit (provides_str, ";", -1);
-        provides_len = g_strv_length (provides);
-        g_free (provides_str);
-
-        if (!aapp->priv->session_provides) {
-                return provides;
-        }
-
-        result_len = provides_len + g_slist_length (aapp->priv->session_provides);
-        result = g_new (char *, result_len + 1); /* including last NULL */
-
-        for (i = 0; provides[i] != NULL; i++)
-                result[i] = provides[i];
-        g_free (provides);
-
-        for (l = aapp->priv->session_provides; l != NULL; l = l->next, i++)
-                result[i] = g_strdup (l->data);
-
-        result[i] = NULL;
-
-        g_assert (i == result_len);
-
-        return result;
-}
-
-void
-gsm_autostart_app_add_provides (GsmAutostartApp *aapp,
-                                const char      *provides)
-{
-        g_return_if_fail (GSM_IS_AUTOSTART_APP (aapp));
-
-        aapp->priv->session_provides = g_slist_prepend (aapp->priv->session_provides,
-                                                        g_strdup (provides));
-}
-
-static gboolean
-gsm_autostart_app_has_autostart_condition (GsmApp     *app,
-                                           const char *condition)
-{
-        GsmAutostartApp *aapp;
-
-        g_return_val_if_fail (GSM_IS_APP (app), FALSE);
-        g_return_val_if_fail (condition != NULL, FALSE);
-
-        aapp = GSM_AUTOSTART_APP (app);
-
-        if (aapp->priv->condition_string == NULL) {
-                return FALSE;
-        }
-
-        if (strcmp (aapp->priv->condition_string, condition) == 0) {
-                return TRUE;
-        }
-
-        return FALSE;
-}
-
-static gboolean
-gsm_autostart_app_get_autorestart (GsmApp *app)
-{
-        gboolean res;
-        gboolean autorestart;
-
-        if (GSM_AUTOSTART_APP (app)->priv->app_info == NULL) {
-                return FALSE;
-        }
-
-        autorestart = FALSE;
-
-        res = g_desktop_app_info_has_key (GSM_AUTOSTART_APP (app)->priv->app_info,
-                                          GSM_AUTOSTART_APP_AUTORESTART_KEY);
-        if (res) {
-                autorestart = g_desktop_app_info_get_boolean (GSM_AUTOSTART_APP (app)->priv->app_info,
-                                                              GSM_AUTOSTART_APP_AUTORESTART_KEY);
-        }
-
-        return autorestart;
-}
-
-static const char *
-gsm_autostart_app_get_app_id (GsmApp *app)
-{
-        const char *location;
-        const char *slash;
-
-        if (GSM_AUTOSTART_APP (app)->priv->app_info == NULL) {
-                return NULL;
-        }
-
-        location = g_desktop_app_info_get_filename (GSM_AUTOSTART_APP (app)->priv->app_info);
-
-        slash = strrchr (location, '/');
-        if (slash != NULL) {
-                return slash + 1;
-        } else {
-                return location;
-        }
-}
-
-static gboolean
-gsm_autostart_app_initable_init (GInitable *initable,
-                                 GCancellable *cancellable,
-                                 GError  **error)
-{
-        GsmAutostartApp *app = GSM_AUTOSTART_APP (initable);
-
-        g_assert (app->priv->desktop_filename != NULL);
-        app->priv->app_info = g_desktop_app_info_new_from_filename (app->priv->desktop_filename);
-        if (app->priv->app_info == NULL) {
-                g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
-                             "Could not parse desktop file %s or it references a not found TryExec binary", app->priv->desktop_id);
-                return FALSE;
-        }
-
-        load_desktop_file (app);
-
-        return TRUE;
-}
-
-static void
-gsm_autostart_app_initable_iface_init (GInitableIface  *iface)
-{
-        iface->init = gsm_autostart_app_initable_init;
-}
-
-static void
-gsm_autostart_app_class_init (GsmAutostartAppClass *klass)
-{
-        GObjectClass *object_class = G_OBJECT_CLASS (klass);
-        GsmAppClass  *app_class = GSM_APP_CLASS (klass);
-
-        object_class->set_property = gsm_autostart_app_set_property;
-        object_class->get_property = gsm_autostart_app_get_property;
-        object_class->dispose = gsm_autostart_app_dispose;
-
-        app_class->impl_is_disabled = is_disabled;
-        app_class->impl_is_conditionally_disabled = is_conditionally_disabled;
-        app_class->impl_is_running = is_running;
-        app_class->impl_start = gsm_autostart_app_start;
-        app_class->impl_restart = gsm_autostart_app_restart;
-        app_class->impl_stop = gsm_autostart_app_stop;
-        app_class->impl_provides = gsm_autostart_app_provides;
-        app_class->impl_get_provides = gsm_autostart_app_get_provides;
-        app_class->impl_has_autostart_condition = gsm_autostart_app_has_autostart_condition;
-        app_class->impl_get_app_id = gsm_autostart_app_get_app_id;
-        app_class->impl_get_autorestart = gsm_autostart_app_get_autorestart;
-
-        g_object_class_install_property (object_class,
-                                         PROP_DESKTOP_FILENAME,
-                                         g_param_spec_string ("desktop-filename",
-                                                              "Desktop filename",
-                                                              "Freedesktop .desktop file",
-                                                              NULL,
-                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-        signals[CONDITION_CHANGED] =
-                g_signal_new ("condition-changed",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmAutostartAppClass, condition_changed),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE,
-                              1,
-                              G_TYPE_BOOLEAN);
-
-        g_type_class_add_private (object_class, sizeof (GsmAutostartAppPrivate));
-}
-
-GsmApp *
-gsm_autostart_app_new (const char *desktop_file,
-                       GError    **error)
-{
-        return (GsmApp*) g_initable_new (GSM_TYPE_AUTOSTART_APP, NULL, error,
-                                         "desktop-filename", desktop_file,
-                                         NULL);
-}
diff --git a/gnome-session/gsm-autostart-app.h b/gnome-session/gsm-autostart-app.h
deleted file mode 100644
index 8acaa0a..0000000
--- a/gnome-session/gsm-autostart-app.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2007 Novell, Inc.
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#ifndef __GSM_AUTOSTART_APP_H__
-#define __GSM_AUTOSTART_APP_H__
-
-#include "gsm-app.h"
-
-#include <X11/SM/SMlib.h>
-
-G_BEGIN_DECLS
-
-#define GSM_TYPE_AUTOSTART_APP            (gsm_autostart_app_get_type ())
-#define GSM_AUTOSTART_APP(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSM_TYPE_AUTOSTART_APP, GsmAutostartApp))
-#define GSM_AUTOSTART_APP_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GSM_TYPE_AUTOSTART_APP, GsmAutostartAppClass))
-#define GSM_IS_AUTOSTART_APP(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSM_TYPE_AUTOSTART_APP))
-#define GSM_IS_AUTOSTART_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GSM_TYPE_AUTOSTART_APP))
-#define GSM_AUTOSTART_APP_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GSM_TYPE_AUTOSTART_APP, GsmAutostartAppClass))
-
-typedef struct _GsmAutostartApp        GsmAutostartApp;
-typedef struct _GsmAutostartAppClass   GsmAutostartAppClass;
-typedef struct _GsmAutostartAppPrivate GsmAutostartAppPrivate;
-
-struct _GsmAutostartApp
-{
-        GsmApp parent;
-
-        GsmAutostartAppPrivate *priv;
-};
-
-struct _GsmAutostartAppClass
-{
-        GsmAppClass parent_class;
-
-        /* signals */
-        void     (*condition_changed)  (GsmApp  *app,
-                                        gboolean condition);
-};
-
-GType   gsm_autostart_app_get_type           (void) G_GNUC_CONST;
-
-GsmApp *gsm_autostart_app_new                (const char *desktop_file,
-                                              GError    **error);
-
-void    gsm_autostart_app_add_provides       (GsmAutostartApp *aapp,
-                                              const char      *provides);
-
-#define GSM_AUTOSTART_APP_ENABLED_KEY     "X-GNOME-Autostart-enabled"
-#define GSM_AUTOSTART_APP_PHASE_KEY       "X-GNOME-Autostart-Phase"
-#define GSM_AUTOSTART_APP_PROVIDES_KEY    "X-GNOME-Provides"
-#define GSM_AUTOSTART_APP_STARTUP_ID_KEY  "X-GNOME-Autostart-startup-id"
-#define GSM_AUTOSTART_APP_AUTORESTART_KEY "X-GNOME-AutoRestart"
-#define GSM_AUTOSTART_APP_DBUS_NAME_KEY   "X-GNOME-DBus-Name"
-#define GSM_AUTOSTART_APP_DBUS_PATH_KEY   "X-GNOME-DBus-Path"
-#define GSM_AUTOSTART_APP_DBUS_ARGS_KEY   "X-GNOME-DBus-Start-Arguments"
-#define GSM_AUTOSTART_APP_DISCARD_KEY     "X-GNOME-Autostart-discard-exec"
-
-G_END_DECLS
-
-#endif /* __GSM_AUTOSTART_APP_H__ */
diff --git a/gnome-session/gsm-client.c b/gnome-session/gsm-client.c
deleted file mode 100644
index efabde0..0000000
--- a/gnome-session/gsm-client.c
+++ /dev/null
@@ -1,543 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2007 Novell, Inc.
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#include "config.h"
-
-#include <dbus/dbus-glib.h>
-
-#include "gsm-client.h"
-#include "gsm-client-glue.h"
-
-static guint32 client_serial = 1;
-
-#define GSM_CLIENT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSM_TYPE_CLIENT, GsmClientPrivate))
-
-struct GsmClientPrivate
-{
-        char            *id;
-        char            *startup_id;
-        char            *app_id;
-        guint            status;
-        DBusGConnection *connection;
-};
-
-enum {
-        PROP_0,
-        PROP_ID,
-        PROP_STARTUP_ID,
-        PROP_APP_ID,
-        PROP_STATUS
-};
-
-enum {
-        DISCONNECTED,
-        END_SESSION_RESPONSE,
-        LAST_SIGNAL
-};
-
-static guint signals[LAST_SIGNAL] = { 0 };
-
-G_DEFINE_ABSTRACT_TYPE (GsmClient, gsm_client, G_TYPE_OBJECT)
-
-GQuark
-gsm_client_error_quark (void)
-{
-        static GQuark ret = 0;
-        if (ret == 0) {
-                ret = g_quark_from_static_string ("gsm_client_error");
-        }
-
-        return ret;
-}
-
-#define ENUM_ENTRY(NAME, DESC) { NAME, "" #NAME "", DESC }
-
-GType
-gsm_client_error_get_type (void)
-{
-        static GType etype = 0;
-
-        if (etype == 0) {
-                static const GEnumValue values[] = {
-                        ENUM_ENTRY (GSM_CLIENT_ERROR_GENERAL, "GeneralError"),
-                        ENUM_ENTRY (GSM_CLIENT_ERROR_NOT_REGISTERED, "NotRegistered"),
-                        { 0, 0, 0 }
-                };
-
-                g_assert (GSM_CLIENT_NUM_ERRORS == G_N_ELEMENTS (values) - 1);
-
-                etype = g_enum_register_static ("GsmClientError", values);
-        }
-
-        return etype;
-}
-
-static guint32
-get_next_client_serial (void)
-{
-        guint32 serial;
-
-        serial = client_serial++;
-
-        if ((gint32)client_serial < 0) {
-                client_serial = 1;
-        }
-
-        return serial;
-}
-
-static gboolean
-register_client (GsmClient *client)
-{
-        GError *error;
-
-        error = NULL;
-        client->priv->connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
-        if (client->priv->connection == NULL) {
-                if (error != NULL) {
-                        g_critical ("error getting session bus: %s", error->message);
-                        g_error_free (error);
-                }
-                return FALSE;
-        }
-
-        dbus_g_connection_register_g_object (client->priv->connection, client->priv->id, G_OBJECT (client));
-
-        return TRUE;
-}
-
-static GObject *
-gsm_client_constructor (GType                  type,
-                        guint                  n_construct_properties,
-                        GObjectConstructParam *construct_properties)
-{
-        GsmClient *client;
-        gboolean   res;
-
-        client = GSM_CLIENT (G_OBJECT_CLASS (gsm_client_parent_class)->constructor (type,
-                                                                                    n_construct_properties,
-                                                                                    construct_properties));
-
-        g_free (client->priv->id);
-        client->priv->id = g_strdup_printf ("/org/gnome/SessionManager/Client%u", get_next_client_serial ());
-
-        res = register_client (client);
-        if (! res) {
-                g_warning ("Unable to register client with session bus");
-        }
-
-        return G_OBJECT (client);
-}
-
-static void
-gsm_client_init (GsmClient *client)
-{
-        client->priv = GSM_CLIENT_GET_PRIVATE (client);
-}
-
-static void
-gsm_client_finalize (GObject *object)
-{
-        GsmClient *client;
-
-        g_return_if_fail (object != NULL);
-        g_return_if_fail (GSM_IS_CLIENT (object));
-
-        client = GSM_CLIENT (object);
-
-        g_return_if_fail (client->priv != NULL);
-
-        g_free (client->priv->id);
-        g_free (client->priv->startup_id);
-        g_free (client->priv->app_id);
-
-        G_OBJECT_CLASS (gsm_client_parent_class)->finalize (object);
-}
-
-void
-gsm_client_set_status (GsmClient *client,
-                       guint      status)
-{
-        g_return_if_fail (GSM_IS_CLIENT (client));
-        if (client->priv->status != status) {
-                client->priv->status = status;
-                g_object_notify (G_OBJECT (client), "status");
-        }
-}
-
-static void
-gsm_client_set_startup_id (GsmClient  *client,
-                           const char *startup_id)
-{
-        g_return_if_fail (GSM_IS_CLIENT (client));
-
-        g_free (client->priv->startup_id);
-
-        if (startup_id != NULL) {
-                client->priv->startup_id = g_strdup (startup_id);
-        } else {
-                client->priv->startup_id = g_strdup ("");
-        }
-        g_object_notify (G_OBJECT (client), "startup-id");
-}
-
-void
-gsm_client_set_app_id (GsmClient  *client,
-                       const char *app_id)
-{
-        g_return_if_fail (GSM_IS_CLIENT (client));
-
-        g_free (client->priv->app_id);
-
-        if (app_id != NULL) {
-                client->priv->app_id = g_strdup (app_id);
-        } else {
-                client->priv->app_id = g_strdup ("");
-        }
-        g_object_notify (G_OBJECT (client), "app-id");
-}
-
-static void
-gsm_client_set_property (GObject       *object,
-                         guint          prop_id,
-                         const GValue  *value,
-                         GParamSpec    *pspec)
-{
-        GsmClient *self;
-
-        self = GSM_CLIENT (object);
-
-        switch (prop_id) {
-        case PROP_STARTUP_ID:
-                gsm_client_set_startup_id (self, g_value_get_string (value));
-                break;
-        case PROP_APP_ID:
-                gsm_client_set_app_id (self, g_value_get_string (value));
-                break;
-        case PROP_STATUS:
-                gsm_client_set_status (self, g_value_get_uint (value));
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_client_get_property (GObject    *object,
-                         guint       prop_id,
-                         GValue     *value,
-                         GParamSpec *pspec)
-{
-        GsmClient *self;
-
-        self = GSM_CLIENT (object);
-
-        switch (prop_id) {
-        case PROP_STARTUP_ID:
-                g_value_set_string (value, self->priv->startup_id);
-                break;
-        case PROP_APP_ID:
-                g_value_set_string (value, self->priv->app_id);
-                break;
-        case PROP_STATUS:
-                g_value_set_uint (value, self->priv->status);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static gboolean
-default_stop (GsmClient *client,
-              GError   **error)
-{
-        g_return_val_if_fail (GSM_IS_CLIENT (client), FALSE);
-
-        g_warning ("Stop not implemented");
-
-        return TRUE;
-}
-
-static void
-gsm_client_dispose (GObject *object)
-{
-        GsmClient *client;
-
-        g_return_if_fail (object != NULL);
-        g_return_if_fail (GSM_IS_CLIENT (object));
-
-        client = GSM_CLIENT (object);
-
-        g_debug ("GsmClient: disposing %s", client->priv->id);
-
-        G_OBJECT_CLASS (gsm_client_parent_class)->dispose (object);
-}
-
-static void
-gsm_client_class_init (GsmClientClass *klass)
-{
-        GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-        object_class->get_property = gsm_client_get_property;
-        object_class->set_property = gsm_client_set_property;
-        object_class->constructor = gsm_client_constructor;
-        object_class->finalize = gsm_client_finalize;
-        object_class->dispose = gsm_client_dispose;
-
-        klass->impl_stop = default_stop;
-
-        signals[DISCONNECTED] =
-                g_signal_new ("disconnected",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmClientClass, disconnected),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE,
-                              0);
-        signals[END_SESSION_RESPONSE] =
-                g_signal_new ("end-session-response",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmClientClass, end_session_response),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE,
-                              4, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_STRING);
-
-        g_object_class_install_property (object_class,
-                                         PROP_STARTUP_ID,
-                                         g_param_spec_string ("startup-id",
-                                                              "startup-id",
-                                                              "startup-id",
-                                                              "",
-                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-        g_object_class_install_property (object_class,
-                                         PROP_APP_ID,
-                                         g_param_spec_string ("app-id",
-                                                              "app-id",
-                                                              "app-id",
-                                                              "",
-                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-        g_object_class_install_property (object_class,
-                                         PROP_STATUS,
-                                         g_param_spec_uint ("status",
-                                                            "status",
-                                                            "status",
-                                                            0,
-                                                            G_MAXINT,
-                                                            GSM_CLIENT_UNREGISTERED,
-                                                            G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-
-        g_type_class_add_private (klass, sizeof (GsmClientPrivate));
-
-        dbus_g_object_type_install_info (GSM_TYPE_CLIENT, &dbus_glib_gsm_client_object_info);
-}
-
-const char *
-gsm_client_peek_id (GsmClient *client)
-{
-        g_return_val_if_fail (GSM_IS_CLIENT (client), NULL);
-
-        return client->priv->id;
-}
-
-/**
- * gsm_client_peek_app_id:
- * @client: a #GsmClient.
- *
- * Note that the application ID might not be known; this happens when for XSMP
- * clients that we did not start ourselves, for instance.
- *
- * Returns: the application ID of the client, or %NULL if no such ID is
- * known. The string is owned by @client.
- **/
-const char *
-gsm_client_peek_app_id (GsmClient *client)
-{
-        g_return_val_if_fail (GSM_IS_CLIENT (client), NULL);
-
-        return client->priv->app_id;
-}
-
-const char *
-gsm_client_peek_startup_id (GsmClient *client)
-{
-        g_return_val_if_fail (GSM_IS_CLIENT (client), NULL);
-
-        return client->priv->startup_id;
-}
-
-guint
-gsm_client_peek_status (GsmClient *client)
-{
-        g_return_val_if_fail (GSM_IS_CLIENT (client), GSM_CLIENT_UNREGISTERED);
-
-        return client->priv->status;
-}
-
-guint
-gsm_client_peek_restart_style_hint (GsmClient *client)
-{
-        g_return_val_if_fail (GSM_IS_CLIENT (client), GSM_CLIENT_RESTART_NEVER);
-
-        return GSM_CLIENT_GET_CLASS (client)->impl_get_restart_style_hint (client);
-}
-
-gboolean
-gsm_client_get_startup_id (GsmClient *client,
-                           char     **id,
-                           GError   **error)
-{
-        g_return_val_if_fail (GSM_IS_CLIENT (client), FALSE);
-
-        *id = g_strdup (client->priv->startup_id);
-
-        return TRUE;
-}
-
-gboolean
-gsm_client_get_app_id (GsmClient *client,
-                       char     **id,
-                       GError   **error)
-{
-        g_return_val_if_fail (GSM_IS_CLIENT (client), FALSE);
-
-        *id = g_strdup (client->priv->app_id);
-
-        return TRUE;
-}
-
-gboolean
-gsm_client_get_restart_style_hint (GsmClient *client,
-                                   guint     *hint,
-                                   GError   **error)
-{
-        g_return_val_if_fail (GSM_IS_CLIENT (client), FALSE);
-
-        *hint = GSM_CLIENT_GET_CLASS (client)->impl_get_restart_style_hint (client);
-
-        return TRUE;
-}
-
-gboolean
-gsm_client_get_status (GsmClient *client,
-                       guint     *status,
-                       GError   **error)
-{
-        g_return_val_if_fail (GSM_IS_CLIENT (client), FALSE);
-
-        *status = client->priv->status;
-
-        return TRUE;
-}
-
-gboolean
-gsm_client_get_unix_process_id (GsmClient  *client,
-                                guint      *pid,
-                                GError    **error)
-{
-        g_return_val_if_fail (GSM_IS_CLIENT (client), FALSE);
-
-        *pid = GSM_CLIENT_GET_CLASS (client)->impl_get_unix_process_id (client);
-
-        return TRUE;
-}
-
-/**
- * gsm_client_get_app_name:
- * @client: a #GsmClient.
- *
- * Returns: a copy of the application name of the client, or %NULL if no such
- * name is known.
- **/
-char *
-gsm_client_get_app_name (GsmClient *client)
-{
-        g_return_val_if_fail (GSM_IS_CLIENT (client), NULL);
-
-        return GSM_CLIENT_GET_CLASS (client)->impl_get_app_name (client);
-}
-
-gboolean
-gsm_client_cancel_end_session (GsmClient *client,
-                               GError   **error)
-{
-        g_return_val_if_fail (GSM_IS_CLIENT (client), FALSE);
-
-        return GSM_CLIENT_GET_CLASS (client)->impl_cancel_end_session (client, error);
-}
-
-
-gboolean
-gsm_client_query_end_session (GsmClient                *client,
-                              GsmClientEndSessionFlag   flags,
-                              GError                  **error)
-{
-        g_return_val_if_fail (GSM_IS_CLIENT (client), FALSE);
-
-        return GSM_CLIENT_GET_CLASS (client)->impl_query_end_session (client, flags, error);
-}
-
-gboolean
-gsm_client_end_session (GsmClient                *client,
-                        GsmClientEndSessionFlag   flags,
-                        GError                  **error)
-{
-        g_return_val_if_fail (GSM_IS_CLIENT (client), FALSE);
-
-        return GSM_CLIENT_GET_CLASS (client)->impl_end_session (client, flags, error);
-}
-
-gboolean
-gsm_client_stop (GsmClient *client,
-                 GError   **error)
-{
-        g_return_val_if_fail (GSM_IS_CLIENT (client), FALSE);
-
-        return GSM_CLIENT_GET_CLASS (client)->impl_stop (client, error);
-}
-
-void
-gsm_client_disconnected (GsmClient *client)
-{
-        g_signal_emit (client, signals[DISCONNECTED], 0);
-}
-
-GKeyFile *
-gsm_client_save (GsmClient *client,
-                 GError   **error)
-{
-        g_return_val_if_fail (GSM_IS_CLIENT (client), FALSE);
-
-        return GSM_CLIENT_GET_CLASS (client)->impl_save (client, error);
-}
-
-void
-gsm_client_end_session_response (GsmClient  *client,
-                                 gboolean    is_ok,
-                                 gboolean    do_last,
-                                 gboolean    cancel,
-                                 const char *reason)
-{
-        g_signal_emit (client, signals[END_SESSION_RESPONSE], 0,
-                       is_ok, do_last, cancel, reason);
-}
diff --git a/gnome-session/gsm-client.h b/gnome-session/gsm-client.h
deleted file mode 100644
index aeb03c2..0000000
--- a/gnome-session/gsm-client.h
+++ /dev/null
@@ -1,171 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2007 Novell, Inc.
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#ifndef __GSM_CLIENT_H__
-#define __GSM_CLIENT_H__
-
-#include <glib.h>
-#include <glib-object.h>
-#include <sys/types.h>
-
-G_BEGIN_DECLS
-
-#define GSM_TYPE_CLIENT            (gsm_client_get_type ())
-#define GSM_CLIENT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSM_TYPE_CLIENT, GsmClient))
-#define GSM_CLIENT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GSM_TYPE_CLIENT, GsmClientClass))
-#define GSM_IS_CLIENT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSM_TYPE_CLIENT))
-#define GSM_IS_CLIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GSM_TYPE_CLIENT))
-#define GSM_CLIENT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GSM_TYPE_CLIENT, GsmClientClass))
-
-typedef struct _GsmClient        GsmClient;
-typedef struct _GsmClientClass   GsmClientClass;
-
-typedef struct GsmClientPrivate GsmClientPrivate;
-
-typedef enum {
-        GSM_CLIENT_UNREGISTERED = 0,
-        GSM_CLIENT_REGISTERED,
-        GSM_CLIENT_FINISHED,
-        GSM_CLIENT_FAILED
-} GsmClientStatus;
-
-typedef enum {
-        GSM_CLIENT_RESTART_NEVER = 0,
-        GSM_CLIENT_RESTART_IF_RUNNING,
-        GSM_CLIENT_RESTART_ANYWAY,
-        GSM_CLIENT_RESTART_IMMEDIATELY
-} GsmClientRestartStyle;
-
-typedef enum {
-        GSM_CLIENT_END_SESSION_FLAG_FORCEFUL = 1 << 0,
-        GSM_CLIENT_END_SESSION_FLAG_SAVE     = 1 << 1,
-        GSM_CLIENT_END_SESSION_FLAG_LAST     = 1 << 2
-} GsmClientEndSessionFlag;
-
-struct _GsmClient
-{
-        GObject           parent;
-        GsmClientPrivate *priv;
-};
-
-struct _GsmClientClass
-{
-        GObjectClass parent_class;
-
-        /* signals */
-        void         (*disconnected)               (GsmClient  *client);
-        void         (*end_session_response)       (GsmClient  *client,
-                                                    gboolean    ok,
-                                                    gboolean    do_last,
-                                                    gboolean    cancel,
-                                                    const char *reason);
-
-        /* virtual methods */
-        char *                (*impl_get_app_name)           (GsmClient *client);
-        GsmClientRestartStyle (*impl_get_restart_style_hint) (GsmClient *client);
-        guint                 (*impl_get_unix_process_id)    (GsmClient *client);
-        gboolean              (*impl_query_end_session)      (GsmClient *client,
-                                                              GsmClientEndSessionFlag flags,
-                                                              GError   **error);
-        gboolean              (*impl_end_session)            (GsmClient *client,
-                                                              GsmClientEndSessionFlag flags,
-                                                              GError   **error);
-        gboolean              (*impl_cancel_end_session)     (GsmClient *client,
-                                                              GError   **error);
-        gboolean              (*impl_stop)                   (GsmClient *client,
-                                                              GError   **error);
-        GKeyFile *            (*impl_save)                   (GsmClient *client,
-                                                              GError   **error);
-};
-
-typedef enum
-{
-        GSM_CLIENT_ERROR_GENERAL = 0,
-        GSM_CLIENT_ERROR_NOT_REGISTERED,
-        GSM_CLIENT_NUM_ERRORS
-} GsmClientError;
-
-#define GSM_CLIENT_ERROR gsm_client_error_quark ()
-#define GSM_CLIENT_TYPE_ERROR (gsm_client_error_get_type ())
-
-GType                 gsm_client_error_get_type             (void);
-GQuark                gsm_client_error_quark                (void);
-
-GType                 gsm_client_get_type                   (void) G_GNUC_CONST;
-
-const char           *gsm_client_peek_id                    (GsmClient  *client);
-
-
-const char *          gsm_client_peek_startup_id            (GsmClient  *client);
-const char *          gsm_client_peek_app_id                (GsmClient  *client);
-guint                 gsm_client_peek_restart_style_hint    (GsmClient  *client);
-guint                 gsm_client_peek_status                (GsmClient  *client);
-
-
-char                 *gsm_client_get_app_name               (GsmClient  *client);
-void                  gsm_client_set_app_id                 (GsmClient  *client,
-                                                             const char *app_id);
-void                  gsm_client_set_status                 (GsmClient  *client,
-                                                             guint       status);
-
-gboolean              gsm_client_end_session                (GsmClient  *client,
-                                                             guint       flags,
-                                                             GError    **error);
-gboolean              gsm_client_query_end_session          (GsmClient  *client,
-                                                             guint       flags,
-                                                             GError    **error);
-gboolean              gsm_client_cancel_end_session         (GsmClient  *client,
-                                                             GError    **error);
-
-void                  gsm_client_disconnected               (GsmClient  *client);
-
-GKeyFile             *gsm_client_save                       (GsmClient  *client,
-                                                             GError    **error);
-/* exported to bus */
-gboolean              gsm_client_stop                       (GsmClient  *client,
-                                                             GError    **error);
-gboolean              gsm_client_get_startup_id             (GsmClient  *client,
-                                                             char      **startup_id,
-                                                             GError    **error);
-gboolean              gsm_client_get_app_id                 (GsmClient  *client,
-                                                             char      **app_id,
-                                                             GError    **error);
-gboolean              gsm_client_get_restart_style_hint     (GsmClient  *client,
-                                                             guint      *hint,
-                                                             GError    **error);
-gboolean              gsm_client_get_status                 (GsmClient  *client,
-                                                             guint      *status,
-                                                             GError    **error);
-gboolean              gsm_client_get_unix_process_id        (GsmClient  *client,
-                                                             guint      *pid,
-                                                             GError    **error);
-
-/* private */
-
-void                  gsm_client_end_session_response       (GsmClient  *client,
-                                                             gboolean    is_ok,
-                                                             gboolean    do_last,
-                                                             gboolean    cancel,
-                                                             const char *reason);
-
-G_END_DECLS
-
-#endif /* __GSM_CLIENT_H__ */
diff --git a/gnome-session/gsm-consolekit.c b/gnome-session/gsm-consolekit.c
deleted file mode 100644
index c4b7e4c..0000000
--- a/gnome-session/gsm-consolekit.c
+++ /dev/null
@@ -1,1054 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2008 Jon McCann <jmccann@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#include "config.h"
-
-#include <errno.h>
-#include <string.h>
-#include <unistd.h>
-
-#include <glib.h>
-#include <glib-object.h>
-#include <glib/gi18n.h>
-
-#include <dbus/dbus-glib.h>
-#include <dbus/dbus-glib-lowlevel.h>
-
-#define UPOWER_ENABLE_DEPRECATED 1
-#include <upower.h>
-
-#include "gsm-system.h"
-#include "gsm-consolekit.h"
-
-#define CK_NAME      "org.freedesktop.ConsoleKit"
-#define CK_PATH      "/org/freedesktop/ConsoleKit"
-
-#define CK_MANAGER_PATH      "/org/freedesktop/ConsoleKit/Manager"
-#define CK_MANAGER_INTERFACE "org.freedesktop.ConsoleKit.Manager"
-#define CK_SEAT_INTERFACE    "org.freedesktop.ConsoleKit.Seat"
-#define CK_SESSION_INTERFACE "org.freedesktop.ConsoleKit.Session"
-
-#define GSM_CONSOLEKIT_SESSION_TYPE_LOGIN_WINDOW "LoginWindow"
-
-#define GSM_CONSOLEKIT_GET_PRIVATE(o)                                   \
-        (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSM_TYPE_CONSOLEKIT, GsmConsolekitPrivate))
-
-struct _GsmConsolekitPrivate
-{
-        DBusGConnection *dbus_connection;
-        DBusGProxy      *bus_proxy;
-        DBusGProxy      *ck_proxy;
-        DBusGProxy      *session_proxy;
-        UpClient        *up_client;
-
-        gboolean         is_active;
-        gboolean         restarting;
-
-        gchar            *session_id;
-};
-
-enum {
-        PROP_0,
-        PROP_ACTIVE
-};
-
-static void     gsm_consolekit_class_init   (GsmConsolekitClass *klass);
-static void     gsm_consolekit_init         (GsmConsolekit      *ck);
-static void     gsm_consolekit_finalize     (GObject            *object);
-
-static void     gsm_consolekit_free_dbus    (GsmConsolekit      *manager);
-
-static DBusHandlerResult gsm_consolekit_dbus_filter (DBusConnection *connection,
-                                                     DBusMessage    *message,
-                                                     void           *user_data);
-
-static void     gsm_consolekit_on_name_owner_changed (DBusGProxy        *bus_proxy,
-                                                      const char        *name,
-                                                      const char        *prev_owner,
-                                                      const char        *new_owner,
-                                                      GsmConsolekit   *manager);
-
-static void gsm_consolekit_system_init (GsmSystemInterface *iface);
-
-G_DEFINE_TYPE_WITH_CODE (GsmConsolekit, gsm_consolekit, G_TYPE_OBJECT,
-                         G_IMPLEMENT_INTERFACE (GSM_TYPE_SYSTEM,
-                                                gsm_consolekit_system_init))
-
-static void
-gsm_consolekit_set_property (GObject      *object,
-                             guint         prop_id,
-                             const GValue *value,
-                             GParamSpec   *pspec)
-{
-        GsmConsolekit *self = GSM_CONSOLEKIT (object);
-
-        switch (prop_id) {
-        case PROP_ACTIVE:
-                self->priv->is_active = g_value_get_boolean (value);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-        }
-}
-
-static void
-gsm_consolekit_get_property (GObject    *object,
-                             guint       prop_id,
-                             GValue     *value,
-                             GParamSpec *pspec)
-{
-        GsmConsolekit *self = GSM_CONSOLEKIT (object);
-
-        switch (prop_id) {
-        case PROP_ACTIVE:
-                g_value_set_boolean (value, self->priv->is_active);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_consolekit_class_init (GsmConsolekitClass *manager_class)
-{
-        GObjectClass *object_class;
-
-        object_class = G_OBJECT_CLASS (manager_class);
-
-        object_class->get_property = gsm_consolekit_get_property;
-        object_class->set_property = gsm_consolekit_set_property;
-        object_class->finalize = gsm_consolekit_finalize;
-
-        g_object_class_override_property (object_class, PROP_ACTIVE, "active");
-
-        g_type_class_add_private (manager_class, sizeof (GsmConsolekitPrivate));
-}
-
-static DBusHandlerResult
-gsm_consolekit_dbus_filter (DBusConnection *connection,
-                            DBusMessage    *message,
-                            void           *user_data)
-{
-        GsmConsolekit *manager;
-
-        manager = GSM_CONSOLEKIT (user_data);
-
-        if (dbus_message_is_signal (message,
-                                    DBUS_INTERFACE_LOCAL, "Disconnected") &&
-            strcmp (dbus_message_get_path (message), DBUS_PATH_LOCAL) == 0) {
-                gsm_consolekit_free_dbus (manager);
-                /* let other filters get this disconnected signal, so that they
-                 * can handle it too */
-        }
-
-        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-}
-
-static void
-is_active_cb (DBusGProxy     *proxy,
-              DBusGProxyCall *call,
-              gpointer        data)
-{
-        GsmConsolekit *self = data;
-        GError *local_error = NULL;
-        gboolean is_active;
-
-        if (!dbus_g_proxy_end_call (proxy, call, &local_error,
-                                    G_TYPE_BOOLEAN, &is_active,
-                                    G_TYPE_INVALID)) {
-                g_warning ("Failed IsActive call to ConsoleKit: %s",
-                           local_error->message);
-                g_clear_error (&local_error);
-                return;
-        }
-
-        if (is_active != self->priv->is_active) {
-                self->priv->is_active = is_active;
-                g_object_notify ((GObject*) self, "active");
-        }
-}
-
-static void
-on_active_changed (DBusGProxy   *proxy,
-                   gboolean      is_active,
-                   GsmConsolekit *self)
-{
-        if (is_active != self->priv->is_active) {
-                self->priv->is_active = is_active;
-                g_object_notify ((GObject*) self, "active");
-        }
-}
-
-static gboolean
-gsm_consolekit_ensure_ck_connection (GsmConsolekit  *manager,
-                                     GError        **error)
-{
-        GError  *connection_error;
-        gboolean is_connected;
-        gboolean ret;
-        guint32 pid;
-
-        connection_error = NULL;
-        manager->priv->session_id = NULL;
-        is_connected = FALSE;
-
-        if (manager->priv->dbus_connection == NULL) {
-                DBusConnection *connection;
-
-                manager->priv->dbus_connection = dbus_g_bus_get (DBUS_BUS_SYSTEM,
-                                                                 &connection_error);
-
-                if (manager->priv->dbus_connection == NULL) {
-                        g_propagate_error (error, connection_error);
-                        is_connected = FALSE;
-                        goto out;
-                }
-
-                connection = dbus_g_connection_get_connection (manager->priv->dbus_connection);
-                dbus_connection_set_exit_on_disconnect (connection, FALSE);
-                dbus_connection_add_filter (connection,
-                                            gsm_consolekit_dbus_filter,
-                                            manager, NULL);
-        }
-
-        if (manager->priv->bus_proxy == NULL) {
-                manager->priv->bus_proxy =
-                        dbus_g_proxy_new_for_name_owner (manager->priv->dbus_connection,
-                                                         DBUS_SERVICE_DBUS,
-                                                         DBUS_PATH_DBUS,
-                                                         DBUS_INTERFACE_DBUS,
-                                                         &connection_error);
-
-                if (manager->priv->bus_proxy == NULL) {
-                        g_propagate_error (error, connection_error);
-                        is_connected = FALSE;
-                        goto out;
-                }
-
-                dbus_g_proxy_add_signal (manager->priv->bus_proxy,
-                                         "NameOwnerChanged",
-                                         G_TYPE_STRING,
-                                         G_TYPE_STRING,
-                                         G_TYPE_STRING,
-                                         G_TYPE_INVALID);
-
-                dbus_g_proxy_connect_signal (manager->priv->bus_proxy,
-                                             "NameOwnerChanged",
-                                             G_CALLBACK (gsm_consolekit_on_name_owner_changed),
-                                             manager, NULL);
-        }
-
-        if (manager->priv->ck_proxy == NULL) {
-                manager->priv->ck_proxy =
-                        dbus_g_proxy_new_for_name_owner (manager->priv->dbus_connection,
-                                                         CK_NAME,
-                                                         CK_MANAGER_PATH,
-                                                         CK_MANAGER_INTERFACE,
-                                                         &connection_error);
-
-                if (manager->priv->ck_proxy == NULL) {
-                        g_propagate_error (error, connection_error);
-                        is_connected = FALSE;
-                        goto out;
-                }
-	}
-
-        pid = getpid ();
-        ret = dbus_g_proxy_call (manager->priv->ck_proxy, "GetSessionForUnixProcess", &connection_error,
-                                 G_TYPE_UINT, pid,
-                                 G_TYPE_INVALID,
-                                 DBUS_TYPE_G_OBJECT_PATH, &manager->priv->session_id,
-                                 G_TYPE_INVALID);
-        if (!ret) {
-                g_propagate_error (error, connection_error);
-                goto out;
-        }
-
-        if (manager->priv->session_proxy == NULL) {
-                manager->priv->session_proxy =
-                        dbus_g_proxy_new_for_name_owner (manager->priv->dbus_connection,
-                                                         CK_NAME,
-                                                         manager->priv->session_id,
-                                                         CK_SESSION_INTERFACE,
-                                                         &connection_error);
-
-                if (manager->priv->session_proxy == NULL) {
-                        g_propagate_error (error, connection_error);
-                        is_connected = FALSE;
-                        goto out;
-                }
-
-                dbus_g_proxy_begin_call (manager->priv->session_proxy,
-                                         "IsActive",
-                                         is_active_cb, g_object_ref (manager),
-                                         (GDestroyNotify)g_object_unref,
-                                         G_TYPE_INVALID);
-                dbus_g_proxy_add_signal (manager->priv->session_proxy, "ActiveChanged", G_TYPE_BOOLEAN, G_TYPE_INVALID);
-                dbus_g_proxy_connect_signal (manager->priv->session_proxy, "ActiveChanged",
-                                             G_CALLBACK (on_active_changed), manager, NULL);
-        }
-
-        g_clear_object (&manager->priv->up_client);
-        manager->priv->up_client = up_client_new ();
-
-        is_connected = TRUE;
-
- out:
-        if (!is_connected) {
-                if (manager->priv->dbus_connection == NULL) {
-                        if (manager->priv->bus_proxy != NULL) {
-                                g_object_unref (manager->priv->bus_proxy);
-                                manager->priv->bus_proxy = NULL;
-                        }
-
-                        if (manager->priv->ck_proxy != NULL) {
-                                g_object_unref (manager->priv->ck_proxy);
-                                manager->priv->ck_proxy = NULL;
-                        }
-
-                        g_clear_object (&manager->priv->session_proxy);
-                        g_clear_object (&manager->priv->session_id);
-                } else if (manager->priv->bus_proxy == NULL) {
-                        if (manager->priv->ck_proxy != NULL) {
-                                g_object_unref (manager->priv->ck_proxy);
-                                manager->priv->ck_proxy = NULL;
-                        }
-
-                        g_clear_object (&manager->priv->session_proxy);
-                        g_clear_object (&manager->priv->session_id);
-                }
-        }
-
-        return is_connected;
-}
-
-static void
-gsm_consolekit_on_name_owner_changed (DBusGProxy    *bus_proxy,
-                                      const char    *name,
-                                      const char    *prev_owner,
-                                      const char    *new_owner,
-                                      GsmConsolekit *manager)
-{
-        if (name != NULL && strcmp (name, "org.freedesktop.ConsoleKit") != 0) {
-                return;
-        }
-
-        g_clear_object (&manager->priv->ck_proxy);
-        g_clear_object (&manager->priv->session_proxy);
-
-        gsm_consolekit_ensure_ck_connection (manager, NULL);
-
-}
-
-static void
-gsm_consolekit_init (GsmConsolekit *manager)
-{
-        GError *error;
-
-        manager->priv = GSM_CONSOLEKIT_GET_PRIVATE (manager);
-
-        error = NULL;
-
-        if (!gsm_consolekit_ensure_ck_connection (manager, &error)) {
-                g_warning ("Could not connect to ConsoleKit: %s",
-                           error->message);
-                g_error_free (error);
-        }
-}
-
-static void
-gsm_consolekit_free_dbus (GsmConsolekit *manager)
-{
-        g_clear_object (&manager->priv->bus_proxy);
-        g_clear_object (&manager->priv->ck_proxy);
-        g_clear_object (&manager->priv->session_proxy);
-        g_clear_object (&manager->priv->session_id);
-        g_clear_object (&manager->priv->up_client);
-
-        if (manager->priv->dbus_connection != NULL) {
-                DBusConnection *connection;
-                connection = dbus_g_connection_get_connection (manager->priv->dbus_connection);
-                dbus_connection_remove_filter (connection,
-                                               gsm_consolekit_dbus_filter,
-                                               manager);
-
-                dbus_g_connection_unref (manager->priv->dbus_connection);
-                manager->priv->dbus_connection = NULL;
-        }
-}
-
-static void
-gsm_consolekit_finalize (GObject *object)
-{
-        GsmConsolekit *manager;
-        GObjectClass  *parent_class;
-
-        manager = GSM_CONSOLEKIT (object);
-
-        parent_class = G_OBJECT_CLASS (gsm_consolekit_parent_class);
-
-        gsm_consolekit_free_dbus (manager);
-
-        if (parent_class->finalize != NULL) {
-                parent_class->finalize (object);
-        }
-}
-
-static void
-emit_restart_complete (GsmConsolekit *manager,
-                       GError        *error)
-{
-        GError *call_error;
-
-        call_error = NULL;
-
-        if (error != NULL) {
-                call_error = g_error_new_literal (GSM_SYSTEM_ERROR,
-                                                  GSM_SYSTEM_ERROR_RESTARTING,
-                                                  error->message);
-        }
-
-        g_signal_emit_by_name (G_OBJECT (manager),
-                               "request_completed", call_error);
-
-        if (call_error != NULL) {
-                g_error_free (call_error);
-        }
-}
-
-static void
-emit_stop_complete (GsmConsolekit *manager,
-                    GError        *error)
-{
-        GError *call_error;
-
-        call_error = NULL;
-
-        if (error != NULL) {
-                call_error = g_error_new_literal (GSM_SYSTEM_ERROR,
-                                                  GSM_SYSTEM_ERROR_STOPPING,
-                                                  error->message);
-        }
-
-        g_signal_emit_by_name (G_OBJECT (manager),
-                               "request_completed", call_error);
-
-        if (call_error != NULL) {
-                g_error_free (call_error);
-        }
-}
-
-static void
-gsm_consolekit_attempt_restart (GsmSystem *system)
-{
-        GsmConsolekit *manager = GSM_CONSOLEKIT (system);
-        gboolean res;
-        GError  *error;
-
-        error = NULL;
-
-        if (!gsm_consolekit_ensure_ck_connection (manager, &error)) {
-                g_warning ("Could not connect to ConsoleKit: %s",
-                           error->message);
-                emit_restart_complete (manager, error);
-                g_error_free (error);
-                return;
-        }
-
-        res = dbus_g_proxy_call_with_timeout (manager->priv->ck_proxy,
-                                              "Restart",
-                                              INT_MAX,
-                                              &error,
-                                              G_TYPE_INVALID,
-                                              G_TYPE_INVALID);
-
-        if (!res) {
-                g_warning ("Unable to restart system: %s", error->message);
-                emit_restart_complete (manager, error);
-                g_error_free (error);
-        } else {
-                emit_restart_complete (manager, NULL);
-        }
-}
-
-static void
-gsm_consolekit_attempt_stop (GsmSystem *system)
-{
-        GsmConsolekit *manager = GSM_CONSOLEKIT (system);
-        gboolean res;
-        GError  *error;
-
-        error = NULL;
-
-        if (!gsm_consolekit_ensure_ck_connection (manager, &error)) {
-                g_warning ("Could not connect to ConsoleKit: %s",
-                           error->message);
-                emit_stop_complete (manager, error);
-                g_error_free (error);
-                return;
-        }
-
-        res = dbus_g_proxy_call_with_timeout (manager->priv->ck_proxy,
-                                              "Stop",
-                                              INT_MAX,
-                                              &error,
-                                              G_TYPE_INVALID,
-                                              G_TYPE_INVALID);
-
-        if (!res) {
-                g_warning ("Unable to stop system: %s", error->message);
-                emit_stop_complete (manager, error);
-                g_error_free (error);
-        } else {
-                emit_stop_complete (manager, NULL);
-        }
-}
-
-static gboolean
-get_current_session_id (DBusConnection *connection,
-                        char          **session_id)
-{
-        DBusError       local_error;
-        DBusMessage    *message;
-        DBusMessage    *reply;
-        gboolean        ret;
-        DBusMessageIter iter;
-        const char     *value;
-
-        ret = FALSE;
-        reply = NULL;
-
-        dbus_error_init (&local_error);
-        message = dbus_message_new_method_call (CK_NAME,
-                                                CK_MANAGER_PATH,
-                                                CK_MANAGER_INTERFACE,
-                                                "GetCurrentSession");
-        if (message == NULL) {
-                goto out;
-        }
-
-        dbus_error_init (&local_error);
-        reply = dbus_connection_send_with_reply_and_block (connection,
-                                                           message,
-                                                           -1,
-                                                           &local_error);
-        if (reply == NULL) {
-                if (dbus_error_is_set (&local_error)) {
-                        g_warning ("Unable to determine session: %s", local_error.message);
-                        dbus_error_free (&local_error);
-                        goto out;
-                }
-        }
-
-        dbus_message_iter_init (reply, &iter);
-        dbus_message_iter_get_basic (&iter, &value);
-        if (session_id != NULL) {
-                *session_id = g_strdup (value);
-        }
-
-        ret = TRUE;
- out:
-        if (message != NULL) {
-                dbus_message_unref (message);
-        }
-        if (reply != NULL) {
-                dbus_message_unref (reply);
-        }
-
-        return ret;
-}
-
-static gboolean
-get_seat_id_for_session (DBusConnection *connection,
-                         const char     *session_id,
-                         char          **seat_id)
-{
-        DBusError       local_error;
-        DBusMessage    *message;
-        DBusMessage    *reply;
-        gboolean        ret;
-        DBusMessageIter iter;
-        const char     *value;
-
-        ret = FALSE;
-        reply = NULL;
-
-        dbus_error_init (&local_error);
-        message = dbus_message_new_method_call (CK_NAME,
-                                                session_id,
-                                                CK_SESSION_INTERFACE,
-                                                "GetSeatId");
-        if (message == NULL) {
-                goto out;
-        }
-
-        dbus_error_init (&local_error);
-        reply = dbus_connection_send_with_reply_and_block (connection,
-                                                           message,
-                                                           -1,
-                                                           &local_error);
-        if (reply == NULL) {
-                if (dbus_error_is_set (&local_error)) {
-                        g_warning ("Unable to determine seat: %s", local_error.message);
-                        dbus_error_free (&local_error);
-                        goto out;
-                }
-        }
-
-        dbus_message_iter_init (reply, &iter);
-        dbus_message_iter_get_basic (&iter, &value);
-        if (seat_id != NULL) {
-                *seat_id = g_strdup (value);
-        }
-
-        ret = TRUE;
- out:
-        if (message != NULL) {
-                dbus_message_unref (message);
-        }
-        if (reply != NULL) {
-                dbus_message_unref (reply);
-        }
-
-        return ret;
-}
-
-static char *
-get_current_seat_id (DBusConnection *connection)
-{
-        gboolean res;
-        char    *session_id;
-        char    *seat_id;
-
-        session_id = NULL;
-        seat_id = NULL;
-
-        res = get_current_session_id (connection, &session_id);
-        if (res) {
-                res = get_seat_id_for_session (connection, session_id, &seat_id);
-        }
-        g_free (session_id);
-
-        return seat_id;
-}
-
-static void
-gsm_consolekit_set_session_idle (GsmSystem *system,
-                                 gboolean   is_idle)
-{
-        GsmConsolekit *manager = GSM_CONSOLEKIT (system);
-        gboolean        res;
-        GError         *error;
-        char           *session_id;
-        DBusMessage    *message;
-        DBusMessage    *reply;
-        DBusError       dbus_error;
-        DBusMessageIter iter;
-
-        error = NULL;
-
-        if (!gsm_consolekit_ensure_ck_connection (manager, &error)) {
-                g_warning ("Could not connect to ConsoleKit: %s",
-                           error->message);
-                g_error_free (error);
-                return;
-        }
-
-        session_id = NULL;
-        res = get_current_session_id (dbus_g_connection_get_connection (manager->priv->dbus_connection),
-                                      &session_id);
-        if (!res) {
-                goto out;
-        }
-
-
-        g_debug ("Updating ConsoleKit idle status: %d", is_idle);
-        message = dbus_message_new_method_call (CK_NAME,
-                                                session_id,
-                                                CK_SESSION_INTERFACE,
-                                                "SetIdleHint");
-        if (message == NULL) {
-                g_debug ("Couldn't allocate the D-Bus message");
-                return;
-        }
-
-        dbus_message_iter_init_append (message, &iter);
-        dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &is_idle);
-
-        /* FIXME: use async? */
-        dbus_error_init (&dbus_error);
-        reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (manager->priv->dbus_connection),
-                                                           message,
-                                                           -1,
-                                                           &dbus_error);
-        dbus_message_unref (message);
-
-        if (reply != NULL) {
-                dbus_message_unref (reply);
-        }
-
-        if (dbus_error_is_set (&dbus_error)) {
-                g_debug ("%s raised:\n %s\n\n", dbus_error.name, dbus_error.message);
-                dbus_error_free (&dbus_error);
-        }
-
-out:
-        g_free (session_id);
-}
-
-static gboolean
-seat_can_activate_sessions (DBusConnection *connection,
-                            const char     *seat_id)
-{
-        DBusError       local_error;
-        DBusMessage    *message;
-        DBusMessage    *reply;
-        DBusMessageIter iter;
-        gboolean        can_activate;
-
-        can_activate = FALSE;
-        reply = NULL;
-
-        dbus_error_init (&local_error);
-        message = dbus_message_new_method_call (CK_NAME,
-                                                seat_id,
-                                                CK_SEAT_INTERFACE,
-                                                "CanActivateSessions");
-        if (message == NULL) {
-                goto out;
-        }
-
-        dbus_error_init (&local_error);
-        reply = dbus_connection_send_with_reply_and_block (connection,
-                                                           message,
-                                                           -1,
-                                                           &local_error);
-        if (reply == NULL) {
-                if (dbus_error_is_set (&local_error)) {
-                        g_warning ("Unable to activate session: %s", local_error.message);
-                        dbus_error_free (&local_error);
-                        goto out;
-                }
-        }
-
-        dbus_message_iter_init (reply, &iter);
-        dbus_message_iter_get_basic (&iter, &can_activate);
-
- out:
-        if (message != NULL) {
-                dbus_message_unref (message);
-        }
-        if (reply != NULL) {
-                dbus_message_unref (reply);
-        }
-
-        return can_activate;
-}
-
-static gboolean
-gsm_consolekit_can_switch_user (GsmSystem *system)
-{
-        GsmConsolekit *manager = GSM_CONSOLEKIT (system);
-        GError  *error;
-        char    *seat_id;
-        gboolean ret;
-
-        error = NULL;
-
-        if (!gsm_consolekit_ensure_ck_connection (manager, &error)) {
-                g_warning ("Could not connect to ConsoleKit: %s",
-                           error->message);
-                g_error_free (error);
-                return FALSE;
-        }
-
-        seat_id = get_current_seat_id (dbus_g_connection_get_connection (manager->priv->dbus_connection));
-        if (seat_id == NULL || seat_id[0] == '\0') {
-                g_debug ("seat id is not set; can't switch sessions");
-                return FALSE;
-        }
-
-        ret = seat_can_activate_sessions (dbus_g_connection_get_connection (manager->priv->dbus_connection),
-                                          seat_id);
-        g_free (seat_id);
-
-        return ret;
-}
-
-static gboolean
-gsm_consolekit_can_restart (GsmSystem *system)
-{
-        GsmConsolekit *manager = GSM_CONSOLEKIT (system);
-        gboolean res;
-	gboolean can_restart;
-        GError  *error;
-
-        error = NULL;
-
-        if (!gsm_consolekit_ensure_ck_connection (manager, &error)) {
-                g_warning ("Could not connect to ConsoleKit: %s",
-                           error->message);
-                g_error_free (error);
-                return FALSE;
-        }
-
-        res = dbus_g_proxy_call_with_timeout (manager->priv->ck_proxy,
-                                              "CanRestart",
-                                              INT_MAX,
-                                              &error,
-                                              G_TYPE_INVALID,
-                                              G_TYPE_BOOLEAN, &can_restart,
-                                              G_TYPE_INVALID);
-
-        if (!res) {
-                g_warning ("Could not query CanRestart from ConsoleKit: %s",
-                           error->message);
-                g_error_free (error);
-                return FALSE;
-        }
-
-	return can_restart;
-}
-
-static gboolean
-gsm_consolekit_can_stop (GsmSystem *system)
-{
-        GsmConsolekit *manager = GSM_CONSOLEKIT (system);
-        gboolean res;
-	gboolean can_stop;
-        GError  *error;
-
-        error = NULL;
-
-        if (!gsm_consolekit_ensure_ck_connection (manager, &error)) {
-                g_warning ("Could not connect to ConsoleKit: %s",
-                           error->message);
-                g_error_free (error);
-                return FALSE;
-        }
-
-        res = dbus_g_proxy_call_with_timeout (manager->priv->ck_proxy,
-                                              "CanStop",
-                                              INT_MAX,
-                                              &error,
-                                              G_TYPE_INVALID,
-                                              G_TYPE_BOOLEAN, &can_stop,
-                                              G_TYPE_INVALID);
-
-        if (!res) {
-                g_warning ("Could not query CanStop from ConsoleKit: %s",
-                           error->message);
-                g_error_free (error);
-                return FALSE;
-        }
-	return can_stop;
-}
-
-static gchar *
-gsm_consolekit_get_current_session_type (GsmConsolekit *manager)
-{
-        GError *gerror;
-	DBusConnection *connection;
-	DBusError error;
-	DBusMessage *message = NULL;
-	DBusMessage *reply = NULL;
-	gchar *session_id;
-	gchar *ret;
-	DBusMessageIter iter;
-	const char *value;
-
-	session_id = NULL;
-	ret = NULL;
-        gerror = NULL;
-
-        if (!gsm_consolekit_ensure_ck_connection (manager, &gerror)) {
-                g_warning ("Could not connect to ConsoleKit: %s",
-                           gerror->message);
-                g_error_free (gerror);
-		goto out;
-        }
-
-	connection = dbus_g_connection_get_connection (manager->priv->dbus_connection);
-	if (!get_current_session_id (connection, &session_id)) {
-		goto out;
-	}
-
-	dbus_error_init (&error);
-	message = dbus_message_new_method_call (CK_NAME,
-						session_id,
-						CK_SESSION_INTERFACE,
-						"GetSessionType");
-	if (message == NULL) {
-		goto out;
-	}
-
-	reply = dbus_connection_send_with_reply_and_block (connection,
-							   message,
-							   -1,
-							   &error);
-
-	if (reply == NULL) {
-		if (dbus_error_is_set (&error)) {
-			g_warning ("Unable to determine session type: %s", error.message);
-			dbus_error_free (&error);
-		}
-		goto out;
-	}
-
-	dbus_message_iter_init (reply, &iter);
-	dbus_message_iter_get_basic (&iter, &value);
-	ret = g_strdup (value);
-
-out:
-	if (message != NULL) {
-		dbus_message_unref (message);
-	}
-	if (reply != NULL) {
-		dbus_message_unref (reply);
-	}
-	g_free (session_id);
-
-	return ret;
-}
-
-static gboolean
-gsm_consolekit_is_login_session (GsmSystem *system)
-{
-        GsmConsolekit *consolekit = GSM_CONSOLEKIT (system);
-        char *session_type;
-        gboolean ret;
-
-        session_type = gsm_consolekit_get_current_session_type (consolekit);
-
-        ret = (g_strcmp0 (session_type, GSM_CONSOLEKIT_SESSION_TYPE_LOGIN_WINDOW) == 0);
-
-        g_free (session_type);
-
-        return ret;
-}
-
-static gboolean
-gsm_consolekit_can_suspend (GsmSystem *system)
-{
-        GsmConsolekit *consolekit = GSM_CONSOLEKIT (system);
-
-        return up_client_get_can_suspend (consolekit->priv->up_client);
-}
-
-static gboolean
-gsm_consolekit_can_hibernate (GsmSystem *system)
-{
-        GsmConsolekit *consolekit = GSM_CONSOLEKIT (system);
-
-        return up_client_get_can_hibernate (consolekit->priv->up_client);
-}
-
-static void
-gsm_consolekit_suspend (GsmSystem *system)
-{
-        GsmConsolekit *consolekit = GSM_CONSOLEKIT (system);
-        GError *error = NULL;
-        gboolean ret;
-
-        ret = up_client_suspend_sync (consolekit->priv->up_client, NULL, &error);
-        if (!ret) {
-                g_warning ("Unexpected suspend failure: %s", error->message);
-                g_error_free (error);
-        }
-}
-
-static void
-gsm_consolekit_hibernate (GsmSystem *system)
-{
-        GsmConsolekit *consolekit = GSM_CONSOLEKIT (system);
-        GError *error = NULL;
-        gboolean ret;
-
-        ret = up_client_hibernate_sync (consolekit->priv->up_client, NULL, &error);
-        if (!ret) {
-                g_warning ("Unexpected hibernate failure: %s", error->message);
-                g_error_free (error);
-        }
-}
-
-static void
-gsm_consolekit_add_inhibitor (GsmSystem        *system,
-                              const gchar      *id,
-                              GsmInhibitorFlag  flag)
-{
-}
-
-static void
-gsm_consolekit_remove_inhibitor (GsmSystem   *system,
-                                 const gchar *id)
-{
-}
-
-static void
-gsm_consolekit_prepare_shutdown (GsmSystem *system,
-                                 gboolean   restart)
-{
-        GsmConsolekit *consolekit = GSM_CONSOLEKIT (system);
-
-        consolekit->priv->restarting = restart;
-        g_signal_emit_by_name (system, "shutdown-prepared", TRUE);
-}
-
-static void
-gsm_consolekit_complete_shutdown (GsmSystem *system)
-{
-        GsmConsolekit *consolekit = GSM_CONSOLEKIT (system);
-
-        if (consolekit->priv->restarting)
-                gsm_consolekit_attempt_restart (system);
-        else
-                gsm_consolekit_attempt_stop (system);
-}
-
-static void
-gsm_consolekit_system_init (GsmSystemInterface *iface)
-{
-        iface->can_switch_user = gsm_consolekit_can_switch_user;
-        iface->can_stop = gsm_consolekit_can_stop;
-        iface->can_restart = gsm_consolekit_can_restart;
-        iface->can_suspend = gsm_consolekit_can_suspend;
-        iface->can_hibernate = gsm_consolekit_can_hibernate;
-        iface->attempt_stop = gsm_consolekit_attempt_stop;
-        iface->attempt_restart = gsm_consolekit_attempt_restart;
-        iface->suspend = gsm_consolekit_suspend;
-        iface->hibernate = gsm_consolekit_hibernate;
-        iface->set_session_idle = gsm_consolekit_set_session_idle;
-        iface->is_login_session = gsm_consolekit_is_login_session;
-        iface->add_inhibitor = gsm_consolekit_add_inhibitor;
-        iface->remove_inhibitor = gsm_consolekit_remove_inhibitor;
-        iface->prepare_shutdown = gsm_consolekit_prepare_shutdown;
-        iface->complete_shutdown = gsm_consolekit_complete_shutdown;
-}
-
-GsmConsolekit *
-gsm_consolekit_new (void)
-{
-        GsmConsolekit *manager;
-
-        manager = g_object_new (GSM_TYPE_CONSOLEKIT, NULL);
-
-        return manager;
-}
diff --git a/gnome-session/gsm-consolekit.h b/gnome-session/gsm-consolekit.h
deleted file mode 100644
index b202095..0000000
--- a/gnome-session/gsm-consolekit.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2008 Jon McCann <jmccann@redhat.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- *
- * Authors:
- *	Jon McCann <jmccann@redhat.com>
- */
-
-#ifndef __GSM_CONSOLEKIT_H__
-#define __GSM_CONSOLEKIT_H__
-
-#include <glib.h>
-#include <glib-object.h>
-
-G_BEGIN_DECLS
-
-#define GSM_TYPE_CONSOLEKIT             (gsm_consolekit_get_type ())
-#define GSM_CONSOLEKIT(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSM_TYPE_CONSOLEKIT, GsmConsolekit))
-#define GSM_CONSOLEKIT_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSM_TYPE_CONSOLEKIT, GsmConsolekitClass))
-#define GSM_IS_CONSOLEKIT(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSM_TYPE_CONSOLEKIT))
-#define GSM_IS_CONSOLEKIT_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSM_TYPE_CONSOLEKIT))
-#define GSM_CONSOLEKIT_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS((obj), GSM_TYPE_CONSOLEKIT, GsmConsolekitClass))
-
-typedef struct _GsmConsolekit        GsmConsolekit;
-typedef struct _GsmConsolekitClass   GsmConsolekitClass;
-typedef struct _GsmConsolekitPrivate GsmConsolekitPrivate;
-
-struct _GsmConsolekit
-{
-        GObject               parent;
-
-        GsmConsolekitPrivate *priv;
-};
-
-struct _GsmConsolekitClass
-{
-        GObjectClass parent_class;
-};
-
-GType            gsm_consolekit_get_type        (void);
-
-GsmConsolekit   *gsm_consolekit_new             (void) G_GNUC_MALLOC;
-
-G_END_DECLS
-
-#endif /* __GSM_CONSOLEKIT_H__ */
diff --git a/gnome-session/gsm-dbus-client.c b/gnome-session/gsm-dbus-client.c
deleted file mode 100644
index 34dd238..0000000
--- a/gnome-session/gsm-dbus-client.c
+++ /dev/null
@@ -1,698 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#include "config.h"
-
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <time.h>
-#include <unistd.h>
-
-#include <dbus/dbus.h>
-#include <dbus/dbus-glib.h>
-#include <dbus/dbus-glib-lowlevel.h>
-
-#include "gsm-dbus-client.h"
-
-#include "gsm-manager.h"
-#include "gsm-util.h"
-
-#define GSM_DBUS_CLIENT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSM_TYPE_DBUS_CLIENT, GsmDBusClientPrivate))
-
-
-#define SM_DBUS_NAME                     "org.gnome.SessionManager"
-#define SM_DBUS_CLIENT_PRIVATE_INTERFACE "org.gnome.SessionManager.ClientPrivate"
-
-struct GsmDBusClientPrivate
-{
-        char                 *bus_name;
-        GPid                  caller_pid;
-        GsmClientRestartStyle restart_style_hint;
-        DBusConnection       *connection;
-};
-
-enum {
-        PROP_0,
-        PROP_BUS_NAME
-};
-
-G_DEFINE_TYPE (GsmDBusClient, gsm_dbus_client, GSM_TYPE_CLIENT)
-
-GQuark
-gsm_dbus_client_error_quark (void)
-{
-        static GQuark ret = 0;
-        if (ret == 0) {
-                ret = g_quark_from_static_string ("gsm_dbus_client_error");
-        }
-
-        return ret;
-}
-
-#define ENUM_ENTRY(NAME, DESC) { NAME, "" #NAME "", DESC }
-
-GType
-gsm_dbus_client_error_get_type (void)
-{
-        static GType etype = 0;
-
-        if (etype == 0) {
-                static const GEnumValue values[] = {
-                        ENUM_ENTRY (GSM_DBUS_CLIENT_ERROR_GENERAL, "GeneralError"),
-                        ENUM_ENTRY (GSM_DBUS_CLIENT_ERROR_NOT_CLIENT, "NotClient"),
-                        { 0, 0, 0 }
-                };
-
-                g_assert (GSM_DBUS_CLIENT_NUM_ERRORS == G_N_ELEMENTS (values) - 1);
-
-                etype = g_enum_register_static ("GsmDbusClientError", values);
-        }
-
-        return etype;
-}
-
-static gboolean
-setup_connection (GsmDBusClient *client)
-{
-        DBusError error;
-
-        dbus_error_init (&error);
-
-        if (client->priv->connection == NULL) {
-                client->priv->connection = dbus_bus_get (DBUS_BUS_SESSION, &error);
-                if (client->priv->connection == NULL) {
-                        if (dbus_error_is_set (&error)) {
-                                g_debug ("GsmDbusClient: Couldn't connect to session bus: %s",
-                                         error.message);
-                                dbus_error_free (&error);
-                        }
-                        return FALSE;
-                }
-
-                dbus_connection_setup_with_g_main (client->priv->connection, NULL);
-                dbus_connection_set_exit_on_disconnect (client->priv->connection, FALSE);
-        }
-
-        return TRUE;
-}
-
-static void
-raise_error (DBusConnection *connection,
-             DBusMessage    *in_reply_to,
-             const char     *error_name,
-             char           *format, ...)
-{
-        char         buf[512];
-        DBusMessage *reply;
-
-        va_list args;
-        va_start (args, format);
-        vsnprintf (buf, sizeof (buf), format, args);
-        va_end (args);
-
-        reply = dbus_message_new_error (in_reply_to, error_name, buf);
-        if (reply == NULL) {
-                g_error ("No memory");
-        }
-        if (! dbus_connection_send (connection, reply, NULL)) {
-                g_error ("No memory");
-        }
-
-        dbus_message_unref (reply);
-}
-
-static void
-handle_end_session_response (GsmDBusClient *client,
-                             DBusMessage   *message)
-{
-        const char     *sender;
-        DBusMessage    *reply;
-        DBusError       error;
-        dbus_bool_t     is_ok;
-        const char     *reason;
-
-        dbus_error_init (&error);
-        if (! dbus_message_get_args (message, &error,
-                                     DBUS_TYPE_BOOLEAN, &is_ok,
-                                     DBUS_TYPE_STRING, &reason,
-                                     DBUS_TYPE_INVALID)) {
-                if (dbus_error_is_set (&error)) {
-                        g_warning ("Invalid method call: %s", error.message);
-                        dbus_error_free (&error);
-                }
-                raise_error (client->priv->connection,
-                             message,
-                             DBUS_ERROR_FAILED,
-                             "There is a syntax error in the invocation of the method EndSessionResponse");
-                return;
-        }
-
-        g_debug ("GsmDBusClient: got EndSessionResponse is-ok:%d reason=%s", is_ok, reason);
-
-        /* make sure it is from our client */
-        sender = dbus_message_get_sender (message);
-        if (sender == NULL
-            || IS_STRING_EMPTY (client->priv->bus_name)
-            || strcmp (sender, client->priv->bus_name) != 0) {
-
-                raise_error (client->priv->connection,
-                             message,
-                             DBUS_ERROR_FAILED,
-                             "Caller not recognized as the client");
-                return;
-        }
-
-        reply = dbus_message_new_method_return (message);
-        if (reply == NULL) {
-                g_error ("No memory");
-        }
-
-        gsm_client_end_session_response (GSM_CLIENT (client),
-                                         is_ok, FALSE, FALSE, reason);
-
-
-        if (! dbus_connection_send (client->priv->connection, reply, NULL)) {
-                g_error ("No memory");
-        }
-
-        dbus_message_unref (reply);
-}
-
-static DBusHandlerResult
-client_dbus_filter_function (DBusConnection *connection,
-                             DBusMessage    *message,
-                             void           *user_data)
-{
-        GsmDBusClient *client = GSM_DBUS_CLIENT (user_data);
-        const char    *path;
-
-        g_return_val_if_fail (connection != NULL, DBUS_HANDLER_RESULT_NOT_YET_HANDLED);
-        g_return_val_if_fail (message != NULL, DBUS_HANDLER_RESULT_NOT_YET_HANDLED);
-
-        path = dbus_message_get_path (message);
-
-        g_debug ("GsmDBusClient: obj_path=%s interface=%s method=%s",
-                 dbus_message_get_path (message),
-                 dbus_message_get_interface (message),
-                 dbus_message_get_member (message));
-
-        if (dbus_message_is_method_call (message, SM_DBUS_CLIENT_PRIVATE_INTERFACE, "EndSessionResponse")) {
-                g_assert (gsm_client_peek_id (GSM_CLIENT (client)) != NULL);
-
-                if (path != NULL && strcmp (path, gsm_client_peek_id (GSM_CLIENT (client))) != 0) {
-                        /* Different object path */
-                        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-                }
-                handle_end_session_response (client, message);
-                return DBUS_HANDLER_RESULT_HANDLED;
-        }
-
-        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-}
-
-static GObject *
-gsm_dbus_client_constructor (GType                  type,
-                             guint                  n_construct_properties,
-                             GObjectConstructParam *construct_properties)
-{
-        GsmDBusClient *client;
-
-        client = GSM_DBUS_CLIENT (G_OBJECT_CLASS (gsm_dbus_client_parent_class)->constructor (type,
-                                                                                              n_construct_properties,
-                                                                                              construct_properties));
-
-        if (! setup_connection (client)) {
-                g_object_unref (client);
-                return NULL;
-        }
-
-        /* Object path is already registered by base class */
-        dbus_connection_add_filter (client->priv->connection, client_dbus_filter_function, client, NULL);
-
-        return G_OBJECT (client);
-}
-
-static void
-gsm_dbus_client_init (GsmDBusClient *client)
-{
-        client->priv = GSM_DBUS_CLIENT_GET_PRIVATE (client);
-}
-
-/* adapted from PolicyKit */
-static gboolean
-get_caller_info (GsmDBusClient *client,
-                 const char    *sender,
-                 uid_t         *calling_uid,
-                 pid_t         *calling_pid)
-{
-        gboolean         res;
-        GError          *error;
-        DBusGConnection *connection;
-        DBusGProxy      *bus_proxy;
-
-        res = FALSE;
-        bus_proxy = NULL;
-
-        if (sender == NULL) {
-                goto out;
-        }
-
-        error = NULL;
-        connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
-        if (connection == NULL) {
-                if (error != NULL) {
-                        g_warning ("error getting session bus: %s", error->message);
-                        g_error_free (error);
-                }
-                goto out;
-        }
-
-        bus_proxy = dbus_g_proxy_new_for_name (connection,
-                                               DBUS_SERVICE_DBUS,
-                                               DBUS_PATH_DBUS,
-                                               DBUS_INTERFACE_DBUS);
-
-        error = NULL;
-        if (! dbus_g_proxy_call (bus_proxy, "GetConnectionUnixUser", &error,
-                                 G_TYPE_STRING, sender,
-                                 G_TYPE_INVALID,
-                                 G_TYPE_UINT, calling_uid,
-                                 G_TYPE_INVALID)) {
-                g_debug ("GetConnectionUnixUser() failed: %s", error->message);
-                g_error_free (error);
-                goto out;
-        }
-
-        error = NULL;
-        if (! dbus_g_proxy_call (bus_proxy, "GetConnectionUnixProcessID", &error,
-                                 G_TYPE_STRING, sender,
-                                 G_TYPE_INVALID,
-                                 G_TYPE_UINT, calling_pid,
-                                 G_TYPE_INVALID)) {
-                g_debug ("GetConnectionUnixProcessID() failed: %s", error->message);
-                g_error_free (error);
-                goto out;
-        }
-
-        res = TRUE;
-
-        g_debug ("uid = %d", *calling_uid);
-        g_debug ("pid = %d", *calling_pid);
-
-out:
-        if (bus_proxy != NULL) {
-                g_object_unref (bus_proxy);
-        }
-        return res;
-}
-
-static void
-gsm_dbus_client_set_bus_name (GsmDBusClient  *client,
-                              const char     *bus_name)
-{
-        uid_t    uid;
-        pid_t    pid;
-
-        g_return_if_fail (GSM_IS_DBUS_CLIENT (client));
-
-        g_free (client->priv->bus_name);
-
-        client->priv->bus_name = g_strdup (bus_name);
-        g_object_notify (G_OBJECT (client), "bus-name");
-
-        if (client->priv->bus_name != NULL) {
-                gboolean res;
-
-                res = get_caller_info (client, bus_name, &uid, &pid);
-                if (! res) {
-                        pid = 0;
-                }
-        } else {
-                pid = 0;
-        }
-        client->priv->caller_pid = pid;
-}
-
-const char *
-gsm_dbus_client_get_bus_name (GsmDBusClient  *client)
-{
-        g_return_val_if_fail (GSM_IS_DBUS_CLIENT (client), NULL);
-
-        return client->priv->bus_name;
-}
-
-static void
-gsm_dbus_client_set_property (GObject       *object,
-                              guint          prop_id,
-                              const GValue  *value,
-                              GParamSpec    *pspec)
-{
-        GsmDBusClient *self;
-
-        self = GSM_DBUS_CLIENT (object);
-
-        switch (prop_id) {
-        case PROP_BUS_NAME:
-                gsm_dbus_client_set_bus_name (self, g_value_get_string (value));
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_dbus_client_get_property (GObject    *object,
-                              guint       prop_id,
-                              GValue     *value,
-                              GParamSpec *pspec)
-{
-        GsmDBusClient *self;
-
-        self = GSM_DBUS_CLIENT (object);
-
-        switch (prop_id) {
-        case PROP_BUS_NAME:
-                g_value_set_string (value, self->priv->bus_name);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_dbus_client_finalize (GObject *object)
-{
-        GsmDBusClient *client = (GsmDBusClient *) object;
-
-        g_free (client->priv->bus_name);
-
-        G_OBJECT_CLASS (gsm_dbus_client_parent_class)->finalize (object);
-}
-
-static GKeyFile *
-dbus_client_save (GsmClient *client,
-                  GError   **error)
-{
-        g_debug ("GsmDBusClient: saving client with id %s",
-                 gsm_client_peek_id (client));
-
-        /* FIXME: We still don't support client saving for D-Bus
-         * session clients */
-
-        return NULL;
-}
-
-static gboolean
-dbus_client_stop (GsmClient *client,
-                  GError   **error)
-{
-        GsmDBusClient  *dbus_client = (GsmDBusClient *) client;
-        DBusMessage    *message;
-        gboolean        ret;
-
-        ret = FALSE;
-
-        /* unicast the signal to only the registered bus name */
-        message = dbus_message_new_signal (gsm_client_peek_id (client),
-                                           SM_DBUS_CLIENT_PRIVATE_INTERFACE,
-                                           "Stop");
-        if (message == NULL) {
-                goto out;
-        }
-        if (!dbus_message_set_destination (message, dbus_client->priv->bus_name)) {
-                goto out;
-        }
-
-        if (!dbus_connection_send (dbus_client->priv->connection, message, NULL)) {
-                goto out;
-        }
-
-        ret = TRUE;
-
- out:
-        if (message != NULL) {
-                dbus_message_unref (message);
-        }
-
-        return ret;
-}
-
-static char *
-dbus_client_get_app_name (GsmClient *client)
-{
-        /* Always use app-id instead */
-        return NULL;
-}
-
-static GsmClientRestartStyle
-dbus_client_get_restart_style_hint (GsmClient *client)
-{
-        return (GSM_DBUS_CLIENT (client)->priv->restart_style_hint);
-}
-
-static guint
-dbus_client_get_unix_process_id (GsmClient *client)
-{
-        return (GSM_DBUS_CLIENT (client)->priv->caller_pid);
-}
-
-static gboolean
-dbus_client_query_end_session (GsmClient                *client,
-                               GsmClientEndSessionFlag   flags,
-                               GError                  **error)
-{
-        GsmDBusClient  *dbus_client = (GsmDBusClient *) client;
-        DBusMessage    *message;
-        DBusMessageIter iter;
-        gboolean        ret;
-
-        ret = FALSE;
-
-        if (dbus_client->priv->bus_name == NULL) {
-                g_set_error (error,
-                             GSM_CLIENT_ERROR,
-                             GSM_CLIENT_ERROR_NOT_REGISTERED,
-                             "Client is not registered");
-                return FALSE;
-        }
-
-        g_debug ("GsmDBusClient: sending QueryEndSession signal to %s", dbus_client->priv->bus_name);
-
-        /* unicast the signal to only the registered bus name */
-        message = dbus_message_new_signal (gsm_client_peek_id (client),
-                                           SM_DBUS_CLIENT_PRIVATE_INTERFACE,
-                                           "QueryEndSession");
-        if (message == NULL) {
-                g_set_error (error,
-                             GSM_CLIENT_ERROR,
-                             GSM_CLIENT_ERROR_NOT_REGISTERED,
-                             "Unable to send QueryEndSession message");
-                goto out;
-        }
-        if (!dbus_message_set_destination (message, dbus_client->priv->bus_name)) {
-                g_set_error (error,
-                             GSM_CLIENT_ERROR,
-                             GSM_CLIENT_ERROR_NOT_REGISTERED,
-                             "Unable to send QueryEndSession message");
-                goto out;
-        }
-
-        dbus_message_iter_init_append (message, &iter);
-        dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &flags);
-
-        if (!dbus_connection_send (dbus_client->priv->connection, message, NULL)) {
-                g_set_error (error,
-                             GSM_CLIENT_ERROR,
-                             GSM_CLIENT_ERROR_NOT_REGISTERED,
-                             "Unable to send QueryEndSession message");
-                goto out;
-        }
-
-        ret = TRUE;
-
- out:
-        if (message != NULL) {
-                dbus_message_unref (message);
-        }
-
-        return ret;
-}
-
-static gboolean
-dbus_client_end_session (GsmClient                *client,
-                         GsmClientEndSessionFlag   flags,
-                         GError                  **error)
-{
-        GsmDBusClient  *dbus_client = (GsmDBusClient *) client;
-        DBusMessage    *message;
-        DBusMessageIter iter;
-        gboolean        ret;
-
-        ret = FALSE;
-
-        /* unicast the signal to only the registered bus name */
-        message = dbus_message_new_signal (gsm_client_peek_id (client),
-                                           SM_DBUS_CLIENT_PRIVATE_INTERFACE,
-                                           "EndSession");
-        if (message == NULL) {
-                g_set_error (error,
-                             GSM_CLIENT_ERROR,
-                             GSM_CLIENT_ERROR_NOT_REGISTERED,
-                             "Unable to send EndSession message");
-                goto out;
-        }
-        if (!dbus_message_set_destination (message, dbus_client->priv->bus_name)) {
-                g_set_error (error,
-                             GSM_CLIENT_ERROR,
-                             GSM_CLIENT_ERROR_NOT_REGISTERED,
-                             "Unable to send EndSession message");
-                goto out;
-        }
-
-        dbus_message_iter_init_append (message, &iter);
-        dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &flags);
-
-        if (!dbus_connection_send (dbus_client->priv->connection, message, NULL)) {
-                g_set_error (error,
-                             GSM_CLIENT_ERROR,
-                             GSM_CLIENT_ERROR_NOT_REGISTERED,
-                             "Unable to send EndSession message");
-                goto out;
-        }
-
-        ret = TRUE;
-
- out:
-        if (message != NULL) {
-                dbus_message_unref (message);
-        }
-        return ret;
-}
-
-static gboolean
-dbus_client_cancel_end_session (GsmClient *client,
-                                GError   **error)
-{
-        GsmDBusClient  *dbus_client = (GsmDBusClient *) client;
-        DBusMessage    *message;
-        gboolean        ret = FALSE;
-
-        /* unicast the signal to only the registered bus name */
-        message = dbus_message_new_signal (gsm_client_peek_id (client),
-                                           SM_DBUS_CLIENT_PRIVATE_INTERFACE,
-                                           "CancelEndSession");
-        if (message == NULL) {
-                g_set_error (error,
-                             GSM_CLIENT_ERROR,
-                             GSM_CLIENT_ERROR_NOT_REGISTERED,
-                             "Unable to send CancelEndSession message");
-                goto out;
-        }
-        if (!dbus_message_set_destination (message, dbus_client->priv->bus_name)) {
-                g_set_error (error,
-                             GSM_CLIENT_ERROR,
-                             GSM_CLIENT_ERROR_NOT_REGISTERED,
-                             "Unable to send CancelEndSession message");
-                goto out;
-        }
-
-        if (!dbus_connection_send (dbus_client->priv->connection, message, NULL)) {
-                g_set_error (error,
-                             GSM_CLIENT_ERROR,
-                             GSM_CLIENT_ERROR_NOT_REGISTERED,
-                             "Unable to send CancelEndSession message");
-                goto out;
-        }
-
-        ret = TRUE;
-
- out:
-        if (message != NULL) {
-                dbus_message_unref (message);
-        }
-
-        return ret;
-}
-
-static void
-gsm_dbus_client_dispose (GObject *object)
-{
-        GsmDBusClient *client;
-
-        g_return_if_fail (object != NULL);
-        g_return_if_fail (GSM_IS_DBUS_CLIENT (object));
-
-        client = GSM_DBUS_CLIENT (object);
-
-        dbus_connection_remove_filter (client->priv->connection, client_dbus_filter_function, client);
-
-        G_OBJECT_CLASS (gsm_dbus_client_parent_class)->dispose (object);
-}
-
-static void
-gsm_dbus_client_class_init (GsmDBusClientClass *klass)
-{
-        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
-        GsmClientClass *client_class = GSM_CLIENT_CLASS (klass);
-
-        object_class->finalize             = gsm_dbus_client_finalize;
-        object_class->constructor          = gsm_dbus_client_constructor;
-        object_class->get_property         = gsm_dbus_client_get_property;
-        object_class->set_property         = gsm_dbus_client_set_property;
-        object_class->dispose              = gsm_dbus_client_dispose;
-
-        client_class->impl_save                   = dbus_client_save;
-        client_class->impl_stop                   = dbus_client_stop;
-        client_class->impl_query_end_session      = dbus_client_query_end_session;
-        client_class->impl_end_session            = dbus_client_end_session;
-        client_class->impl_cancel_end_session     = dbus_client_cancel_end_session;
-        client_class->impl_get_app_name           = dbus_client_get_app_name;
-        client_class->impl_get_restart_style_hint = dbus_client_get_restart_style_hint;
-        client_class->impl_get_unix_process_id    = dbus_client_get_unix_process_id;
-
-        g_object_class_install_property (object_class,
-                                         PROP_BUS_NAME,
-                                         g_param_spec_string ("bus-name",
-                                                              "bus-name",
-                                                              "bus-name",
-                                                              NULL,
-                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-
-        g_type_class_add_private (klass, sizeof (GsmDBusClientPrivate));
-}
-
-GsmClient *
-gsm_dbus_client_new (const char *startup_id,
-                     const char *bus_name)
-{
-        GsmDBusClient *client;
-
-        client = g_object_new (GSM_TYPE_DBUS_CLIENT,
-                               "startup-id", startup_id,
-                               "bus-name", bus_name,
-                               NULL);
-
-        return GSM_CLIENT (client);
-}
diff --git a/gnome-session/gsm-dbus-client.h b/gnome-session/gsm-dbus-client.h
deleted file mode 100644
index ca9bd0d..0000000
--- a/gnome-session/gsm-dbus-client.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#ifndef __GSM_DBUS_CLIENT_H__
-#define __GSM_DBUS_CLIENT_H__
-
-#include "gsm-client.h"
-
-G_BEGIN_DECLS
-
-#define GSM_TYPE_DBUS_CLIENT            (gsm_dbus_client_get_type ())
-#define GSM_DBUS_CLIENT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSM_TYPE_DBUS_CLIENT, GsmDBusClient))
-#define GSM_DBUS_CLIENT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GSM_TYPE_DBUS_CLIENT, GsmDBusClientClass))
-#define GSM_IS_DBUS_CLIENT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSM_TYPE_DBUS_CLIENT))
-#define GSM_IS_DBUS_CLIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GSM_TYPE_DBUS_CLIENT))
-#define GSM_DBUS_CLIENT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GSM_TYPE_DBUS_CLIENT, GsmDBusClientClass))
-
-typedef struct _GsmDBusClient        GsmDBusClient;
-typedef struct _GsmDBusClientClass   GsmDBusClientClass;
-
-typedef struct GsmDBusClientPrivate  GsmDBusClientPrivate;
-
-struct _GsmDBusClient
-{
-        GsmClient             parent;
-        GsmDBusClientPrivate *priv;
-};
-
-struct _GsmDBusClientClass
-{
-        GsmClientClass parent_class;
-};
-
-typedef enum
-{
-        GSM_DBUS_CLIENT_ERROR_GENERAL = 0,
-        GSM_DBUS_CLIENT_ERROR_NOT_CLIENT,
-        GSM_DBUS_CLIENT_NUM_ERRORS
-} GsmDBusClientError;
-
-#define GSM_DBUS_CLIENT_ERROR gsm_dbus_client_error_quark ()
-
-GType          gsm_dbus_client_error_get_type     (void);
-#define GSM_DBUS_CLIENT_TYPE_ERROR (gsm_dbus_client_error_get_type ())
-
-GQuark         gsm_dbus_client_error_quark        (void);
-
-GType          gsm_dbus_client_get_type           (void) G_GNUC_CONST;
-
-GsmClient *    gsm_dbus_client_new                (const char     *startup_id,
-                                                   const char     *bus_name);
-const char *   gsm_dbus_client_get_bus_name       (GsmDBusClient  *client);
-
-G_END_DECLS
-
-#endif /* __GSM_DBUS_CLIENT_H__ */
diff --git a/gnome-session/gsm-fail-whale-dialog.c b/gnome-session/gsm-fail-whale-dialog.c
deleted file mode 100644
index dc4ac94..0000000
--- a/gnome-session/gsm-fail-whale-dialog.c
+++ /dev/null
@@ -1,376 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- *
- * Authors:
- *	Colin Walters <walters@verbum.org>
- */
-
-#include <config.h>
-
-#include <stdlib.h>
-
-#include <glib/gi18n.h>
-
-#include <gtk/gtk.h>
-#ifdef GDK_WINDOWING_X11
-#include <gtk/gtkx.h>
-#endif
-
-#include "gsm-fail-whale-dialog.h"
-
-#include "gsm-icon-names.h"
-
-#define GSM_FAIL_WHALE_DIALOG_GET_PRIVATE(o)                                \
-        (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSM_TYPE_FAIL_WHALE_DIALOG, GsmFailWhaleDialogPrivate))
-
-struct _GsmFailWhaleDialogPrivate
-{
-        gboolean debug_mode;
-        gboolean allow_logout;
-        gboolean extensions;
-        GdkRectangle geometry;
-};
-
-G_DEFINE_TYPE (GsmFailWhaleDialog, gsm_fail_whale_dialog, GTK_TYPE_WINDOW);
-
-/* derived from tomboy */
-static void
-_window_override_user_time (GsmFailWhaleDialog *window)
-{
-        guint32 ev_time = gtk_get_current_event_time ();
-        GdkWindow *gdk_window = gtk_widget_get_window (GTK_WIDGET (window));
-
-#ifdef GDK_WINDOWING_X11
-        if (!GDK_IS_X11_WINDOW (gdk_window))
-                return;
-
-        if (ev_time == 0) {
-                gint ev_mask = gtk_widget_get_events (GTK_WIDGET (window));
-                if (!(ev_mask & GDK_PROPERTY_CHANGE_MASK)) {
-                        gtk_widget_add_events (GTK_WIDGET (window),
-                                               GDK_PROPERTY_CHANGE_MASK);
-                }
-
-                /*
-                 * NOTE: Last resort for D-BUS or other non-interactive
-                 *       openings.  Causes roundtrip to server.  Lame.
-                 */
-                ev_time = gdk_x11_get_server_time (gdk_window);
-        }
-
-        gdk_x11_window_set_user_time (gdk_window, ev_time);
-#endif
-}
-
-static void
-_window_move_resize_window (GsmFailWhaleDialog *window,
-                            gboolean  move,
-                            gboolean  resize)
-{
-        if (window->priv->debug_mode)
-                return;
-
-        g_debug ("Move and/or resize window x=%d y=%d w=%d h=%d",
-                 window->priv->geometry.x,
-                 window->priv->geometry.y,
-                 window->priv->geometry.width,
-                 window->priv->geometry.height);
-
-        if (resize) {
-                gtk_window_resize (GTK_WINDOW (window),
-                                   window->priv->geometry.width,
-                                   window->priv->geometry.height);
-        }
-
-        if (move) {
-                gtk_window_move (GTK_WINDOW (window),
-                                 window->priv->geometry.x,
-                                 window->priv->geometry.y);
-        }
-}
-
-static void
-update_geometry (GsmFailWhaleDialog *fail_dialog)
-{
-        int monitor;
-        GdkScreen *screen;
-
-        screen = gtk_widget_get_screen (GTK_WIDGET (fail_dialog));
-        monitor = gdk_screen_get_primary_monitor (screen);
-
-        gdk_screen_get_monitor_geometry (screen,
-                                         monitor,
-                                         &fail_dialog->priv->geometry);
-}
-
-static void
-on_screen_size_changed (GdkScreen          *screen,
-                        GsmFailWhaleDialog *fail_dialog)
-{
-        gtk_widget_queue_resize (GTK_WIDGET (fail_dialog));
-}
-
-static void
-gsm_fail_whale_dialog_realize (GtkWidget *widget)
-{
-        if (GTK_WIDGET_CLASS (gsm_fail_whale_dialog_parent_class)->realize) {
-                GTK_WIDGET_CLASS (gsm_fail_whale_dialog_parent_class)->realize (widget);
-        }
-
-        _window_override_user_time (GSM_FAIL_WHALE_DIALOG (widget));
-        update_geometry (GSM_FAIL_WHALE_DIALOG (widget));
-        _window_move_resize_window (GSM_FAIL_WHALE_DIALOG (widget), TRUE, TRUE);
-
-        g_signal_connect (gtk_window_get_screen (GTK_WINDOW (widget)),
-                          "size_changed",
-                          G_CALLBACK (on_screen_size_changed),
-                          widget);
-}
-
-static void
-gsm_fail_whale_dialog_unrealize (GtkWidget *widget)
-{
-        g_signal_handlers_disconnect_by_func (gtk_window_get_screen (GTK_WINDOW (widget)),
-                                              on_screen_size_changed,
-                                              widget);
-
-        if (GTK_WIDGET_CLASS (gsm_fail_whale_dialog_parent_class)->unrealize) {
-                GTK_WIDGET_CLASS (gsm_fail_whale_dialog_parent_class)->unrealize (widget);
-        }
-}
-
-static void
-gsm_fail_whale_dialog_size_request (GtkWidget      *widget,
-                                    GtkRequisition *requisition)
-{
-        GsmFailWhaleDialog *fail_dialog;
-        GdkRectangle   old_geometry;
-        int            position_changed = FALSE;
-        int            size_changed = FALSE;
-
-        fail_dialog = GSM_FAIL_WHALE_DIALOG (widget);
-
-        old_geometry = fail_dialog->priv->geometry;
-
-        update_geometry (fail_dialog);
-
-        requisition->width  = fail_dialog->priv->geometry.width;
-        requisition->height = fail_dialog->priv->geometry.height;
-
-        if (!gtk_widget_get_realized (widget)) {
-                return;
-        }
-
-        if (old_geometry.width  != fail_dialog->priv->geometry.width ||
-            old_geometry.height != fail_dialog->priv->geometry.height) {
-                size_changed = TRUE;
-        }
-
-        if (old_geometry.x != fail_dialog->priv->geometry.x ||
-            old_geometry.y != fail_dialog->priv->geometry.y) {
-                position_changed = TRUE;
-        }
-
-        _window_move_resize_window (fail_dialog,
-                                    position_changed, size_changed);
-}
-
-static void
-gsm_fail_whale_dialog_get_preferred_width (GtkWidget *widget,
-                                           gint      *minimal_width,
-                                           gint      *natural_width)
-{
-        GtkRequisition requisition;
-
-        gsm_fail_whale_dialog_size_request (widget, &requisition);
-
-        *minimal_width = *natural_width = requisition.width;
-}
-
-static void
-gsm_fail_whale_dialog_get_preferred_height (GtkWidget *widget,
-                                            gint      *minimal_height,
-                                            gint      *natural_height)
-{
-        GtkRequisition requisition;
-
-        gsm_fail_whale_dialog_size_request (widget, &requisition);
-
-        *minimal_height = *natural_height = requisition.height;
-}
-
-static void
-gsm_fail_whale_dialog_class_init (GsmFailWhaleDialogClass *klass)
-{
-        GtkWidgetClass *widget_class;
-
-        widget_class = GTK_WIDGET_CLASS (klass);
-
-        widget_class->realize = gsm_fail_whale_dialog_realize;
-        widget_class->unrealize = gsm_fail_whale_dialog_unrealize;
-        widget_class->get_preferred_width = gsm_fail_whale_dialog_get_preferred_width;
-        widget_class->get_preferred_height = gsm_fail_whale_dialog_get_preferred_height;
-
-        g_type_class_add_private (klass, sizeof (GsmFailWhaleDialogPrivate));
-}
-
-static void
-on_logout_clicked (GtkWidget          *button,
-                   GsmFailWhaleDialog *fail_dialog)
-{
-        if (!fail_dialog->priv->debug_mode) {
-                g_spawn_command_line_async ("gnome-session-quit --force", NULL);
-        }
-        gtk_main_quit ();
-}
-
-static GtkIconSize
-gsm_util_get_computer_fail_icon_size (void)
-{
-        static GtkIconSize icon_size = 0;
-
-        if (icon_size == 0)
-                icon_size = gtk_icon_size_register ("gnome-session-computer-fail", 128, 128);
-
-        return icon_size;
-}
-
-static void
-setup_window (GsmFailWhaleDialog *fail_dialog)
-{
-        GsmFailWhaleDialogPrivate *priv;
-        GtkWidget *alignment;
-        GtkWidget *box;
-        GtkWidget *image;
-        GtkWidget *label;
-        GtkWidget *message_label;
-        GtkWidget *button_box;
-        GtkWidget *button;
-        char *markup;
-
-        priv = fail_dialog->priv;
-
-        gtk_window_set_title (GTK_WINDOW (fail_dialog), "");
-        gtk_window_set_icon_name (GTK_WINDOW (fail_dialog), GSM_ICON_COMPUTER_FAIL);
-
-        gtk_window_set_skip_taskbar_hint (GTK_WINDOW (fail_dialog), TRUE);
-        gtk_window_set_keep_above (GTK_WINDOW (fail_dialog), TRUE);
-        gtk_window_stick (GTK_WINDOW (fail_dialog));
-        gtk_window_set_position (GTK_WINDOW (fail_dialog), GTK_WIN_POS_CENTER_ALWAYS);
-        /* only works if there is a window manager which is unlikely */
-        gtk_window_fullscreen (GTK_WINDOW (fail_dialog));
-
-        alignment = gtk_alignment_new (0.5, 0.5, 1, 1);
-        gtk_widget_show (alignment);
-        gtk_container_add (GTK_CONTAINER (fail_dialog), alignment);
-        g_object_set (alignment, "valign", GTK_ALIGN_CENTER, NULL);
-
-        box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 10);
-        gtk_widget_show (box);
-        gtk_container_add (GTK_CONTAINER (alignment), box);
-
-        image = gtk_image_new_from_icon_name (GSM_ICON_COMPUTER_FAIL,
-                                              gsm_util_get_computer_fail_icon_size ());
-        g_object_set (image, "use-fallback", TRUE, NULL);
-        gtk_widget_show (image);
-        gtk_box_pack_start (GTK_BOX (box), image, FALSE, FALSE, 0);
-
-        label = gtk_label_new (NULL);
-        markup = g_strdup_printf ("<b><big>%s</big></b>", _("Oh no!  Something has gone wrong."));
-        gtk_label_set_markup (GTK_LABEL (label), markup);
-        g_free (markup);
-        gtk_widget_show (label);
-        gtk_box_pack_start (GTK_BOX (box), label, FALSE, FALSE, 0);
-
-        if (!priv->allow_logout)
-                message_label = gtk_label_new (_("A problem has occurred and the system can't recover. Please contact a system administrator"));
-        else if (priv->extensions)
-                message_label = gtk_label_new (_("A problem has occurred and the system can't recover. All extensions have been disabled as a precaution."));
-        else
-                message_label = gtk_label_new (_("A problem has occurred and the system can't recover.\nPlease log out and try again."));
-
-        gtk_label_set_justify (GTK_LABEL (message_label), GTK_JUSTIFY_CENTER);
-        gtk_label_set_line_wrap (GTK_LABEL (message_label), TRUE);
-        gtk_widget_show (message_label);
-        gtk_box_pack_start (GTK_BOX (box),
-                            message_label, FALSE, FALSE, 0);
-
-        button_box = gtk_button_box_new (GTK_ORIENTATION_HORIZONTAL);
-        gtk_container_set_border_width (GTK_CONTAINER (button_box), 20);
-        gtk_widget_show (button_box);
-        gtk_box_pack_end (GTK_BOX (box),
-                          button_box, FALSE, FALSE, 0);
-
-        if (priv->allow_logout) {
-                button = gtk_button_new_with_mnemonic (_("_Log Out"));
-                gtk_widget_show (button);
-                gtk_box_pack_end (GTK_BOX (button_box),
-                                  button, FALSE, FALSE, 0);
-                g_signal_connect (button, "clicked",
-                                  G_CALLBACK (on_logout_clicked), fail_dialog);
-        }
-}
-
-static void
-gsm_fail_whale_dialog_init (GsmFailWhaleDialog *fail_dialog)
-{
-        fail_dialog->priv = GSM_FAIL_WHALE_DIALOG_GET_PRIVATE (fail_dialog);
-}
-
-static gboolean debug_mode = FALSE;
-static gboolean allow_logout = FALSE;
-static gboolean extensions = FALSE;
-
-int main (int argc, char *argv[])
-{
-        GOptionEntry entries[] = {
-                 { "debug", 0, 0, G_OPTION_ARG_NONE, &debug_mode, N_("Enable debugging code"), NULL },
-                 { "allow-logout", 0, 0, G_OPTION_ARG_NONE, &allow_logout, N_("Allow logout"), NULL },
-                 { "extensions", 0, 0, G_OPTION_ARG_NONE, &extensions, N_("Show extension warning"), NULL },
-                { NULL, 0, 0, 0, NULL, NULL, NULL }
-        };
-
-        GsmFailWhaleDialog        *fail_dialog;
-        GError *error = NULL;
-
-        gtk_init_with_args (&argc, &argv, " - fail whale",
-                            entries, GETTEXT_PACKAGE,
-                            &error);
-         if (error != NULL) {
-                 g_warning ("%s", error->message);
-                 exit (1);
-         }
-
-        fail_dialog = g_object_new (GSM_TYPE_FAIL_WHALE_DIALOG, NULL);
-        fail_dialog->priv->debug_mode = debug_mode;
-        fail_dialog->priv->allow_logout = allow_logout;
-        fail_dialog->priv->extensions = extensions;
-
-        setup_window (fail_dialog);
-
-        g_signal_connect (fail_dialog, "destroy",
-                          G_CALLBACK (gtk_main_quit), NULL);
-
-        gtk_widget_show (GTK_WIDGET (fail_dialog));
-
-        gtk_main ();
-
-        return 0;
-}
-
diff --git a/gnome-session/gsm-fail-whale-dialog.h b/gnome-session/gsm-fail-whale-dialog.h
deleted file mode 100644
index ec13993..0000000
--- a/gnome-session/gsm-fail-whale-dialog.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- *
- * Authors:
- *	Colin Walters <walters@verbum.org>
- */
-
-#ifndef __GSM_FAIL_WHALE_DIALOG_H__
-#define __GSM_FAIL_WHALE_DIALOG_H__
-
-#include <gtk/gtk.h>
-
-G_BEGIN_DECLS
-
-#define GSM_TYPE_FAIL_WHALE_DIALOG         (gsm_fail_whale_dialog_get_type ())
-#define GSM_FAIL_WHALE_DIALOG(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GSM_TYPE_FAIL_WHALE_DIALOG, GsmFailWhaleDialog))
-#define GSM_FAIL_WHALE_DIALOG_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GSM_TYPE_FAIL_WHALE_DIALOG, GsmFailWhaleDialogClass))
-#define GSM_IS_FAIL_WHALE_DIALOG(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GSM_TYPE_FAIL_WHALE_DIALOG))
-#define GSM_IS_FAIL_WHALE_DIALOG_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GSM_TYPE_FAIL_WHALE_DIALOG))
-#define GSM_FAIL_WHALE_DIALOG_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GSM_TYPE_FAIL_WHALE_DIALOG, GsmFailWhaleDialogClass))
-
-typedef struct _GsmFailWhaleDialog         GsmFailWhaleDialog;
-typedef struct _GsmFailWhaleDialogClass    GsmFailWhaleDialogClass;
-typedef struct _GsmFailWhaleDialogPrivate  GsmFailWhaleDialogPrivate;
-
-struct _GsmFailWhaleDialog
-{
-        GtkWindow                  parent;
-
-        GsmFailWhaleDialogPrivate *priv;
-};
-
-struct _GsmFailWhaleDialogClass
-{
-        GtkWindowClass  parent_class;
-};
-
-GType        gsm_fail_whale_dialog_get_type   (void) G_GNUC_CONST;
-
-G_END_DECLS
-
-#endif /* __GSM_FAIL_WHALE_DIALOG_H__ */
diff --git a/gnome-session/gsm-fail-whale.c b/gnome-session/gsm-fail-whale.c
deleted file mode 100644
index a76932d..0000000
--- a/gnome-session/gsm-fail-whale.c
+++ /dev/null
@@ -1,47 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- * gsm-fail-whale.c
- * Copyright (C) 2012 Red Hat, Inc
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#include <config.h>
-
-#include <glib/gi18n.h>
-#include <glib/gstdio.h>
-
-#include "gsm-fail-whale.h"
-
-void
-gsm_fail_whale_dialog_we_failed  (gboolean            debug_mode,
-                                  gboolean            allow_logout,
-                                  GsmShellExtensions *extensions)
-{
-        gint i;
-        gchar *argv[5];
-
-        i = 0;
-        argv[i++] = LIBEXECDIR "/gnome-session-failed";
-        if (debug_mode)
-                argv[i++] = "--debug";
-        if (allow_logout)
-                argv[i++] = "--allow-logout";
-        if (extensions != NULL && gsm_shell_extensions_n_extensions (extensions) > 0)
-                argv[i++] = "--extensions";
-        argv[i++] = NULL;
-
-        g_spawn_async (NULL, argv, NULL, 0, NULL, NULL, NULL, NULL);
-}
diff --git a/gnome-session/gsm-fail-whale.h b/gnome-session/gsm-fail-whale.h
deleted file mode 100644
index 0736ec4..0000000
--- a/gnome-session/gsm-fail-whale.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/* gsm-fail-whale.h
- * Copyright (C) 2012 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#ifndef __GSM_FAIL_WHALE_H___
-#define __GSM_FAIL_WHALE_H__
-
-#include <glib.h>
-
-#include "gsm-shell-extensions.h"
-
-G_BEGIN_DECLS
-
-void        gsm_fail_whale_dialog_we_failed  (gboolean            debug_mode,
-                                              gboolean            allow_logout,
-                                              GsmShellExtensions *extensions);
-
-G_END_DECLS
-
-#endif /* __GSM_FAIL_WHALE_H__ */
-
diff --git a/gnome-session/gsm-icon-names.h b/gnome-session/gsm-icon-names.h
deleted file mode 100644
index 84f0c36..0000000
--- a/gnome-session/gsm-icon-names.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2011 Novell, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#ifndef __GSM_ICON_NAMES_H__
-#define __GSM_ICON_NAMES_H__
-
-#define GSM_ICON_COMPUTER_FAIL       "computer-fail-symbolic"
-#define GSM_ICON_INHIBITOR_DEFAULT   "gnome-windows"
-#define GSM_ICON_LOGOUT              "system-log-out"
-#define GSM_ICON_SHUTDOWN            "system-shutdown"
-#define GSM_ICON_XSMP_DEFAULT        "system-run"
-
-#endif /*__GSM_ICON_NAMES_H__ */
diff --git a/gnome-session/gsm-inhibitor-flag.h b/gnome-session/gsm-inhibitor-flag.h
deleted file mode 100644
index dbe0288..0000000
--- a/gnome-session/gsm-inhibitor-flag.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#ifndef __GSM_INHIBITOR_FLAG_H__
-#define __GSM_INHIBITOR_FLAG_H__
-
-#include <glib-object.h>
-
-G_BEGIN_DECLS
-
-typedef enum {
-        GSM_INHIBITOR_FLAG_LOGOUT      = 1 << 0,
-        GSM_INHIBITOR_FLAG_SWITCH_USER = 1 << 1,
-        GSM_INHIBITOR_FLAG_SUSPEND     = 1 << 2,
-        GSM_INHIBITOR_FLAG_IDLE        = 1 << 3,
-        GSM_INHIBITOR_FLAG_AUTOMOUNT   = 1 << 4
-} GsmInhibitorFlag;
-
-G_END_DECLS
-
-#endif /* __GSM_INHIBITOR_FLAG_H__ */
diff --git a/gnome-session/gsm-inhibitor.c b/gnome-session/gsm-inhibitor.c
deleted file mode 100644
index 56525c5..0000000
--- a/gnome-session/gsm-inhibitor.c
+++ /dev/null
@@ -1,605 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#include "config.h"
-
-#include <fcntl.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <unistd.h>
-
-#include <dbus/dbus-glib.h>
-
-#include "gsm-inhibitor.h"
-#include "gsm-inhibitor-glue.h"
-
-#include "gsm-util.h"
-
-static guint32 inhibitor_serial = 1;
-
-#define GSM_INHIBITOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSM_TYPE_INHIBITOR, GsmInhibitorPrivate))
-
-struct GsmInhibitorPrivate
-{
-        char *id;
-        char *bus_name;
-        char *app_id;
-        char *client_id;
-        char *reason;
-        guint flags;
-        guint toplevel_xid;
-        guint cookie;
-        DBusGConnection *connection;
-};
-
-enum {
-        PROP_0,
-        PROP_BUS_NAME,
-        PROP_REASON,
-        PROP_APP_ID,
-        PROP_CLIENT_ID,
-        PROP_FLAGS,
-        PROP_TOPLEVEL_XID,
-        PROP_COOKIE
-};
-
-G_DEFINE_TYPE (GsmInhibitor, gsm_inhibitor, G_TYPE_OBJECT)
-
-GQuark
-gsm_inhibitor_error_quark (void)
-{
-        static GQuark ret = 0;
-        if (ret == 0) {
-                ret = g_quark_from_static_string ("gsm_inhibitor_error");
-        }
-
-        return ret;
-}
-
-#define ENUM_ENTRY(NAME, DESC) { NAME, "" #NAME "", DESC }
-
-GType
-gsm_inhibitor_error_get_type (void)
-{
-        static GType etype = 0;
-
-        if (etype == 0) {
-                static const GEnumValue values[] = {
-                        ENUM_ENTRY (GSM_INHIBITOR_ERROR_GENERAL, "GeneralError"),
-                        ENUM_ENTRY (GSM_INHIBITOR_ERROR_NOT_SET, "NotSet"),
-                        { 0, 0, 0 }
-                };
-
-                g_assert (GSM_INHIBITOR_NUM_ERRORS == G_N_ELEMENTS (values) - 1);
-
-                etype = g_enum_register_static ("GsmInhibitorError", values);
-        }
-
-        return etype;
-}
-
-static guint32
-get_next_inhibitor_serial (void)
-{
-        guint32 serial;
-
-        serial = inhibitor_serial++;
-
-        if ((gint32)inhibitor_serial < 0) {
-                inhibitor_serial = 1;
-        }
-
-        return serial;
-}
-
-static gboolean
-register_inhibitor (GsmInhibitor *inhibitor)
-{
-        GError *error;
-
-        error = NULL;
-        inhibitor->priv->connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
-        if (inhibitor->priv->connection == NULL) {
-                if (error != NULL) {
-                        g_critical ("error getting session bus: %s", error->message);
-                        g_error_free (error);
-                }
-                return FALSE;
-        }
-
-        dbus_g_connection_register_g_object (inhibitor->priv->connection, inhibitor->priv->id, G_OBJECT (inhibitor));
-
-        return TRUE;
-}
-
-static GObject *
-gsm_inhibitor_constructor (GType                  type,
-                           guint                  n_construct_properties,
-                           GObjectConstructParam *construct_properties)
-{
-        GsmInhibitor *inhibitor;
-        gboolean      res;
-
-        inhibitor = GSM_INHIBITOR (G_OBJECT_CLASS (gsm_inhibitor_parent_class)->constructor (type,
-                                                                                             n_construct_properties,
-                                                                                             construct_properties));
-
-        g_free (inhibitor->priv->id);
-        inhibitor->priv->id = g_strdup_printf ("/org/gnome/SessionManager/Inhibitor%u", get_next_inhibitor_serial ());
-        res = register_inhibitor (inhibitor);
-        if (! res) {
-                g_warning ("Unable to register inhibitor with session bus");
-        }
-
-        return G_OBJECT (inhibitor);
-}
-
-static void
-gsm_inhibitor_init (GsmInhibitor *inhibitor)
-{
-        inhibitor->priv = GSM_INHIBITOR_GET_PRIVATE (inhibitor);
-}
-
-static void
-gsm_inhibitor_set_bus_name (GsmInhibitor  *inhibitor,
-                            const char    *bus_name)
-{
-        g_return_if_fail (GSM_IS_INHIBITOR (inhibitor));
-
-        g_free (inhibitor->priv->bus_name);
-
-        if (bus_name != NULL) {
-                inhibitor->priv->bus_name = g_strdup (bus_name);
-        } else {
-                inhibitor->priv->bus_name = g_strdup ("");
-        }
-        g_object_notify (G_OBJECT (inhibitor), "bus-name");
-}
-
-static void
-gsm_inhibitor_set_app_id (GsmInhibitor  *inhibitor,
-                          const char    *app_id)
-{
-        g_return_if_fail (GSM_IS_INHIBITOR (inhibitor));
-
-        g_free (inhibitor->priv->app_id);
-
-        inhibitor->priv->app_id = g_strdup (app_id);
-        g_object_notify (G_OBJECT (inhibitor), "app-id");
-}
-
-static void
-gsm_inhibitor_set_client_id (GsmInhibitor  *inhibitor,
-                             const char    *client_id)
-{
-        g_return_if_fail (GSM_IS_INHIBITOR (inhibitor));
-
-        g_free (inhibitor->priv->client_id);
-
-        g_debug ("GsmInhibitor: setting client-id = %s", client_id);
-
-        if (client_id != NULL) {
-                inhibitor->priv->client_id = g_strdup (client_id);
-        } else {
-                inhibitor->priv->client_id = g_strdup ("");
-        }
-        g_object_notify (G_OBJECT (inhibitor), "client-id");
-}
-
-static void
-gsm_inhibitor_set_reason (GsmInhibitor  *inhibitor,
-                          const char    *reason)
-{
-        g_return_if_fail (GSM_IS_INHIBITOR (inhibitor));
-
-        g_free (inhibitor->priv->reason);
-
-        if (reason != NULL) {
-                inhibitor->priv->reason = g_strdup (reason);
-        } else {
-                inhibitor->priv->reason = g_strdup ("");
-        }
-        g_object_notify (G_OBJECT (inhibitor), "reason");
-}
-
-static void
-gsm_inhibitor_set_cookie (GsmInhibitor  *inhibitor,
-                          guint          cookie)
-{
-        g_return_if_fail (GSM_IS_INHIBITOR (inhibitor));
-
-        if (inhibitor->priv->cookie != cookie) {
-                inhibitor->priv->cookie = cookie;
-                g_object_notify (G_OBJECT (inhibitor), "cookie");
-        }
-}
-
-static void
-gsm_inhibitor_set_flags (GsmInhibitor  *inhibitor,
-                         guint          flags)
-{
-        g_return_if_fail (GSM_IS_INHIBITOR (inhibitor));
-
-        if (inhibitor->priv->flags != flags) {
-                inhibitor->priv->flags = flags;
-                g_object_notify (G_OBJECT (inhibitor), "flags");
-        }
-}
-
-static void
-gsm_inhibitor_set_toplevel_xid (GsmInhibitor  *inhibitor,
-                                guint          xid)
-{
-        g_return_if_fail (GSM_IS_INHIBITOR (inhibitor));
-
-        if (inhibitor->priv->toplevel_xid != xid) {
-                inhibitor->priv->toplevel_xid = xid;
-                g_object_notify (G_OBJECT (inhibitor), "toplevel-xid");
-        }
-}
-
-const char *
-gsm_inhibitor_peek_bus_name (GsmInhibitor  *inhibitor)
-{
-        g_return_val_if_fail (GSM_IS_INHIBITOR (inhibitor), NULL);
-
-        return inhibitor->priv->bus_name;
-}
-
-gboolean
-gsm_inhibitor_get_app_id (GsmInhibitor *inhibitor,
-                          char        **id,
-                          GError      **error)
-{
-        g_return_val_if_fail (GSM_IS_INHIBITOR (inhibitor), FALSE);
-
-        if (inhibitor->priv->app_id != NULL) {
-                *id = g_strdup (inhibitor->priv->app_id);
-        } else {
-                *id = g_strdup ("");
-        }
-
-        return TRUE;
-}
-
-gboolean
-gsm_inhibitor_get_client_id (GsmInhibitor *inhibitor,
-                             char        **id,
-                             GError      **error)
-{
-        g_return_val_if_fail (GSM_IS_INHIBITOR (inhibitor), FALSE);
-
-        /* object paths are not allowed to be NULL or blank */
-        if (IS_STRING_EMPTY (inhibitor->priv->client_id)) {
-                g_set_error (error,
-                             GSM_INHIBITOR_ERROR,
-                             GSM_INHIBITOR_ERROR_NOT_SET,
-                             "Value is not set");
-                return FALSE;
-        }
-
-        *id = g_strdup (inhibitor->priv->client_id);
-
-        g_debug ("GsmInhibitor: getting client-id = '%s'", *id);
-
-        return TRUE;
-}
-
-gboolean
-gsm_inhibitor_get_reason (GsmInhibitor *inhibitor,
-                          char        **reason,
-                          GError      **error)
-{
-        g_return_val_if_fail (GSM_IS_INHIBITOR (inhibitor), FALSE);
-
-        if (inhibitor->priv->reason != NULL) {
-                *reason = g_strdup (inhibitor->priv->reason);
-        } else {
-                *reason = g_strdup ("");
-        }
-
-        return TRUE;
-}
-
-gboolean
-gsm_inhibitor_get_flags (GsmInhibitor *inhibitor,
-                         guint        *flags,
-                         GError      **error)
-{
-        g_return_val_if_fail (GSM_IS_INHIBITOR (inhibitor), FALSE);
-
-        *flags = inhibitor->priv->flags;
-
-        return TRUE;
-}
-
-gboolean
-gsm_inhibitor_get_toplevel_xid (GsmInhibitor *inhibitor,
-                                guint        *xid,
-                                GError      **error)
-{
-        g_return_val_if_fail (GSM_IS_INHIBITOR (inhibitor), FALSE);
-
-        *xid = inhibitor->priv->toplevel_xid;
-
-        return TRUE;
-}
-
-const char *
-gsm_inhibitor_peek_id (GsmInhibitor *inhibitor)
-{
-        g_return_val_if_fail (GSM_IS_INHIBITOR (inhibitor), NULL);
-
-        return inhibitor->priv->id;
-}
-
-const char *
-gsm_inhibitor_peek_app_id (GsmInhibitor  *inhibitor)
-{
-        g_return_val_if_fail (GSM_IS_INHIBITOR (inhibitor), NULL);
-
-        return inhibitor->priv->app_id;
-}
-
-const char *
-gsm_inhibitor_peek_client_id (GsmInhibitor  *inhibitor)
-{
-        g_return_val_if_fail (GSM_IS_INHIBITOR (inhibitor), NULL);
-
-        return inhibitor->priv->client_id;
-}
-
-const char *
-gsm_inhibitor_peek_reason (GsmInhibitor  *inhibitor)
-{
-        g_return_val_if_fail (GSM_IS_INHIBITOR (inhibitor), NULL);
-
-        return inhibitor->priv->reason;
-}
-
-guint
-gsm_inhibitor_peek_flags (GsmInhibitor  *inhibitor)
-{
-        g_return_val_if_fail (GSM_IS_INHIBITOR (inhibitor), 0);
-
-        return inhibitor->priv->flags;
-}
-
-guint
-gsm_inhibitor_peek_toplevel_xid (GsmInhibitor  *inhibitor)
-{
-        g_return_val_if_fail (GSM_IS_INHIBITOR (inhibitor), 0);
-
-        return inhibitor->priv->toplevel_xid;
-}
-
-guint
-gsm_inhibitor_peek_cookie (GsmInhibitor  *inhibitor)
-{
-        g_return_val_if_fail (GSM_IS_INHIBITOR (inhibitor), 0);
-
-        return inhibitor->priv->cookie;
-}
-
-static void
-gsm_inhibitor_set_property (GObject       *object,
-                            guint          prop_id,
-                            const GValue  *value,
-                            GParamSpec    *pspec)
-{
-        GsmInhibitor *self;
-
-        self = GSM_INHIBITOR (object);
-
-        switch (prop_id) {
-        case PROP_BUS_NAME:
-                gsm_inhibitor_set_bus_name (self, g_value_get_string (value));
-                break;
-        case PROP_APP_ID:
-                gsm_inhibitor_set_app_id (self, g_value_get_string (value));
-                break;
-        case PROP_CLIENT_ID:
-                gsm_inhibitor_set_client_id (self, g_value_get_string (value));
-                break;
-        case PROP_REASON:
-                gsm_inhibitor_set_reason (self, g_value_get_string (value));
-                break;
-        case PROP_FLAGS:
-                gsm_inhibitor_set_flags (self, g_value_get_uint (value));
-                break;
-        case PROP_COOKIE:
-                gsm_inhibitor_set_cookie (self, g_value_get_uint (value));
-                break;
-        case PROP_TOPLEVEL_XID:
-                gsm_inhibitor_set_toplevel_xid (self, g_value_get_uint (value));
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_inhibitor_get_property (GObject    *object,
-                            guint       prop_id,
-                            GValue     *value,
-                            GParamSpec *pspec)
-{
-        GsmInhibitor *self;
-
-        self = GSM_INHIBITOR (object);
-
-        switch (prop_id) {
-        case PROP_BUS_NAME:
-                g_value_set_string (value, self->priv->bus_name);
-                break;
-        case PROP_APP_ID:
-                g_value_set_string (value, self->priv->app_id);
-                break;
-        case PROP_CLIENT_ID:
-                g_value_set_string (value, self->priv->client_id);
-                break;
-        case PROP_REASON:
-                g_value_set_string (value, self->priv->reason);
-                break;
-        case PROP_FLAGS:
-                g_value_set_uint (value, self->priv->flags);
-                break;
-        case PROP_COOKIE:
-                g_value_set_uint (value, self->priv->cookie);
-                break;
-        case PROP_TOPLEVEL_XID:
-                g_value_set_uint (value, self->priv->toplevel_xid);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_inhibitor_finalize (GObject *object)
-{
-        GsmInhibitor *inhibitor = (GsmInhibitor *) object;
-
-        g_free (inhibitor->priv->id);
-        g_free (inhibitor->priv->bus_name);
-        g_free (inhibitor->priv->app_id);
-        g_free (inhibitor->priv->client_id);
-        g_free (inhibitor->priv->reason);
-
-        G_OBJECT_CLASS (gsm_inhibitor_parent_class)->finalize (object);
-}
-
-static void
-gsm_inhibitor_class_init (GsmInhibitorClass *klass)
-{
-        GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-        object_class->finalize             = gsm_inhibitor_finalize;
-        object_class->constructor          = gsm_inhibitor_constructor;
-        object_class->get_property         = gsm_inhibitor_get_property;
-        object_class->set_property         = gsm_inhibitor_set_property;
-
-        g_object_class_install_property (object_class,
-                                         PROP_BUS_NAME,
-                                         g_param_spec_string ("bus-name",
-                                                              "bus-name",
-                                                              "bus-name",
-                                                              "",
-                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-        g_object_class_install_property (object_class,
-                                         PROP_APP_ID,
-                                         g_param_spec_string ("app-id",
-                                                              "app-id",
-                                                              "app-id",
-                                                              "",
-                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-        g_object_class_install_property (object_class,
-                                         PROP_CLIENT_ID,
-                                         g_param_spec_string ("client-id",
-                                                              "client-id",
-                                                              "client-id",
-                                                              "",
-                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-        g_object_class_install_property (object_class,
-                                         PROP_REASON,
-                                         g_param_spec_string ("reason",
-                                                              "reason",
-                                                              "reason",
-                                                              "",
-                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-        g_object_class_install_property (object_class,
-                                         PROP_FLAGS,
-                                         g_param_spec_uint ("flags",
-                                                            "flags",
-                                                            "flags",
-                                                            0,
-                                                            G_MAXINT,
-                                                            0,
-                                                            G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-        g_object_class_install_property (object_class,
-                                         PROP_TOPLEVEL_XID,
-                                         g_param_spec_uint ("toplevel-xid",
-                                                            "toplevel-xid",
-                                                            "toplevel-xid",
-                                                            0,
-                                                            G_MAXINT,
-                                                            0,
-                                                            G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-        g_object_class_install_property (object_class,
-                                         PROP_COOKIE,
-                                         g_param_spec_uint ("cookie",
-                                                            "cookie",
-                                                            "cookie",
-                                                            0,
-                                                            G_MAXINT,
-                                                            0,
-                                                            G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-
-        dbus_g_object_type_install_info (GSM_TYPE_INHIBITOR, &dbus_glib_gsm_inhibitor_object_info);
-        dbus_g_error_domain_register (GSM_INHIBITOR_ERROR, NULL, GSM_INHIBITOR_TYPE_ERROR);
-        g_type_class_add_private (klass, sizeof (GsmInhibitorPrivate));
-}
-
-GsmInhibitor *
-gsm_inhibitor_new (const char    *app_id,
-                   guint          toplevel_xid,
-                   guint          flags,
-                   const char    *reason,
-                   const char    *bus_name,
-                   guint          cookie)
-{
-        GsmInhibitor *inhibitor;
-
-        inhibitor = g_object_new (GSM_TYPE_INHIBITOR,
-                                  "app-id", app_id,
-                                  "reason", reason,
-                                  "bus-name", bus_name,
-                                  "flags", flags,
-                                  "toplevel-xid", toplevel_xid,
-                                  "cookie", cookie,
-                                  NULL);
-
-        return inhibitor;
-}
-
-GsmInhibitor *
-gsm_inhibitor_new_for_client (const char    *client_id,
-                              const char    *app_id,
-                              guint          flags,
-                              const char    *reason,
-                              const char    *bus_name,
-                              guint          cookie)
-{
-        GsmInhibitor *inhibitor;
-
-        inhibitor = g_object_new (GSM_TYPE_INHIBITOR,
-                                  "client-id", client_id,
-                                  "app-id", app_id,
-                                  "reason", reason,
-                                  "bus-name", bus_name,
-                                  "flags", flags,
-                                  "cookie", cookie,
-                                  NULL);
-
-        return inhibitor;
-}
diff --git a/gnome-session/gsm-inhibitor.h b/gnome-session/gsm-inhibitor.h
deleted file mode 100644
index 4f49e86..0000000
--- a/gnome-session/gsm-inhibitor.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#ifndef __GSM_INHIBITOR_H__
-#define __GSM_INHIBITOR_H__
-
-#include <glib-object.h>
-#include <sys/types.h>
-
-#include "gsm-inhibitor-flag.h"
-
-G_BEGIN_DECLS
-
-#define GSM_TYPE_INHIBITOR            (gsm_inhibitor_get_type ())
-#define GSM_INHIBITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSM_TYPE_INHIBITOR, GsmInhibitor))
-#define GSM_INHIBITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GSM_TYPE_INHIBITOR, GsmInhibitorClass))
-#define GSM_IS_INHIBITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSM_TYPE_INHIBITOR))
-#define GSM_IS_INHIBITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GSM_TYPE_INHIBITOR))
-#define GSM_INHIBITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GSM_TYPE_INHIBITOR, GsmInhibitorClass))
-
-typedef struct _GsmInhibitor        GsmInhibitor;
-typedef struct _GsmInhibitorClass   GsmInhibitorClass;
-
-typedef struct GsmInhibitorPrivate GsmInhibitorPrivate;
-
-struct _GsmInhibitor
-{
-        GObject              parent;
-        GsmInhibitorPrivate *priv;
-};
-
-struct _GsmInhibitorClass
-{
-        GObjectClass parent_class;
-};
-
-typedef enum
-{
-        GSM_INHIBITOR_ERROR_GENERAL = 0,
-        GSM_INHIBITOR_ERROR_NOT_SET,
-        GSM_INHIBITOR_NUM_ERRORS
-} GsmInhibitorError;
-
-#define GSM_INHIBITOR_ERROR gsm_inhibitor_error_quark ()
-GType          gsm_inhibitor_error_get_type       (void);
-#define GSM_INHIBITOR_TYPE_ERROR (gsm_inhibitor_error_get_type ())
-
-GQuark         gsm_inhibitor_error_quark          (void);
-
-GType          gsm_inhibitor_get_type             (void) G_GNUC_CONST;
-
-GsmInhibitor * gsm_inhibitor_new                  (const char    *app_id,
-                                                   guint          toplevel_xid,
-                                                   guint          flags,
-                                                   const char    *reason,
-                                                   const char    *bus_name,
-                                                   guint          cookie);
-GsmInhibitor * gsm_inhibitor_new_for_client       (const char    *client_id,
-                                                   const char    *app_id,
-                                                   guint          flags,
-                                                   const char    *reason,
-                                                   const char    *bus_name,
-                                                   guint          cookie);
-
-const char *   gsm_inhibitor_peek_id              (GsmInhibitor  *inhibitor);
-const char *   gsm_inhibitor_peek_app_id          (GsmInhibitor  *inhibitor);
-const char *   gsm_inhibitor_peek_client_id       (GsmInhibitor  *inhibitor);
-const char *   gsm_inhibitor_peek_reason          (GsmInhibitor  *inhibitor);
-const char *   gsm_inhibitor_peek_bus_name        (GsmInhibitor  *inhibitor);
-guint          gsm_inhibitor_peek_cookie          (GsmInhibitor  *inhibitor);
-guint          gsm_inhibitor_peek_flags           (GsmInhibitor  *inhibitor);
-guint          gsm_inhibitor_peek_toplevel_xid    (GsmInhibitor  *inhibitor);
-
-/* exported to bus */
-gboolean       gsm_inhibitor_get_app_id           (GsmInhibitor  *inhibitor,
-                                                   char         **id,
-                                                   GError       **error);
-gboolean       gsm_inhibitor_get_client_id        (GsmInhibitor  *inhibitor,
-                                                   char         **id,
-                                                   GError       **error);
-gboolean       gsm_inhibitor_get_reason           (GsmInhibitor  *inhibitor,
-                                                   char         **reason,
-                                                   GError       **error);
-gboolean       gsm_inhibitor_get_flags            (GsmInhibitor  *inhibitor,
-                                                   guint         *flags,
-                                                   GError       **error);
-gboolean       gsm_inhibitor_get_toplevel_xid     (GsmInhibitor  *inhibitor,
-                                                   guint         *xid,
-                                                   GError       **error);
-
-
-G_END_DECLS
-
-#endif /* __GSM_INHIBITOR_H__ */
diff --git a/gnome-session/gsm-manager-logout-mode.h b/gnome-session/gsm-manager-logout-mode.h
deleted file mode 100644
index 41b1883..0000000
--- a/gnome-session/gsm-manager-logout-mode.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2008 William Jon McCann <jmccann@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- */
-
-
-#ifndef __GSM_MANAGER_LOGOUT_MODE_H
-#define __GSM_MANAGER_LOGOUT_MODE_H
-
-G_BEGIN_DECLS
-
-typedef enum {
-        GSM_MANAGER_LOGOUT_MODE_NORMAL = 0,
-        GSM_MANAGER_LOGOUT_MODE_NO_CONFIRMATION,
-        GSM_MANAGER_LOGOUT_MODE_FORCE
-} GsmManagerLogoutMode;
-
-G_END_DECLS
-
-#endif /* __GSM_MANAGER_LOGOUT_MODE_H */
diff --git a/gnome-session/gsm-manager.c b/gnome-session/gsm-manager.c
deleted file mode 100644
index 17b971c..0000000
--- a/gnome-session/gsm-manager.c
+++ /dev/null
@@ -1,3863 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2007 Novell, Inc.
- * Copyright (C) 2008 Red Hat, Inc.
- * Copyright (C) 2008 William Jon McCann <jmccann@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- */
-
-#include "config.h"
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <string.h>
-#include <signal.h>
-#include <locale.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-
-#include <glib.h>
-#include <glib/gi18n.h>
-#include <glib/gstdio.h>
-#include <glib-object.h>
-#include <gio/gio.h>
-#include <dbus/dbus-glib.h>
-#include <dbus/dbus-glib-lowlevel.h>
-
-#include "gsm-manager.h"
-#include "gsm-manager-glue.h"
-
-#ifdef HAVE_SYSTEMD
-#include <systemd/sd-journal.h>
-#endif
-
-#include "gsm-store.h"
-#include "gsm-inhibitor.h"
-#include "gsm-presence.h"
-#include "gsm-shell.h"
-
-#include "gsm-xsmp-server.h"
-#include "gsm-xsmp-client.h"
-#include "gsm-dbus-client.h"
-
-#include "gsm-autostart-app.h"
-
-#include "gsm-util.h"
-#include "gsm-icon-names.h"
-#include "gsm-system.h"
-#include "gsm-session-save.h"
-#include "gsm-shell-extensions.h"
-#include "gsm-fail-whale.h"
-
-#define GSM_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSM_TYPE_MANAGER, GsmManagerPrivate))
-
-/* UUIDs for log messages */
-#define GSM_MANAGER_STARTUP_SUCCEEDED_MSGID     "0ce153587afa4095832d233c17a88001"
-#define GSM_MANAGER_UNRECOVERABLE_FAILURE_MSGID "10dd2dc188b54a5e98970f56499d1f73"
-
-#define GSM_MANAGER_DBUS_PATH "/org/gnome/SessionManager"
-#define GSM_MANAGER_DBUS_NAME "org.gnome.SessionManager"
-
-/* Probably about the longest amount of time someone could reasonably
- * want to wait, at least for something happening more than once.
- * We can get deployed on very slow media though like CDROM devices,
- * often with complex stacking/compressing filesystems on top, which
- * is not a recipie for speed.   Particularly now that we throw up
- * a fail whale if required components don't show up quickly enough,
- * let's make this fairly long.
- */
-#define GSM_MANAGER_PHASE_TIMEOUT 90 /* seconds */
-
-#define GDM_FLEXISERVER_COMMAND "gdmflexiserver"
-#define GDM_FLEXISERVER_ARGS    "--startnew Standard"
-
-#define SESSION_SCHEMA            "org.gnome.desktop.session"
-#define KEY_IDLE_DELAY            "idle-delay"
-#define KEY_SESSION_NAME          "session-name"
-
-#define GSM_MANAGER_SCHEMA        "org.gnome.SessionManager"
-#define KEY_AUTOSAVE              "auto-save-session"
-#define KEY_AUTOSAVE_ONE_SHOT     "auto-save-session-one-shot"
-#define KEY_LOGOUT_PROMPT         "logout-prompt"
-#define KEY_SHOW_FALLBACK_WARNING "show-fallback-warning"
-
-#define SCREENSAVER_SCHEMA        "org.gnome.desktop.screensaver"
-#define KEY_SLEEP_LOCK            "lock-enabled"
-
-#define LOCKDOWN_SCHEMA           "org.gnome.desktop.lockdown"
-#define KEY_DISABLE_LOG_OUT       "disable-log-out"
-#define KEY_DISABLE_USER_SWITCHING "disable-user-switching"
-
-static void app_registered (GsmApp     *app, GsmManager *manager);
-
-typedef enum
-{
-        GSM_MANAGER_LOGOUT_NONE,
-        GSM_MANAGER_LOGOUT_LOGOUT,
-        GSM_MANAGER_LOGOUT_REBOOT,
-        GSM_MANAGER_LOGOUT_REBOOT_INTERACT,
-        GSM_MANAGER_LOGOUT_SHUTDOWN,
-        GSM_MANAGER_LOGOUT_SHUTDOWN_INTERACT,
-} GsmManagerLogoutType;
-
-struct GsmManagerPrivate
-{
-        gboolean                failsafe;
-        GsmStore               *clients;
-        GsmStore               *inhibitors;
-        GsmInhibitorFlag        inhibited_actions;
-        GsmStore               *apps;
-        GsmPresence            *presence;
-        GsmXsmpServer          *xsmp_server;
-
-        char                   *session_name;
-        gboolean                is_fallback_session : 1;
-
-        /* Current status */
-        GsmManagerPhase         phase;
-        guint                   phase_timeout_id;
-        GSList                 *required_apps;
-        GSList                 *pending_apps;
-        GsmManagerLogoutMode    logout_mode;
-        GSList                 *query_clients;
-        guint                   query_timeout_id;
-        /* This is used for GSM_MANAGER_PHASE_END_SESSION only at the moment,
-         * since it uses a sublist of all running client that replied in a
-         * specific way */
-        GSList                 *next_query_clients;
-        /* This is the action that will be done just before we exit */
-        GsmManagerLogoutType    logout_type;
-
-        /* List of clients which were disconnected due to disabled condition
-         * and shouldn't be automatically restarted */
-        GSList                 *condition_clients;
-
-        GSList                 *pending_end_session_tasks;
-        GCancellable           *end_session_cancellable;
-
-        GSettings              *settings;
-        GSettings              *session_settings;
-        GSettings              *screensaver_settings;
-        GSettings              *lockdown_settings;
-
-        GsmSystem              *system;
-        DBusGProxy             *bus_proxy;
-        DBusGConnection        *connection;
-        gboolean                dbus_disconnected : 1;
-
-        GsmShell               *shell;
-        guint                   shell_end_session_dialog_canceled_id;
-        guint                   shell_end_session_dialog_open_failed_id;
-        guint                   shell_end_session_dialog_confirmed_logout_id;
-        guint                   shell_end_session_dialog_confirmed_shutdown_id;
-        guint                   shell_end_session_dialog_confirmed_reboot_id;
-};
-
-enum {
-        PROP_0,
-        PROP_CLIENT_STORE,
-        PROP_INHIBITED_ACTIONS,
-        PROP_SESSION_NAME,
-        PROP_SESSION_IS_ACTIVE,
-        PROP_FALLBACK,
-        PROP_FAILSAFE
-};
-
-enum {
-        PHASE_CHANGED,
-        CLIENT_ADDED,
-        CLIENT_REMOVED,
-        INHIBITOR_ADDED,
-        INHIBITOR_REMOVED,
-        SESSION_RUNNING,
-        SESSION_OVER,
-        LAST_SIGNAL
-};
-
-static guint signals [LAST_SIGNAL] = { 0 };
-
-static void     gsm_manager_class_init  (GsmManagerClass *klass);
-static void     gsm_manager_init        (GsmManager      *manager);
-
-static gboolean auto_save_is_enabled (GsmManager *manager);
-static void     maybe_save_session   (GsmManager *manager);
-
-static gboolean _log_out_is_locked_down     (GsmManager *manager);
-
-static void     _handle_client_end_session_response (GsmManager *manager,
-                                                     GsmClient  *client,
-                                                     gboolean    is_ok,
-                                                     gboolean    do_last,
-                                                     gboolean    cancel,
-                                                     const char *reason);
-static void     show_shell_end_session_dialog (GsmManager                   *manager,
-                                               GsmShellEndSessionDialogType  type);
-static gpointer manager_object = NULL;
-
-G_DEFINE_TYPE (GsmManager, gsm_manager, G_TYPE_OBJECT)
-
-GQuark
-gsm_manager_error_quark (void)
-{
-        static GQuark ret = 0;
-        if (ret == 0) {
-                ret = g_quark_from_static_string ("gsm_manager_error");
-        }
-
-        return ret;
-}
-
-#define ENUM_ENTRY(NAME, DESC) { NAME, "" #NAME "", DESC }
-
-GType
-gsm_manager_error_get_type (void)
-{
-        static GType etype = 0;
-
-        if (etype == 0) {
-                static const GEnumValue values[] = {
-                        ENUM_ENTRY (GSM_MANAGER_ERROR_GENERAL, "GeneralError"),
-                        ENUM_ENTRY (GSM_MANAGER_ERROR_NOT_IN_INITIALIZATION, "NotInInitialization"),
-                        ENUM_ENTRY (GSM_MANAGER_ERROR_NOT_IN_RUNNING, "NotInRunning"),
-                        ENUM_ENTRY (GSM_MANAGER_ERROR_ALREADY_REGISTERED, "AlreadyRegistered"),
-                        ENUM_ENTRY (GSM_MANAGER_ERROR_NOT_REGISTERED, "NotRegistered"),
-                        ENUM_ENTRY (GSM_MANAGER_ERROR_INVALID_OPTION, "InvalidOption"),
-                        ENUM_ENTRY (GSM_MANAGER_ERROR_LOCKED_DOWN, "LockedDown"),
-                        { 0, 0, 0 }
-                };
-
-                g_assert (GSM_MANAGER_NUM_ERRORS == G_N_ELEMENTS (values) - 1);
-
-                etype = g_enum_register_static ("GsmManagerError", values);
-        }
-
-        return etype;
-}
-
-static gboolean
-start_app_or_warn (GsmManager *manager,
-                   GsmApp     *app)
-{
-        gboolean res;
-        GError *error = NULL;
-
-        g_debug ("GsmManager: starting app '%s'", gsm_app_peek_id (app));
-
-        res = gsm_app_start (app, &error);
-        if (error != NULL) {
-                g_warning ("Failed to start app: %s", error->message);
-                g_clear_error (&error);
-        }
-        return res;
-}
-
-static gboolean
-is_app_required (GsmManager *manager,
-                 GsmApp     *app)
-{
-        return g_slist_find (manager->priv->required_apps, app) != NULL;
-}
-
-static void
-on_required_app_failure (GsmManager  *manager,
-                         GsmApp      *app)
-{
-        const gchar *app_id;
-        gboolean allow_logout;
-        GsmShellExtensions *extensions;
-
-        app_id = gsm_app_peek_app_id (app);
-
-        if (g_str_equal (app_id, "gnome-shell.desktop")) {
-                extensions = g_object_new (GSM_TYPE_SHELL_EXTENSIONS, NULL);
-                gsm_shell_extensions_disable_all (extensions);
-        } else {
-                extensions = NULL;
-        }
-
-        if (gsm_system_is_login_session (manager->priv->system)) {
-                allow_logout = FALSE;
-        } else {
-                allow_logout = !_log_out_is_locked_down (manager);
-        }
-
-#ifdef HAVE_SYSTEMD
-        sd_journal_send ("MESSAGE_ID=%s", GSM_MANAGER_UNRECOVERABLE_FAILURE_MSGID,
-                         "PRIORITY=%d", 3,
-                         "MESSAGE=Unrecoverable failure in required component %s", app_id,
-                         NULL);
-#endif
-
-        gsm_fail_whale_dialog_we_failed (FALSE,
-                                         allow_logout,
-                                         extensions);
-}
-
-static void
-on_display_server_failure (GsmManager *manager,
-                           GsmApp     *app)
-{
-        const gchar *app_id;
-        gboolean allow_logout;
-        GsmShellExtensions *extensions;
-
-        app_id = gsm_app_peek_app_id (app);
-
-        if (g_str_equal (app_id, "gnome-shell-wayland.desktop")) {
-                extensions = g_object_new (GSM_TYPE_SHELL_EXTENSIONS, NULL);
-                gsm_shell_extensions_disable_all (extensions);
-
-                g_object_unref (extensions);
-        } else {
-                extensions = NULL;
-        }
-
-#ifdef HAVE_SYSTEMD
-        sd_journal_send ("MESSAGE_ID=%s", GSM_MANAGER_UNRECOVERABLE_FAILURE_MSGID,
-                         "PRIORITY=%d", 3,
-                         "MESSAGE=Unrecoverable failure in required component %s", app_id,
-                         NULL);
-#endif
-
-        gsm_quit ();
-}
-
-static gboolean
-_debug_client (const char *id,
-               GsmClient  *client,
-               GsmManager *manager)
-{
-        g_debug ("GsmManager: Client %s", gsm_client_peek_id (client));
-        return FALSE;
-}
-
-static void
-debug_clients (GsmManager *manager)
-{
-        gsm_store_foreach (manager->priv->clients,
-                           (GsmStoreFunc)_debug_client,
-                           manager);
-}
-
-static gboolean
-_debug_inhibitor (const char    *id,
-                  GsmInhibitor  *inhibitor,
-                  GsmManager    *manager)
-{
-        g_debug ("GsmManager: Inhibitor app:%s client:%s bus-name:%s reason:%s",
-                 gsm_inhibitor_peek_app_id (inhibitor),
-                 gsm_inhibitor_peek_client_id (inhibitor),
-                 gsm_inhibitor_peek_bus_name (inhibitor),
-                 gsm_inhibitor_peek_reason (inhibitor));
-        return FALSE;
-}
-
-static void
-debug_inhibitors (GsmManager *manager)
-{
-        gsm_store_foreach (manager->priv->inhibitors,
-                           (GsmStoreFunc)_debug_inhibitor,
-                           manager);
-}
-
-static gboolean
-_find_by_cookie (const char   *id,
-                 GsmInhibitor *inhibitor,
-                 guint        *cookie_ap)
-{
-        guint cookie_b;
-
-        cookie_b = gsm_inhibitor_peek_cookie (inhibitor);
-
-        return (*cookie_ap == cookie_b);
-}
-
-static gboolean
-_client_has_startup_id (const char *id,
-                        GsmClient  *client,
-                        const char *startup_id_a)
-{
-        const char *startup_id_b;
-
-        startup_id_b = gsm_client_peek_startup_id (client);
-        if (IS_STRING_EMPTY (startup_id_b)) {
-                return FALSE;
-        }
-
-        return (strcmp (startup_id_a, startup_id_b) == 0);
-}
-
-static void
-app_condition_changed (GsmApp     *app,
-                       gboolean    condition,
-                       GsmManager *manager)
-{
-        GsmClient *client;
-
-        g_debug ("GsmManager: app:%s condition changed condition:%d",
-                 gsm_app_peek_id (app),
-                 condition);
-
-        client = (GsmClient *)gsm_store_find (manager->priv->clients,
-                                              (GsmStoreFunc)_client_has_startup_id,
-                                              (char *)gsm_app_peek_startup_id (app));
-
-        if (condition) {
-                if (!gsm_app_is_running (app) && client == NULL) {
-                        start_app_or_warn (manager, app);
-                } else {
-                        g_debug ("GsmManager: not starting - app still running '%s'", gsm_app_peek_id (app));
-                }
-        } else {
-                GError  *error;
-                gboolean res;
-
-                if (client != NULL) {
-                        /* Kill client in case condition if false and make sure it won't
-                         * be automatically restarted by adding the client to
-                         * condition_clients */
-                        manager->priv->condition_clients =
-                                g_slist_prepend (manager->priv->condition_clients, client);
-
-                        g_debug ("GsmManager: stopping client %s for app", gsm_client_peek_id (client));
-
-                        error = NULL;
-                        res = gsm_client_stop (client, &error);
-                        if (! res) {
-                                g_warning ("Not able to stop app client from its condition: %s",
-                                           error->message);
-                                g_error_free (error);
-                        }
-                } else {
-                        g_debug ("GsmManager: stopping app %s", gsm_app_peek_id (app));
-
-                        /* If we don't have a client then we should try to kill the app */
-                        error = NULL;
-                        res = gsm_app_stop (app, &error);
-                        if (! res) {
-                                g_warning ("Not able to stop app from its condition: %s",
-                                           error->message);
-                                g_error_free (error);
-                        }
-                }
-        }
-}
-
-static const char *
-phase_num_to_name (guint phase)
-{
-        const char *name;
-
-        switch (phase) {
-        case GSM_MANAGER_PHASE_STARTUP:
-                name = "STARTUP";
-                break;
-        case GSM_MANAGER_PHASE_EARLY_INITIALIZATION:
-                name = "EARLY_INITIALIZATION";
-                break;
-        case GSM_MANAGER_PHASE_DISPLAY_SERVER:
-                name = "DISPLAY_SERVER";
-                break;
-        case GSM_MANAGER_PHASE_INITIALIZATION:
-                name = "INITIALIZATION";
-                break;
-        case GSM_MANAGER_PHASE_WINDOW_MANAGER:
-                name = "WINDOW_MANAGER";
-                break;
-        case GSM_MANAGER_PHASE_PANEL:
-                name = "PANEL";
-                break;
-        case GSM_MANAGER_PHASE_DESKTOP:
-                name = "DESKTOP";
-                break;
-        case GSM_MANAGER_PHASE_APPLICATION:
-                name = "APPLICATION";
-                break;
-        case GSM_MANAGER_PHASE_RUNNING:
-                name = "RUNNING";
-                break;
-        case GSM_MANAGER_PHASE_QUERY_END_SESSION:
-                name = "QUERY_END_SESSION";
-                break;
-        case GSM_MANAGER_PHASE_END_SESSION:
-                name = "END_SESSION";
-                break;
-        case GSM_MANAGER_PHASE_EXIT:
-                name = "EXIT";
-                break;
-        default:
-                g_assert_not_reached ();
-                break;
-        }
-
-        return name;
-}
-
-static void start_phase (GsmManager *manager);
-
-static void
-gsm_manager_quit (GsmManager *manager)
-{
-        /* See the comment in request_reboot() for some more details about how
-         * this works. */
-
-        switch (manager->priv->logout_type) {
-        case GSM_MANAGER_LOGOUT_LOGOUT:
-                gsm_quit ();
-                break;
-        case GSM_MANAGER_LOGOUT_REBOOT:
-        case GSM_MANAGER_LOGOUT_REBOOT_INTERACT:
-                gsm_system_complete_shutdown (manager->priv->system);
-                break;
-        case GSM_MANAGER_LOGOUT_SHUTDOWN:
-        case GSM_MANAGER_LOGOUT_SHUTDOWN_INTERACT:
-                gsm_system_complete_shutdown (manager->priv->system);
-                break;
-        default:
-                g_assert_not_reached ();
-                break;
-        }
-}
-
-static gboolean do_query_end_session_exit (GsmManager *manager);
-
-static void
-end_phase (GsmManager *manager)
-{
-        gboolean start_next_phase = TRUE;
-
-        g_debug ("GsmManager: ending phase %s",
-                 phase_num_to_name (manager->priv->phase));
-
-        g_slist_free (manager->priv->pending_apps);
-        manager->priv->pending_apps = NULL;
-
-        g_slist_free (manager->priv->query_clients);
-        manager->priv->query_clients = NULL;
-
-        g_slist_free (manager->priv->next_query_clients);
-        manager->priv->next_query_clients = NULL;
-
-        if (manager->priv->query_timeout_id > 0) {
-                g_source_remove (manager->priv->query_timeout_id);
-                manager->priv->query_timeout_id = 0;
-        }
-        if (manager->priv->phase_timeout_id > 0) {
-                g_source_remove (manager->priv->phase_timeout_id);
-                manager->priv->phase_timeout_id = 0;
-        }
-
-        switch (manager->priv->phase) {
-        case GSM_MANAGER_PHASE_STARTUP:
-        case GSM_MANAGER_PHASE_EARLY_INITIALIZATION:
-        case GSM_MANAGER_PHASE_DISPLAY_SERVER:
-        case GSM_MANAGER_PHASE_INITIALIZATION:
-        case GSM_MANAGER_PHASE_WINDOW_MANAGER:
-        case GSM_MANAGER_PHASE_PANEL:
-        case GSM_MANAGER_PHASE_DESKTOP:
-        case GSM_MANAGER_PHASE_APPLICATION:
-                break;
-        case GSM_MANAGER_PHASE_RUNNING:
-                if (_log_out_is_locked_down (manager)) {
-                        g_warning ("Unable to logout: Logout has been locked down");
-                        start_next_phase = FALSE;
-                }
-                break;
-        case GSM_MANAGER_PHASE_QUERY_END_SESSION:
-                if (!do_query_end_session_exit (manager))
-                        start_next_phase = FALSE;
-                break;
-        case GSM_MANAGER_PHASE_END_SESSION:
-                maybe_save_session (manager);
-                break;
-        case GSM_MANAGER_PHASE_EXIT:
-                start_next_phase = FALSE;
-                gsm_manager_quit (manager);
-                break;
-        default:
-                g_assert_not_reached ();
-                break;
-        }
-
-        if (start_next_phase) {
-                manager->priv->phase++;
-                start_phase (manager);
-        }
-}
-
-static void
-app_event_during_startup (GsmManager *manager,
-                          GsmApp     *app)
-{
-        if (!(manager->priv->phase < GSM_MANAGER_PHASE_APPLICATION))
-                return;
-
-        manager->priv->pending_apps = g_slist_remove (manager->priv->pending_apps, app);
-
-        if (manager->priv->pending_apps == NULL) {
-                if (manager->priv->phase_timeout_id > 0) {
-                        g_source_remove (manager->priv->phase_timeout_id);
-                        manager->priv->phase_timeout_id = 0;
-                }
-
-                end_phase (manager);
-        }
-}
-
-static gboolean
-is_app_display_server (GsmManager *manager,
-                       GsmApp     *app)
-{
-        GsmManagerPhase phase;
-
-        phase = gsm_app_peek_phase (app);
-
-        return (phase == GSM_MANAGER_PHASE_DISPLAY_SERVER &&
-                is_app_required (manager, app));
-}
-
-static void
-_restart_app (GsmManager *manager,
-              GsmApp     *app)
-{
-        GError *error = NULL;
-
-        if (is_app_display_server (manager, app)) {
-                on_display_server_failure (manager, app);
-                return;
-        }
-
-        if (!gsm_app_restart (app, &error)) {
-                if (is_app_required (manager, app)) {
-                        on_required_app_failure (manager, app);
-                } else {
-                        g_warning ("Error on restarting session managed app: %s", error->message);
-                }
-                g_clear_error (&error);
-
-                app_event_during_startup (manager, app);
-        }
-}
-
-static void
-app_died (GsmApp     *app,
-          int         signal,
-          GsmManager *manager)
-{
-        g_warning ("Application '%s' killed by signal %d", gsm_app_peek_app_id (app), signal);
-
-        if (gsm_app_peek_autorestart (app)) {
-                g_debug ("Component '%s' is autorestart, ignoring died signal",
-                         gsm_app_peek_app_id (app));
-                return;
-        }
-
-        _restart_app (manager, app);
-
-        /* For now, we don't do anything with crashes from
-         * non-required apps after they hit the restart limit.
-         *
-         * Note that both required and not-required apps will be
-         * caught by ABRT/apport type infrastructure, and it'd be
-         * better to pick up the crash from there and do something
-         * un-intrusive about it generically.
-         */
-}
-
-static void
-app_exited (GsmApp     *app,
-            guchar      exit_code,
-            GsmManager *manager)
-{
-        if (exit_code != 0)
-                g_warning ("App '%s' exited with code %d", gsm_app_peek_app_id (app), exit_code);
-        else
-                g_debug ("App %s exited successfully", gsm_app_peek_app_id (app));
-
-        /* Consider that non-success exit status means "crash" for required components */
-        if (exit_code != 0 && is_app_required (manager, app)) {
-                if (gsm_app_peek_autorestart (app)) {
-                        g_debug ("Component '%s' is autorestart, ignoring non-successful exit",
-                                 gsm_app_peek_app_id (app));
-                        return;
-                }
-
-                _restart_app (manager, app);
-        } else {
-                app_event_during_startup (manager, app);
-        }
-}
-
-static void
-app_registered (GsmApp     *app,
-                GsmManager *manager)
-{
-        g_debug ("App %s registered", gsm_app_peek_app_id (app));
-
-        app_event_during_startup (manager, app);
-}
-
-static gboolean
-_client_failed_to_stop (const char *id,
-                        GsmClient  *client,
-                        gpointer    user_data)
-{
-        g_debug ("GsmManager: client failed to stop: %s, %s", gsm_client_peek_id (client), gsm_client_peek_app_id (client));
-        return FALSE;
-}
-
-static gboolean
-on_phase_timeout (GsmManager *manager)
-{
-        GSList *a;
-
-        manager->priv->phase_timeout_id = 0;
-
-        switch (manager->priv->phase) {
-        case GSM_MANAGER_PHASE_STARTUP:
-        case GSM_MANAGER_PHASE_EARLY_INITIALIZATION:
-        case GSM_MANAGER_PHASE_DISPLAY_SERVER:
-        case GSM_MANAGER_PHASE_INITIALIZATION:
-        case GSM_MANAGER_PHASE_WINDOW_MANAGER:
-        case GSM_MANAGER_PHASE_PANEL:
-        case GSM_MANAGER_PHASE_DESKTOP:
-        case GSM_MANAGER_PHASE_APPLICATION:
-                for (a = manager->priv->pending_apps; a; a = a->next) {
-                        GsmApp *app = a->data;
-                        g_warning ("Application '%s' failed to register before timeout",
-                                   gsm_app_peek_app_id (app));
-                        if (is_app_required (manager, app))
-                                on_required_app_failure (manager, app);
-                }
-                break;
-        case GSM_MANAGER_PHASE_RUNNING:
-                break;
-        case GSM_MANAGER_PHASE_QUERY_END_SESSION:
-        case GSM_MANAGER_PHASE_END_SESSION:
-                break;
-        case GSM_MANAGER_PHASE_EXIT:
-                gsm_store_foreach (manager->priv->clients,
-                                   (GsmStoreFunc)_client_failed_to_stop,
-                                   NULL);
-                break;
-        default:
-                g_assert_not_reached ();
-                break;
-        }
-
-        end_phase (manager);
-
-        return FALSE;
-}
-
-static gboolean
-_start_app (const char *id,
-            GsmApp     *app,
-            GsmManager *manager)
-{
-        if (gsm_app_peek_phase (app) != manager->priv->phase) {
-                goto out;
-        }
-
-        /* Keep track of app autostart condition in order to react
-         * accordingly in the future. */
-        g_signal_connect (app,
-                          "condition-changed",
-                          G_CALLBACK (app_condition_changed),
-                          manager);
-
-        if (gsm_app_peek_is_disabled (app)
-            || gsm_app_peek_is_conditionally_disabled (app)) {
-                g_debug ("GsmManager: Skipping disabled app: %s", id);
-                goto out;
-        }
-
-        if (!start_app_or_warn (manager, app))
-                goto out;
-
-        if (manager->priv->phase < GSM_MANAGER_PHASE_APPLICATION) {
-                /* Historical note - apparently,
-                 * e.g. gnome-settings-daemon used to "daemonize", and
-                 * so gnome-session assumes process exit means "ok
-                 * we're done".  Of course this is broken, we don't
-                 * even distinguish between exit code 0 versus not-0,
-                 * nor do we have any metadata which tells us a
-                 * process is going to "daemonize" or not (and
-                 * basically nothing should be anyways).
-                 */
-                g_signal_connect (app,
-                                  "exited",
-                                  G_CALLBACK (app_exited),
-                                  manager);
-                g_signal_connect (app,
-                                  "registered",
-                                  G_CALLBACK (app_registered),
-                                  manager);
-                g_signal_connect (app,
-                                  "died",
-                                  G_CALLBACK (app_died),
-                                  manager);
-                manager->priv->pending_apps = g_slist_prepend (manager->priv->pending_apps, app);
-        }
- out:
-        return FALSE;
-}
-
-static void
-do_phase_startup (GsmManager *manager)
-{
-        gsm_store_foreach (manager->priv->apps,
-                           (GsmStoreFunc)_start_app,
-                           manager);
-
-        if (manager->priv->pending_apps != NULL) {
-                if (manager->priv->phase < GSM_MANAGER_PHASE_APPLICATION) {
-                        manager->priv->phase_timeout_id = g_timeout_add_seconds (GSM_MANAGER_PHASE_TIMEOUT,
-                                                                                 (GSourceFunc)on_phase_timeout,
-                                                                                 manager);
-                }
-        } else {
-                end_phase (manager);
-        }
-}
-
-typedef struct {
-        GsmManager *manager;
-        guint       flags;
-} ClientEndSessionData;
-
-
-static gboolean
-_client_end_session (GsmClient            *client,
-                     ClientEndSessionData *data)
-{
-        gboolean ret;
-        GError  *error;
-
-        error = NULL;
-        ret = gsm_client_end_session (client, data->flags, &error);
-        if (! ret) {
-                g_warning ("Unable to query client: %s", error->message);
-                g_error_free (error);
-                /* FIXME: what should we do if we can't communicate with client? */
-        } else {
-                g_debug ("GsmManager: adding client to end-session clients: %s", gsm_client_peek_id (client));
-                data->manager->priv->query_clients = g_slist_prepend (data->manager->priv->query_clients,
-                                                                      client);
-        }
-
-        return FALSE;
-}
-
-static gboolean
-_client_end_session_helper (const char           *id,
-                            GsmClient            *client,
-                            ClientEndSessionData *data)
-{
-        return _client_end_session (client, data);
-}
-
-static void
-complete_end_session_tasks (GsmManager *manager)
-{
-        GSList *l;
-
-        for (l = manager->priv->pending_end_session_tasks;
-             l != NULL;
-             l = l->next) {
-                GTask *task = G_TASK (l->data);
-                if (!g_task_return_error_if_cancelled (task))
-                    g_task_return_boolean (task, TRUE);
-        }
-
-        g_slist_free_full (manager->priv->pending_end_session_tasks,
-                           (GDestroyNotify) g_object_unref);
-        manager->priv->pending_end_session_tasks = NULL;
-}
-
-static void
-do_phase_end_session (GsmManager *manager)
-{
-        ClientEndSessionData data;
-
-        complete_end_session_tasks (manager);
-
-        data.manager = manager;
-        data.flags = 0;
-
-        if (manager->priv->logout_mode == GSM_MANAGER_LOGOUT_MODE_FORCE) {
-                data.flags |= GSM_CLIENT_END_SESSION_FLAG_FORCEFUL;
-        }
-        if (auto_save_is_enabled (manager)) {
-                data.flags |= GSM_CLIENT_END_SESSION_FLAG_SAVE;
-        }
-
-        if (manager->priv->phase_timeout_id > 0) {
-                g_source_remove (manager->priv->phase_timeout_id);
-                manager->priv->phase_timeout_id = 0;
-        }
-
-        if (gsm_store_size (manager->priv->clients) > 0) {
-                manager->priv->phase_timeout_id = g_timeout_add_seconds (GSM_MANAGER_PHASE_TIMEOUT,
-                                                                         (GSourceFunc)on_phase_timeout,
-                                                                         manager);
-
-                gsm_store_foreach (manager->priv->clients,
-                                   (GsmStoreFunc)_client_end_session_helper,
-                                   &data);
-        } else {
-                end_phase (manager);
-        }
-}
-
-static void
-do_phase_end_session_part_2 (GsmManager *manager)
-{
-        ClientEndSessionData data;
-
-        data.manager = manager;
-        data.flags = 0;
-
-        if (manager->priv->logout_mode == GSM_MANAGER_LOGOUT_MODE_FORCE) {
-                data.flags |= GSM_CLIENT_END_SESSION_FLAG_FORCEFUL;
-        }
-        if (auto_save_is_enabled (manager)) {
-                data.flags |= GSM_CLIENT_END_SESSION_FLAG_SAVE;
-        }
-        data.flags |= GSM_CLIENT_END_SESSION_FLAG_LAST;
-
-        /* keep the timeout that was started at the beginning of the
-         * GSM_MANAGER_PHASE_END_SESSION phase */
-
-        if (g_slist_length (manager->priv->next_query_clients) > 0) {
-                g_slist_foreach (manager->priv->next_query_clients,
-                                 (GFunc)_client_end_session,
-                                 &data);
-
-                g_slist_free (manager->priv->next_query_clients);
-                manager->priv->next_query_clients = NULL;
-        } else {
-                end_phase (manager);
-        }
-}
-
-static gboolean
-_client_stop (const char *id,
-              GsmClient  *client,
-              gpointer    user_data)
-{
-        gboolean ret;
-        GError  *error;
-
-        error = NULL;
-        ret = gsm_client_stop (client, &error);
-        if (! ret) {
-                g_warning ("Unable to stop client: %s", error->message);
-                g_error_free (error);
-                /* FIXME: what should we do if we can't communicate with client? */
-        } else {
-                g_debug ("GsmManager: stopped client: %s", gsm_client_peek_id (client));
-        }
-
-        return FALSE;
-}
-
-static void
-do_phase_exit (GsmManager *manager)
-{
-        if (gsm_store_size (manager->priv->clients) > 0) {
-                manager->priv->phase_timeout_id = g_timeout_add_seconds (GSM_MANAGER_PHASE_TIMEOUT,
-                                                                         (GSourceFunc)on_phase_timeout,
-                                                                         manager);
-
-                gsm_store_foreach (manager->priv->clients,
-                                   (GsmStoreFunc)_client_stop,
-                                   NULL);
-        } else {
-                end_phase (manager);
-        }
-}
-
-static gboolean
-_client_query_end_session (const char           *id,
-                           GsmClient            *client,
-                           ClientEndSessionData *data)
-{
-        gboolean ret;
-        GError  *error;
-
-        error = NULL;
-        ret = gsm_client_query_end_session (client, data->flags, &error);
-        if (! ret) {
-                g_warning ("Unable to query client: %s", error->message);
-                g_error_free (error);
-                /* FIXME: what should we do if we can't communicate with client? */
-        } else {
-                g_debug ("GsmManager: adding client to query clients: %s", gsm_client_peek_id (client));
-                data->manager->priv->query_clients = g_slist_prepend (data->manager->priv->query_clients,
-                                                                      client);
-        }
-
-        return FALSE;
-}
-
-static gboolean
-inhibitor_has_flag (gpointer      key,
-                    GsmInhibitor *inhibitor,
-                    gpointer      data)
-{
-        guint flag;
-        guint flags;
-
-        flag = GPOINTER_TO_UINT (data);
-
-        flags = gsm_inhibitor_peek_flags (inhibitor);
-
-        return (flags & flag);
-}
-
-static gboolean
-gsm_manager_is_logout_inhibited (GsmManager *manager)
-{
-        GsmInhibitor *inhibitor;
-
-        if (manager->priv->inhibitors == NULL) {
-                return FALSE;
-        }
-
-        inhibitor = (GsmInhibitor *)gsm_store_find (manager->priv->inhibitors,
-                                                    (GsmStoreFunc)inhibitor_has_flag,
-                                                    GUINT_TO_POINTER (GSM_INHIBITOR_FLAG_LOGOUT));
-        if (inhibitor == NULL) {
-                return FALSE;
-        }
-        return TRUE;
-}
-
-static gboolean
-gsm_manager_is_idle_inhibited (GsmManager *manager)
-{
-        GsmInhibitor *inhibitor;
-
-        if (manager->priv->inhibitors == NULL) {
-                return FALSE;
-        }
-
-        inhibitor = (GsmInhibitor *)gsm_store_find (manager->priv->inhibitors,
-                                                    (GsmStoreFunc)inhibitor_has_flag,
-                                                    GUINT_TO_POINTER (GSM_INHIBITOR_FLAG_IDLE));
-        if (inhibitor == NULL) {
-                return FALSE;
-        }
-        return TRUE;
-}
-
-static gboolean
-_client_cancel_end_session (const char *id,
-                            GsmClient  *client,
-                            GsmManager *manager)
-{
-        gboolean res;
-        GError  *error;
-
-        error = NULL;
-        res = gsm_client_cancel_end_session (client, &error);
-        if (! res) {
-                g_warning ("Unable to cancel end session: %s", error->message);
-                g_error_free (error);
-        }
-
-        return FALSE;
-}
-
-static gboolean
-inhibitor_is_jit (gpointer      key,
-                  GsmInhibitor *inhibitor,
-                  GsmManager   *manager)
-{
-        gboolean    matches;
-        const char *id;
-
-        id = gsm_inhibitor_peek_client_id (inhibitor);
-
-        matches = (id != NULL && id[0] != '\0');
-
-        return matches;
-}
-
-static void
-cancel_end_session (GsmManager *manager)
-{
-        /* just ignore if received outside of shutdown */
-        if (manager->priv->phase < GSM_MANAGER_PHASE_QUERY_END_SESSION) {
-                return;
-        }
-
-        /* switch back to running phase */
-        g_debug ("GsmManager: Cancelling the end of session");
-
-        g_cancellable_cancel (manager->priv->end_session_cancellable);
-
-        /* clear all JIT inhibitors */
-        gsm_store_foreach_remove (manager->priv->inhibitors,
-                                  (GsmStoreFunc)inhibitor_is_jit,
-                                  (gpointer)manager);
-
-        gsm_store_foreach (manager->priv->clients,
-                           (GsmStoreFunc)_client_cancel_end_session,
-                           NULL);
-
-        gsm_manager_set_phase (manager, GSM_MANAGER_PHASE_RUNNING);
-        manager->priv->logout_mode = GSM_MANAGER_LOGOUT_MODE_NORMAL;
-
-        manager->priv->logout_type = GSM_MANAGER_LOGOUT_NONE;
-
-        start_phase (manager);
-}
-
-static void
-end_session_or_show_shell_dialog (GsmManager *manager)
-{
-        gboolean logout_prompt;
-        GsmShellEndSessionDialogType type;
-        gboolean logout_inhibited;
-
-        switch (manager->priv->logout_type) {
-        case GSM_MANAGER_LOGOUT_LOGOUT:
-                type = GSM_SHELL_END_SESSION_DIALOG_TYPE_LOGOUT;
-                break;
-        case GSM_MANAGER_LOGOUT_REBOOT:
-        case GSM_MANAGER_LOGOUT_REBOOT_INTERACT:
-                type = GSM_SHELL_END_SESSION_DIALOG_TYPE_RESTART;
-                break;
-        case GSM_MANAGER_LOGOUT_SHUTDOWN:
-        case GSM_MANAGER_LOGOUT_SHUTDOWN_INTERACT:
-                type = GSM_SHELL_END_SESSION_DIALOG_TYPE_SHUTDOWN;
-                break;
-        default:
-                g_warning ("Unexpected logout type %d when creating end session dialog",
-                           manager->priv->logout_type);
-                type = GSM_SHELL_END_SESSION_DIALOG_TYPE_LOGOUT;
-                break;
-        }
-
-        logout_inhibited = gsm_manager_is_logout_inhibited (manager);
-        logout_prompt = g_settings_get_boolean (manager->priv->settings,
-                                                KEY_LOGOUT_PROMPT);
-
-        switch (manager->priv->logout_mode) {
-        case GSM_MANAGER_LOGOUT_MODE_NORMAL:
-                if (logout_inhibited || logout_prompt) {
-                        show_shell_end_session_dialog (manager, type);
-                } else {
-                        end_phase (manager);
-                }
-                break;
-
-        case GSM_MANAGER_LOGOUT_MODE_NO_CONFIRMATION:
-                if (logout_inhibited) {
-                        show_shell_end_session_dialog (manager, type);
-                } else {
-                        end_phase (manager);
-                }
-                break;
-
-        case GSM_MANAGER_LOGOUT_MODE_FORCE:
-                end_phase (manager);
-                break;
-        default:
-                g_assert_not_reached ();
-                break;
-        }
-
-}
-
-static void
-query_end_session_complete (GsmManager *manager)
-{
-
-        g_debug ("GsmManager: query end session complete");
-
-        /* Remove the timeout since this can be called from outside the timer
-         * and we don't want to have it called twice */
-        if (manager->priv->query_timeout_id > 0) {
-                g_source_remove (manager->priv->query_timeout_id);
-                manager->priv->query_timeout_id = 0;
-        }
-
-        end_session_or_show_shell_dialog (manager);
-}
-
-static guint32
-generate_cookie (void)
-{
-        guint32 cookie;
-
-        cookie = (guint32)g_random_int_range (1, G_MAXINT32);
-
-        return cookie;
-}
-
-static guint32
-_generate_unique_cookie (GsmManager *manager)
-{
-        guint32 cookie;
-
-        do {
-                cookie = generate_cookie ();
-        } while (gsm_store_find (manager->priv->inhibitors, (GsmStoreFunc)_find_by_cookie, &cookie) != NULL);
-
-        return cookie;
-}
-
-static gboolean
-_on_query_end_session_timeout (GsmManager *manager)
-{
-        GSList *l;
-
-        manager->priv->query_timeout_id = 0;
-
-        g_debug ("GsmManager: query end session timed out");
-
-        for (l = manager->priv->query_clients; l != NULL; l = l->next) {
-                guint         cookie;
-                GsmInhibitor *inhibitor;
-                const char   *bus_name;
-                char         *app_id;
-
-                g_warning ("Client '%s' failed to reply before timeout",
-                           gsm_client_peek_id (l->data));
-
-                /* Don't add "not responding" inhibitors if logout is forced
-                 */
-                if (manager->priv->logout_mode == GSM_MANAGER_LOGOUT_MODE_FORCE) {
-                        continue;
-                }
-
-                /* Add JIT inhibit for unresponsive client */
-                if (GSM_IS_DBUS_CLIENT (l->data)) {
-                        bus_name = gsm_dbus_client_get_bus_name (l->data);
-                } else {
-                        bus_name = NULL;
-                }
-
-                app_id = g_strdup (gsm_client_peek_app_id (l->data));
-                if (IS_STRING_EMPTY (app_id)) {
-                        /* XSMP clients don't give us an app id unless we start them */
-                        g_free (app_id);
-                        app_id = gsm_client_get_app_name (l->data);
-                }
-
-                cookie = _generate_unique_cookie (manager);
-                inhibitor = gsm_inhibitor_new_for_client (gsm_client_peek_id (l->data),
-                                                          app_id,
-                                                          GSM_INHIBITOR_FLAG_LOGOUT,
-                                                          _("Not responding"),
-                                                          bus_name,
-                                                          cookie);
-                g_free (app_id);
-                gsm_store_add (manager->priv->inhibitors, gsm_inhibitor_peek_id (inhibitor), G_OBJECT (inhibitor));
-                g_object_unref (inhibitor);
-        }
-
-        g_slist_free (manager->priv->query_clients);
-        manager->priv->query_clients = NULL;
-
-        query_end_session_complete (manager);
-
-        return FALSE;
-}
-
-static void
-do_phase_query_end_session (GsmManager *manager)
-{
-        ClientEndSessionData data;
-
-        data.manager = manager;
-        data.flags = 0;
-
-        if (manager->priv->logout_mode == GSM_MANAGER_LOGOUT_MODE_FORCE) {
-                data.flags |= GSM_CLIENT_END_SESSION_FLAG_FORCEFUL;
-        }
-        /* We only query if an app is ready to log out, so we don't use
-         * GSM_CLIENT_END_SESSION_FLAG_SAVE here.
-         */
-
-        debug_clients (manager);
-        g_debug ("GsmManager: sending query-end-session to clients (logout mode: %s)",
-                 manager->priv->logout_mode == GSM_MANAGER_LOGOUT_MODE_NORMAL? "normal" :
-                 manager->priv->logout_mode == GSM_MANAGER_LOGOUT_MODE_FORCE? "forceful":
-                 "no confirmation");
-        gsm_store_foreach (manager->priv->clients,
-                           (GsmStoreFunc)_client_query_end_session,
-                           &data);
-
-        /* This phase doesn't time out unless logout is forced. Typically, this
-         * separate timer is only used to show UI. */
-        manager->priv->query_timeout_id = g_timeout_add_seconds (1, (GSourceFunc)_on_query_end_session_timeout, manager);
-}
-
-static void
-update_idle (GsmManager *manager)
-{
-        if (gsm_manager_is_idle_inhibited (manager)) {
-                gsm_presence_set_idle_enabled (manager->priv->presence, FALSE);
-        } else {
-                gsm_presence_set_idle_enabled (manager->priv->presence, TRUE);
-        }
-}
-
-static void
-start_phase (GsmManager *manager)
-{
-
-        g_debug ("GsmManager: starting phase %s\n",
-                 phase_num_to_name (manager->priv->phase));
-
-        /* reset state */
-        g_slist_free (manager->priv->pending_apps);
-        manager->priv->pending_apps = NULL;
-        g_slist_free (manager->priv->query_clients);
-        manager->priv->query_clients = NULL;
-        g_slist_free (manager->priv->next_query_clients);
-        manager->priv->next_query_clients = NULL;
-
-        if (manager->priv->query_timeout_id > 0) {
-                g_source_remove (manager->priv->query_timeout_id);
-                manager->priv->query_timeout_id = 0;
-        }
-        if (manager->priv->phase_timeout_id > 0) {
-                g_source_remove (manager->priv->phase_timeout_id);
-                manager->priv->phase_timeout_id = 0;
-        }
-
-        switch (manager->priv->phase) {
-        case GSM_MANAGER_PHASE_STARTUP:
-        case GSM_MANAGER_PHASE_EARLY_INITIALIZATION:
-        case GSM_MANAGER_PHASE_DISPLAY_SERVER:
-        case GSM_MANAGER_PHASE_INITIALIZATION:
-        case GSM_MANAGER_PHASE_WINDOW_MANAGER:
-        case GSM_MANAGER_PHASE_PANEL:
-        case GSM_MANAGER_PHASE_DESKTOP:
-        case GSM_MANAGER_PHASE_APPLICATION:
-                do_phase_startup (manager);
-                break;
-        case GSM_MANAGER_PHASE_RUNNING:
-#ifdef HAVE_SYSTEMD                
-                sd_journal_send ("MESSAGE_ID=%s", GSM_MANAGER_STARTUP_SUCCEEDED_MSGID,
-                                 "PRIORITY=%d", 5,
-                                 "MESSAGE=Entering running state",
-                                 NULL);
-#endif
-                gsm_xsmp_server_start_accepting_new_clients (manager->priv->xsmp_server);
-                if (manager->priv->pending_end_session_tasks != NULL)
-                        complete_end_session_tasks (manager);
-                g_object_unref (manager->priv->end_session_cancellable);
-                manager->priv->end_session_cancellable = g_cancellable_new ();
-                g_signal_emit (manager, signals[SESSION_RUNNING], 0);
-                update_idle (manager);
-                break;
-        case GSM_MANAGER_PHASE_QUERY_END_SESSION:
-                gsm_xsmp_server_stop_accepting_new_clients (manager->priv->xsmp_server);
-                do_phase_query_end_session (manager);
-                break;
-        case GSM_MANAGER_PHASE_END_SESSION:
-                do_phase_end_session (manager);
-                break;
-        case GSM_MANAGER_PHASE_EXIT:
-                do_phase_exit (manager);
-                break;
-        default:
-                g_assert_not_reached ();
-                break;
-        }
-}
-
-static gboolean
-_debug_app_for_phase (const char *id,
-                      GsmApp     *app,
-                      gpointer    data)
-{
-        guint phase;
-
-        phase = GPOINTER_TO_UINT (data);
-
-        if (gsm_app_peek_phase (app) != phase) {
-                return FALSE;
-        }
-
-        g_debug ("GsmManager:\tID: %s\tapp-id:%s\tis-disabled:%d\tis-conditionally-disabled:%d",
-                 gsm_app_peek_id (app),
-                 gsm_app_peek_app_id (app),
-                 gsm_app_peek_is_disabled (app),
-                 gsm_app_peek_is_conditionally_disabled (app));
-
-        return FALSE;
-}
-
-static void
-debug_app_summary (GsmManager *manager)
-{
-        guint phase;
-
-        g_debug ("GsmManager: App startup summary");
-        for (phase = GSM_MANAGER_PHASE_EARLY_INITIALIZATION; phase < GSM_MANAGER_PHASE_RUNNING; phase++) {
-                g_debug ("GsmManager: Phase %s", phase_num_to_name (phase));
-                gsm_store_foreach (manager->priv->apps,
-                                   (GsmStoreFunc)_debug_app_for_phase,
-                                   GUINT_TO_POINTER (phase));
-        }
-}
-
-void
-gsm_manager_start (GsmManager *manager)
-{
-        g_debug ("GsmManager: GSM starting to manage");
-
-        g_return_if_fail (GSM_IS_MANAGER (manager));
-
-        gsm_xsmp_server_start (manager->priv->xsmp_server);
-        gsm_manager_set_phase (manager, GSM_MANAGER_PHASE_EARLY_INITIALIZATION);
-        debug_app_summary (manager);
-        start_phase (manager);
-}
-
-const char *
-_gsm_manager_get_default_session (GsmManager     *manager)
-{
-        return g_settings_get_string (manager->priv->session_settings,
-                                      KEY_SESSION_NAME);
-}
-
-void
-_gsm_manager_set_active_session (GsmManager     *manager,
-                                 const char     *session_name,
-                                 gboolean        is_fallback)
-{
-        g_free (manager->priv->session_name);
-        manager->priv->session_name = g_strdup (session_name);
-        manager->priv->is_fallback_session = is_fallback;
-}
-
-static gboolean
-_app_has_app_id (const char   *id,
-                 GsmApp       *app,
-                 const char   *app_id_a)
-{
-        const char *app_id_b;
-
-        app_id_b = gsm_app_peek_app_id (app);
-        return (app_id_b != NULL && strcmp (app_id_a, app_id_b) == 0);
-}
-
-static GsmApp *
-find_app_for_app_id (GsmManager *manager,
-                     const char *app_id)
-{
-        GsmApp *app;
-        app = (GsmApp *)gsm_store_find (manager->priv->apps,
-                                        (GsmStoreFunc)_app_has_app_id,
-                                        (char *)app_id);
-        return app;
-}
-
-static gboolean
-inhibitor_has_client_id (gpointer      key,
-                         GsmInhibitor *inhibitor,
-                         const char   *client_id_a)
-{
-        gboolean    matches;
-        const char *client_id_b;
-
-        client_id_b = gsm_inhibitor_peek_client_id (inhibitor);
-
-        matches = FALSE;
-        if (! IS_STRING_EMPTY (client_id_a) && ! IS_STRING_EMPTY (client_id_b)) {
-                matches = (strcmp (client_id_a, client_id_b) == 0);
-                if (matches) {
-                        g_debug ("GsmManager: removing JIT inhibitor for %s for reason '%s'",
-                                 gsm_inhibitor_peek_client_id (inhibitor),
-                                 gsm_inhibitor_peek_reason (inhibitor));
-                }
-        }
-
-        return matches;
-}
-
-static gboolean
-_app_has_startup_id (const char *id,
-                     GsmApp     *app,
-                     const char *startup_id_a)
-{
-        const char *startup_id_b;
-
-        startup_id_b = gsm_app_peek_startup_id (app);
-
-        if (IS_STRING_EMPTY (startup_id_b)) {
-                return FALSE;
-        }
-
-        return (strcmp (startup_id_a, startup_id_b) == 0);
-}
-
-static GsmApp *
-find_app_for_startup_id (GsmManager *manager,
-                        const char *startup_id)
-{
-        GsmApp *found_app;
-        GSList *a;
-
-        found_app = NULL;
-
-        /* If we're starting up the session, try to match the new client
-         * with one pending apps for the current phase. If not, try to match
-         * with any of the autostarted apps. */
-        if (manager->priv->phase < GSM_MANAGER_PHASE_APPLICATION) {
-                for (a = manager->priv->pending_apps; a != NULL; a = a->next) {
-                        GsmApp *app = GSM_APP (a->data);
-
-                        if (strcmp (startup_id, gsm_app_peek_startup_id (app)) == 0) {
-                                found_app = app;
-                                goto out;
-                        }
-                }
-        } else {
-                GsmApp *app;
-
-                app = (GsmApp *)gsm_store_find (manager->priv->apps,
-                                                (GsmStoreFunc)_app_has_startup_id,
-                                                (char *)startup_id);
-                if (app != NULL) {
-                        found_app = app;
-                        goto out;
-                }
-        }
- out:
-        return found_app;
-}
-
-static void
-_disconnect_client (GsmManager *manager,
-                    GsmClient  *client)
-{
-        gboolean              is_condition_client;
-        GsmApp               *app;
-        const char           *app_id;
-        const char           *startup_id;
-        gboolean              app_restart;
-        GsmClientRestartStyle client_restart_hint;
-
-        g_debug ("GsmManager: disconnect client: %s", gsm_client_peek_id (client));
-
-        /* take a ref so it doesn't get finalized */
-        g_object_ref (client);
-
-        gsm_client_set_status (client, GSM_CLIENT_FINISHED);
-
-        is_condition_client = FALSE;
-        if (g_slist_find (manager->priv->condition_clients, client)) {
-                manager->priv->condition_clients = g_slist_remove (manager->priv->condition_clients, client);
-
-                is_condition_client = TRUE;
-        }
-
-        /* remove any inhibitors for this client */
-        gsm_store_foreach_remove (manager->priv->inhibitors,
-                                  (GsmStoreFunc)inhibitor_has_client_id,
-                                  (gpointer)gsm_client_peek_id (client));
-
-        app = NULL;
-
-        /* first try to match on startup ID */
-        startup_id = gsm_client_peek_startup_id (client);
-        if (! IS_STRING_EMPTY (startup_id)) {
-                app = find_app_for_startup_id (manager, startup_id);
-
-        }
-
-        /* then try to find matching app-id */
-        if (app == NULL) {
-                app_id = gsm_client_peek_app_id (client);
-                if (! IS_STRING_EMPTY (app_id)) {
-                        g_debug ("GsmManager: disconnect for app '%s'", app_id);
-                        app = find_app_for_app_id (manager, app_id);
-                }
-        }
-
-        if (manager->priv->phase == GSM_MANAGER_PHASE_QUERY_END_SESSION) {
-                /* Instead of answering our end session query, the client just exited.
-                 * Treat that as an "okay, end the session" answer.
-                 *
-                 * This call implicitly removes any inhibitors for the client, along
-                 * with removing the client from the pending query list.
-                 */
-                _handle_client_end_session_response (manager,
-                                                     client,
-                                                     TRUE,
-                                                     FALSE,
-                                                     FALSE,
-                                                     "Client exited in "
-                                                     "query end session phase "
-                                                     "instead of end session "
-                                                     "phase");
-        }
-
-        if (manager->priv->dbus_disconnected && GSM_IS_DBUS_CLIENT (client)) {
-                g_debug ("GsmManager: dbus disconnected, not restarting application");
-                goto out;
-        }
-
-        if (app == NULL) {
-                g_debug ("GsmManager: unable to find application for client - not restarting");
-                goto out;
-        }
-
-        if (manager->priv->phase >= GSM_MANAGER_PHASE_QUERY_END_SESSION) {
-                g_debug ("GsmManager: in shutdown, not restarting application");
-                goto out;
-        }
-
-        app_restart = gsm_app_peek_autorestart (app);
-        client_restart_hint = gsm_client_peek_restart_style_hint (client);
-
-        /* allow legacy clients to override the app info */
-        if (! app_restart
-            && client_restart_hint != GSM_CLIENT_RESTART_IMMEDIATELY) {
-                g_debug ("GsmManager: autorestart not set, not restarting application");
-                goto out;
-        }
-
-        if (is_condition_client) {
-                g_debug ("GsmManager: app conditionally disabled, not restarting application");
-                goto out;
-        }
-
-        g_debug ("GsmManager: restarting app");
-
-        _restart_app (manager, app);
-
- out:
-        g_object_unref (client);
-}
-
-typedef struct {
-        const char *service_name;
-        GsmManager *manager;
-} RemoveClientData;
-
-static gboolean
-_disconnect_dbus_client (const char       *id,
-                         GsmClient        *client,
-                         RemoveClientData *data)
-{
-        const char *name;
-
-        if (! GSM_IS_DBUS_CLIENT (client)) {
-                return FALSE;
-        }
-
-        /* If no service name, then we simply disconnect all clients */
-        if (!data->service_name) {
-                _disconnect_client (data->manager, client);
-                return TRUE;
-        }
-
-        name = gsm_dbus_client_get_bus_name (GSM_DBUS_CLIENT (client));
-        if (IS_STRING_EMPTY (name)) {
-                return FALSE;
-        }
-
-        if (strcmp (data->service_name, name) == 0) {
-                _disconnect_client (data->manager, client);
-                return TRUE;
-        }
-
-        return FALSE;
-}
-
-/**
- * remove_clients_for_connection:
- * @manager: a #GsmManager
- * @service_name: a service name
- *
- * Disconnects clients that own @service_name.
- *
- * If @service_name is NULL, then disconnects all clients for the connection.
- */
-static void
-remove_clients_for_connection (GsmManager *manager,
-                               const char *service_name)
-{
-        RemoveClientData data;
-
-        data.service_name = service_name;
-        data.manager = manager;
-
-        /* disconnect dbus clients for name */
-        gsm_store_foreach_remove (manager->priv->clients,
-                                  (GsmStoreFunc)_disconnect_dbus_client,
-                                  &data);
-
-        if (manager->priv->phase >= GSM_MANAGER_PHASE_QUERY_END_SESSION
-            && gsm_store_size (manager->priv->clients) == 0) {
-                g_debug ("GsmManager: last client disconnected - exiting");
-                end_phase (manager);
-        }
-}
-
-static gboolean
-inhibitor_has_bus_name (gpointer          key,
-                        GsmInhibitor     *inhibitor,
-                        RemoveClientData *data)
-{
-        gboolean    matches;
-        const char *bus_name_b;
-
-        bus_name_b = gsm_inhibitor_peek_bus_name (inhibitor);
-
-        matches = FALSE;
-        if (! IS_STRING_EMPTY (data->service_name) && ! IS_STRING_EMPTY (bus_name_b)) {
-                matches = (strcmp (data->service_name, bus_name_b) == 0);
-                if (matches) {
-                        g_debug ("GsmManager: removing inhibitor from %s for reason '%s' on connection %s",
-                                 gsm_inhibitor_peek_app_id (inhibitor),
-                                 gsm_inhibitor_peek_reason (inhibitor),
-                                 gsm_inhibitor_peek_bus_name (inhibitor));
-                }
-        }
-
-        return matches;
-}
-
-static void
-remove_inhibitors_for_connection (GsmManager *manager,
-                                  const char *service_name)
-{
-        RemoveClientData data;
-        guint count;
-
-        data.service_name = service_name;
-        data.manager = manager;
-
-        debug_inhibitors (manager);
-
-        count = gsm_store_foreach_remove (manager->priv->inhibitors,
-                                          (GsmStoreFunc)inhibitor_has_bus_name,
-                                          &data);
-        if (count > 0 &&
-            manager->priv->phase == GSM_MANAGER_PHASE_QUERY_END_SESSION) {
-                end_session_or_show_shell_dialog (manager);
-        }
-}
-
-static void
-bus_name_owner_changed (DBusGProxy  *bus_proxy,
-                        const char  *service_name,
-                        const char  *old_service_name,
-                        const char  *new_service_name,
-                        GsmManager  *manager)
-{
-        if (strlen (new_service_name) == 0
-            && strlen (old_service_name) > 0) {
-                /* service removed */
-                remove_inhibitors_for_connection (manager, old_service_name);
-                remove_clients_for_connection (manager, old_service_name);
-        } else if (strlen (old_service_name) == 0
-                   && strlen (new_service_name) > 0) {
-                /* service added */
-
-                /* use this if we support automatically registering
-                 * well known bus names */
-        }
-}
-
-static DBusHandlerResult
-gsm_manager_bus_filter (DBusConnection *connection,
-                        DBusMessage    *message,
-                        void           *user_data)
-{
-        GsmManager *manager;
-
-        manager = GSM_MANAGER (user_data);
-
-        if (dbus_message_is_signal (message,
-                                    DBUS_INTERFACE_LOCAL, "Disconnected") &&
-            strcmp (dbus_message_get_path (message), DBUS_PATH_LOCAL) == 0) {
-                g_debug ("GsmManager: dbus disconnected; disconnecting dbus clients...");
-                manager->priv->dbus_disconnected = TRUE;
-                remove_clients_for_connection (manager, NULL);
-                /* let other filters get this disconnected signal, so that they
-                 * can handle it too */
-        }
-
-        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-}
-static gboolean
-register_manager (GsmManager *manager)
-{
-        GError *error = NULL;
-        DBusConnection *connection;
-
-        manager->priv->connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
-        if (manager->priv->connection == NULL) {
-                if (error != NULL) {
-                        g_critical ("error getting session bus: %s", error->message);
-                        g_error_free (error);
-                }
-                exit (1);
-        }
-
-        connection = dbus_g_connection_get_connection (manager->priv->connection);
-        dbus_connection_add_filter (connection,
-                                    gsm_manager_bus_filter,
-                                    manager, NULL);
-        manager->priv->dbus_disconnected = FALSE;
-
-        manager->priv->bus_proxy = dbus_g_proxy_new_for_name (manager->priv->connection,
-                                                              DBUS_SERVICE_DBUS,
-                                                              DBUS_PATH_DBUS,
-                                                              DBUS_INTERFACE_DBUS);
-        dbus_g_proxy_add_signal (manager->priv->bus_proxy,
-                                 "NameOwnerChanged",
-                                 G_TYPE_STRING,
-                                 G_TYPE_STRING,
-                                 G_TYPE_STRING,
-                                 G_TYPE_INVALID);
-        dbus_g_proxy_connect_signal (manager->priv->bus_proxy,
-                                     "NameOwnerChanged",
-                                     G_CALLBACK (bus_name_owner_changed),
-                                     manager,
-                                     NULL);
-
-        dbus_g_connection_register_g_object (manager->priv->connection, GSM_MANAGER_DBUS_PATH, G_OBJECT (manager));
-
-        return TRUE;
-}
-
-static void
-gsm_manager_set_failsafe (GsmManager *manager,
-                          gboolean    enabled)
-{
-        g_return_if_fail (GSM_IS_MANAGER (manager));
-
-        manager->priv->failsafe = enabled;
-}
-
-gboolean
-gsm_manager_get_failsafe (GsmManager *manager)
-{
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-
-	return manager->priv->failsafe;
-}
-
-static void
-on_client_disconnected (GsmClient  *client,
-                        GsmManager *manager)
-{
-        g_debug ("GsmManager: disconnect client");
-        _disconnect_client (manager, client);
-        gsm_store_remove (manager->priv->clients, gsm_client_peek_id (client));
-        if (manager->priv->phase >= GSM_MANAGER_PHASE_QUERY_END_SESSION
-            && gsm_store_size (manager->priv->clients) == 0) {
-                g_debug ("GsmManager: last client disconnected - exiting");
-                end_phase (manager);
-        }
-}
-
-static gboolean
-on_xsmp_client_register_request (GsmXSMPClient *client,
-                                 char         **id,
-                                 GsmManager    *manager)
-{
-        gboolean handled;
-        char    *new_id;
-        GsmApp  *app;
-
-        handled = TRUE;
-        new_id = NULL;
-
-        if (manager->priv->phase >= GSM_MANAGER_PHASE_QUERY_END_SESSION) {
-                goto out;
-        }
-
-        if (IS_STRING_EMPTY (*id)) {
-                new_id = gsm_util_generate_startup_id ();
-        } else {
-                GsmClient *client;
-
-                client = (GsmClient *)gsm_store_find (manager->priv->clients,
-                                                      (GsmStoreFunc)_client_has_startup_id,
-                                                      *id);
-                /* We can't have two clients with the same id. */
-                if (client != NULL) {
-                        goto out;
-                }
-
-                new_id = g_strdup (*id);
-        }
-
-        g_debug ("GsmManager: Adding new client %s to session", new_id);
-
-        g_signal_connect (client,
-                          "disconnected",
-                          G_CALLBACK (on_client_disconnected),
-                          manager);
-
-        /* If it's a brand new client id, we just accept the client*/
-        if (IS_STRING_EMPTY (*id)) {
-                goto out;
-        }
-
-        app = find_app_for_startup_id (manager, new_id);
-        if (app != NULL) {
-                gsm_client_set_app_id (GSM_CLIENT (client), gsm_app_peek_app_id (app));
-                goto out;
-        }
-
-        /* app not found */
-        g_free (new_id);
-        new_id = NULL;
-
- out:
-        g_free (*id);
-        *id = new_id;
-
-        return handled;
-}
-
-static void
-on_xsmp_client_register_confirmed (GsmXSMPClient *client,
-                                   const gchar   *id,
-                                   GsmManager    *manager)
-{
-        GsmApp *app;
-
-        app = find_app_for_startup_id (manager, id);
-
-        if (app != NULL) {
-                gsm_app_registered (app);
-        }
-}
-
-static gboolean
-auto_save_is_enabled (GsmManager *manager)
-{
-        return g_settings_get_boolean (manager->priv->settings, KEY_AUTOSAVE_ONE_SHOT)
-            || g_settings_get_boolean (manager->priv->settings, KEY_AUTOSAVE);
-}
-
-static void
-maybe_save_session (GsmManager *manager)
-{
-        GError *error;
-
-        if (gsm_system_is_login_session (manager->priv->system))
-                return;
-
-        /* We only allow session saving when session is running or when
-         * logging out */
-        if (manager->priv->phase != GSM_MANAGER_PHASE_RUNNING &&
-            manager->priv->phase != GSM_MANAGER_PHASE_END_SESSION) {
-                return;
-        }
-
-        if (!auto_save_is_enabled (manager)) {
-                gsm_session_save_clear ();
-                return;
-        }
-
-        error = NULL;
-        gsm_session_save (manager->priv->clients, &error);
-
-        if (error) {
-                g_warning ("Error saving session: %s", error->message);
-                g_error_free (error);
-        }
-}
-
-static void
-_handle_client_end_session_response (GsmManager *manager,
-                                     GsmClient  *client,
-                                     gboolean    is_ok,
-                                     gboolean    do_last,
-                                     gboolean    cancel,
-                                     const char *reason)
-{
-        /* just ignore if received outside of shutdown */
-        if (manager->priv->phase < GSM_MANAGER_PHASE_QUERY_END_SESSION) {
-                return;
-        }
-
-        g_debug ("GsmManager: Response from end session request: is-ok=%d do-last=%d cancel=%d reason=%s", is_ok, do_last, cancel, reason ? reason :"");
-
-        if (cancel) {
-                cancel_end_session (manager);
-                return;
-        }
-
-        manager->priv->query_clients = g_slist_remove (manager->priv->query_clients, client);
-
-        if (! is_ok && manager->priv->logout_mode != GSM_MANAGER_LOGOUT_MODE_FORCE) {
-                guint         cookie;
-                GsmInhibitor *inhibitor;
-                char         *app_id;
-                const char   *bus_name;
-
-                /* FIXME: do we support updating the reason? */
-
-                /* Create JIT inhibit */
-                if (GSM_IS_DBUS_CLIENT (client)) {
-                        bus_name = gsm_dbus_client_get_bus_name (GSM_DBUS_CLIENT (client));
-                } else {
-                        bus_name = NULL;
-                }
-
-                app_id = g_strdup (gsm_client_peek_app_id (client));
-                if (IS_STRING_EMPTY (app_id)) {
-                        /* XSMP clients don't give us an app id unless we start them */
-                        g_free (app_id);
-                        app_id = gsm_client_get_app_name (client);
-                }
-
-                cookie = _generate_unique_cookie (manager);
-                inhibitor = gsm_inhibitor_new_for_client (gsm_client_peek_id (client),
-                                                          app_id,
-                                                          GSM_INHIBITOR_FLAG_LOGOUT,
-                                                          reason != NULL ? reason : _("Not responding"),
-                                                          bus_name,
-                                                          cookie);
-                g_free (app_id);
-                gsm_store_add (manager->priv->inhibitors, gsm_inhibitor_peek_id (inhibitor), G_OBJECT (inhibitor));
-                g_object_unref (inhibitor);
-        } else {
-                gsm_store_foreach_remove (manager->priv->inhibitors,
-                                          (GsmStoreFunc)inhibitor_has_client_id,
-                                          (gpointer)gsm_client_peek_id (client));
-        }
-
-        if (manager->priv->phase == GSM_MANAGER_PHASE_QUERY_END_SESSION) { 
-                if (manager->priv->query_clients == NULL) {
-                        query_end_session_complete (manager);
-                }
-        } else if (manager->priv->phase == GSM_MANAGER_PHASE_END_SESSION) {
-                if (do_last) {
-                        /* This only makes sense if we're in part 1 of
-                         * GSM_MANAGER_PHASE_END_SESSION. Doing this in part 2
-                         * can only happen because of a buggy client that loops
-                         * wanting to be last again and again. The phase
-                         * timeout will take care of this issue. */
-                        manager->priv->next_query_clients = g_slist_prepend (manager->priv->next_query_clients,
-                                                                             client);
-                }
-
-                /* we can continue to the next step if all clients have replied
-                 * and if there's no inhibitor */
-                if (manager->priv->query_clients != NULL
-                    || gsm_manager_is_logout_inhibited (manager)) {
-                        return;
-                }
-
-                if (manager->priv->next_query_clients != NULL) {
-                        do_phase_end_session_part_2 (manager);
-                } else {
-                        end_phase (manager);
-                }
-        }
-}
-
-static void
-on_client_end_session_response (GsmClient  *client,
-                                gboolean    is_ok,
-                                gboolean    do_last,
-                                gboolean    cancel,
-                                const char *reason,
-                                GsmManager *manager)
-{
-        _handle_client_end_session_response (manager,
-                                             client,
-                                             is_ok,
-                                             do_last,
-                                             cancel,
-                                             reason);
-}
-
-static void
-on_xsmp_client_logout_request (GsmXSMPClient *client,
-                               gboolean       show_dialog,
-                               GsmManager    *manager)
-{
-        GError *error;
-        int     logout_mode;
-
-        if (show_dialog) {
-                logout_mode = GSM_MANAGER_LOGOUT_MODE_NORMAL;
-        } else {
-                logout_mode = GSM_MANAGER_LOGOUT_MODE_NO_CONFIRMATION;
-        }
-
-        error = NULL;
-        gsm_manager_logout (manager, logout_mode, &error);
-        if (error != NULL) {
-                g_warning ("Unable to logout: %s", error->message);
-                g_error_free (error);
-        }
-}
-
-static void
-on_store_client_added (GsmStore   *store,
-                       const char *id,
-                       GsmManager *manager)
-{
-        GsmClient *client;
-
-        g_debug ("GsmManager: Client added: %s", id);
-
-        client = (GsmClient *)gsm_store_lookup (store, id);
-
-        /* a bit hacky */
-        if (GSM_IS_XSMP_CLIENT (client)) {
-                g_signal_connect (client,
-                                  "register-request",
-                                  G_CALLBACK (on_xsmp_client_register_request),
-                                  manager);
-                g_signal_connect (client,
-                                  "register-confirmed",
-                                  G_CALLBACK (on_xsmp_client_register_confirmed),
-                                  manager);
-                g_signal_connect (client,
-                                  "logout-request",
-                                  G_CALLBACK (on_xsmp_client_logout_request),
-                                  manager);
-        }
-
-        g_signal_connect (client,
-                          "end-session-response",
-                          G_CALLBACK (on_client_end_session_response),
-                          manager);
-
-        g_signal_emit (manager, signals [CLIENT_ADDED], 0, id);
-        /* FIXME: disconnect signal handler */
-}
-
-static void
-on_store_client_removed (GsmStore   *store,
-                         const char *id,
-                         GsmManager *manager)
-{
-        g_debug ("GsmManager: Client removed: %s", id);
-
-        g_signal_emit (manager, signals [CLIENT_REMOVED], 0, id);
-}
-
-static void
-gsm_manager_set_client_store (GsmManager *manager,
-                              GsmStore   *store)
-{
-        g_return_if_fail (GSM_IS_MANAGER (manager));
-
-        if (store != NULL) {
-                g_object_ref (store);
-        }
-
-        if (manager->priv->clients != NULL) {
-                g_signal_handlers_disconnect_by_func (manager->priv->clients,
-                                                      on_store_client_added,
-                                                      manager);
-                g_signal_handlers_disconnect_by_func (manager->priv->clients,
-                                                      on_store_client_removed,
-                                                      manager);
-
-                g_object_unref (manager->priv->clients);
-        }
-
-
-        g_debug ("GsmManager: setting client store %p", store);
-
-        manager->priv->clients = store;
-
-        if (manager->priv->clients != NULL) {
-                if (manager->priv->xsmp_server)
-                        g_object_unref (manager->priv->xsmp_server);
-
-                manager->priv->xsmp_server = gsm_xsmp_server_new (store);
-
-                g_signal_connect (manager->priv->clients,
-                                  "added",
-                                  G_CALLBACK (on_store_client_added),
-                                  manager);
-                g_signal_connect (manager->priv->clients,
-                                  "removed",
-                                  G_CALLBACK (on_store_client_removed),
-                                  manager);
-        }
-}
-
-static void
-gsm_manager_set_property (GObject       *object,
-                          guint          prop_id,
-                          const GValue  *value,
-                          GParamSpec    *pspec)
-{
-        GsmManager *self;
-
-        self = GSM_MANAGER (object);
-
-        switch (prop_id) {
-        case PROP_FAILSAFE:
-                gsm_manager_set_failsafe (self, g_value_get_boolean (value));
-                break;
-         case PROP_FALLBACK:
-                self->priv->is_fallback_session = g_value_get_boolean (value);
-                break;
-         case PROP_CLIENT_STORE:
-                gsm_manager_set_client_store (self, g_value_get_object (value));
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_manager_get_property (GObject    *object,
-                          guint       prop_id,
-                          GValue     *value,
-                          GParamSpec *pspec)
-{
-        GsmManager *self;
-
-        self = GSM_MANAGER (object);
-
-        switch (prop_id) {
-        case PROP_FAILSAFE:
-                g_value_set_boolean (value, self->priv->failsafe);
-                break;
-        case PROP_SESSION_NAME:
-                g_value_set_string (value, self->priv->session_name);
-                break;
-        case PROP_SESSION_IS_ACTIVE:
-                g_value_set_boolean (value, gsm_system_is_active (self->priv->system));
-                break;
-        case PROP_FALLBACK:
-                g_value_set_boolean (value, self->priv->is_fallback_session);
-                break;
-        case PROP_CLIENT_STORE:
-                g_value_set_object (value, self->priv->clients);
-                break;
-        case PROP_INHIBITED_ACTIONS:
-                g_value_set_uint (value, self->priv->inhibited_actions);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static gboolean
-_find_app_provides (const char *id,
-                    GsmApp     *app,
-                    const char *service)
-{
-        return gsm_app_provides (app, service);
-}
-
-static GObject *
-gsm_manager_constructor (GType                  type,
-                         guint                  n_construct_properties,
-                         GObjectConstructParam *construct_properties)
-{
-        GsmManager *manager;
-
-        manager = GSM_MANAGER (G_OBJECT_CLASS (gsm_manager_parent_class)->constructor (type,
-                                                                                       n_construct_properties,
-                                                                                       construct_properties));
-        return G_OBJECT (manager);
-}
-
-static void
-update_inhibited_actions (GsmManager *manager,
-                          GsmInhibitorFlag new_inhibited_actions)
-{
-        DBusGConnection *gconnection;
-        DBusConnection *connection;
-        DBusMessage *message;
-        DBusMessageIter iter;
-        DBusMessageIter subiter;
-        DBusMessageIter dict_iter;
-        DBusMessageIter v_iter;
-        const char *iface_name = GSM_MANAGER_DBUS_NAME;
-        const char *prop_name = "InhibitedActions";
-
-        if (manager->priv->inhibited_actions == new_inhibited_actions)
-                return;
-
-        manager->priv->inhibited_actions = new_inhibited_actions;
-        g_object_notify (G_OBJECT (manager), "inhibited-actions");
-
-        /* Now, the following bits emit the PropertiesChanged signal
-         * that GDBus expects.  This code should just die in a port to
-         * GDBus.
-         */
-        gconnection = dbus_g_bus_get (DBUS_BUS_SESSION, NULL);
-        g_assert (gconnection);
-        connection = dbus_g_connection_get_connection (gconnection);
-        message = dbus_message_new_signal (GSM_MANAGER_DBUS_PATH, "org.freedesktop.DBus.Properties",
-                                           "PropertiesChanged");
-        g_assert (message != NULL);
-        dbus_message_iter_init_append (message, &iter);
-        dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &iface_name);
-        /* changed */
-        dbus_message_iter_open_container (&iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
-        dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &dict_iter);
-        dbus_message_iter_append_basic (&dict_iter, DBUS_TYPE_STRING, &prop_name);
-        dbus_message_iter_open_container (&dict_iter, DBUS_TYPE_VARIANT, "u", &v_iter);
-        dbus_message_iter_append_basic (&v_iter, DBUS_TYPE_UINT32, &new_inhibited_actions);
-        dbus_message_iter_close_container (&dict_iter, &v_iter);
-        dbus_message_iter_close_container (&subiter, &dict_iter);
-        dbus_message_iter_close_container (&iter, &subiter);
-        /* invalidated */
-        dbus_message_iter_open_container (&iter, DBUS_TYPE_ARRAY, "s", &subiter);
-        dbus_message_iter_close_container (&iter, &subiter);
-
-        dbus_connection_send (connection, message, NULL);
-        dbus_message_unref (message);
-}
-
-static void
-on_store_inhibitor_added (GsmStore   *store,
-                          const char *id,
-                          GsmManager *manager)
-{
-        GsmInhibitor *i;
-        GsmInhibitorFlag new_inhibited_actions;
-
-        g_debug ("GsmManager: Inhibitor added: %s", id);
-
-        i = GSM_INHIBITOR (gsm_store_lookup (store, id));
-        gsm_system_add_inhibitor (manager->priv->system, id,
-                                  gsm_inhibitor_peek_flags (i));
-
-        new_inhibited_actions = manager->priv->inhibited_actions | gsm_inhibitor_peek_flags (i);
-        update_inhibited_actions (manager, new_inhibited_actions);
-
-        g_signal_emit (manager, signals [INHIBITOR_ADDED], 0, id);
-
-        update_idle (manager);
-}
-
-static gboolean
-collect_inhibition_flags (const char *id,
-                          GObject    *object,
-                          gpointer    user_data)
-{
-        GsmInhibitorFlag *new_inhibited_actions = user_data;
-
-        *new_inhibited_actions |= gsm_inhibitor_peek_flags (GSM_INHIBITOR (object));
-
-        return FALSE;
-}
-
-static void
-on_store_inhibitor_removed (GsmStore   *store,
-                            const char *id,
-                            GsmManager *manager)
-{
-        GsmInhibitorFlag new_inhibited_actions;
-
-        g_debug ("GsmManager: Inhibitor removed: %s", id);
-
-        gsm_system_remove_inhibitor (manager->priv->system, id);
-
-        new_inhibited_actions = 0;
-        gsm_store_foreach (manager->priv->inhibitors,
-                           collect_inhibition_flags,
-                           &new_inhibited_actions);
-        update_inhibited_actions (manager, new_inhibited_actions);
-
-        g_signal_emit (manager, signals [INHIBITOR_REMOVED], 0, id);
-
-        update_idle (manager);
-}
-
-static void
-gsm_manager_dispose (GObject *object)
-{
-        GsmManager *manager = GSM_MANAGER (object);
-
-        g_debug ("GsmManager: disposing manager");
-
-        g_clear_object (&manager->priv->end_session_cancellable);
-        g_clear_object (&manager->priv->xsmp_server);
-
-        if (manager->priv->clients != NULL) {
-                g_signal_handlers_disconnect_by_func (manager->priv->clients,
-                                                      on_store_client_added,
-                                                      manager);
-                g_signal_handlers_disconnect_by_func (manager->priv->clients,
-                                                      on_store_client_removed,
-                                                      manager);
-                g_object_unref (manager->priv->clients);
-                manager->priv->clients = NULL;
-        }
-
-        g_clear_object (&manager->priv->apps);
-        g_slist_free (manager->priv->required_apps);
-        manager->priv->required_apps = NULL;
-
-        if (manager->priv->inhibitors != NULL) {
-                g_signal_handlers_disconnect_by_func (manager->priv->inhibitors,
-                                                      on_store_inhibitor_added,
-                                                      manager);
-                g_signal_handlers_disconnect_by_func (manager->priv->inhibitors,
-                                                      on_store_inhibitor_removed,
-                                                      manager);
-
-                g_object_unref (manager->priv->inhibitors);
-                manager->priv->inhibitors = NULL;
-        }
-
-        g_clear_object (&manager->priv->presence);
-        g_clear_object (&manager->priv->settings);
-        g_clear_object (&manager->priv->session_settings);
-        g_clear_object (&manager->priv->screensaver_settings);
-        g_clear_object (&manager->priv->lockdown_settings);
-        g_clear_object (&manager->priv->system);
-        g_clear_object (&manager->priv->shell);
-
-        G_OBJECT_CLASS (gsm_manager_parent_class)->dispose (object);
-}
-
-static void
-gsm_manager_class_init (GsmManagerClass *klass)
-{
-        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
-
-        object_class->get_property = gsm_manager_get_property;
-        object_class->set_property = gsm_manager_set_property;
-        object_class->constructor = gsm_manager_constructor;
-        object_class->dispose = gsm_manager_dispose;
-
-        signals [PHASE_CHANGED] =
-                g_signal_new ("phase-changed",
-                              G_TYPE_FROM_CLASS (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmManagerClass, phase_changed),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE,
-                              1, G_TYPE_STRING);
-
-        signals [SESSION_RUNNING] =
-                g_signal_new ("session-running",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmManagerClass, session_running),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE,
-                              0);
-
-        signals [SESSION_OVER] =
-                g_signal_new ("session-over",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmManagerClass, session_over),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE,
-                              0);
-        signals [CLIENT_ADDED] =
-                g_signal_new ("client-added",
-                              G_TYPE_FROM_CLASS (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmManagerClass, client_added),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE,
-                              1, DBUS_TYPE_G_OBJECT_PATH);
-        signals [CLIENT_REMOVED] =
-                g_signal_new ("client-removed",
-                              G_TYPE_FROM_CLASS (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmManagerClass, client_removed),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE,
-                              1, DBUS_TYPE_G_OBJECT_PATH);
-        signals [INHIBITOR_ADDED] =
-                g_signal_new ("inhibitor-added",
-                              G_TYPE_FROM_CLASS (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmManagerClass, inhibitor_added),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE,
-                              1, DBUS_TYPE_G_OBJECT_PATH);
-        signals [INHIBITOR_REMOVED] =
-                g_signal_new ("inhibitor-removed",
-                              G_TYPE_FROM_CLASS (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmManagerClass, inhibitor_removed),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE,
-                              1, DBUS_TYPE_G_OBJECT_PATH);
-
-        g_object_class_install_property (object_class,
-                                         PROP_FAILSAFE,
-                                         g_param_spec_boolean ("failsafe",
-                                                               NULL,
-                                                               NULL,
-                                                               FALSE,
-                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-
-        /**
-         * GsmManager::inhibited-actions
-         *
-         * A bitmask of flags to indicate which actions are inhibited. See the Inhibit()
-         * function's description for a list of possible values.
-         */
-        g_object_class_install_property (object_class,
-                                         PROP_INHIBITED_ACTIONS,
-                                         g_param_spec_uint ("inhibited-actions",
-                                                            NULL,
-                                                            NULL,
-                                                            0,
-                                                            G_MAXUINT,
-                                                            0,
-                                                            G_PARAM_READABLE));
-        /**
-         * GsmManager::session-name
-         *
-         * Then name of the currently active session, typically "gnome" or "gnome-fallback".
-         * This may be the name of the configured default session, or the name of a fallback
-         * session in case we fell back.
-         */
-        g_object_class_install_property (object_class,
-                                         PROP_SESSION_NAME,
-                                         g_param_spec_string ("session-name",
-                                                              NULL,
-                                                              NULL,
-                                                              NULL,
-                                                              G_PARAM_READABLE));
-        /**
-
-         * GsmManager::session-is-active
-         *
-         * If true, the current session is in the foreground and
-         * available for user input.
-         */
-        g_object_class_install_property (object_class,
-                                         PROP_SESSION_IS_ACTIVE,
-                                         g_param_spec_boolean ("session-is-active",
-                                                               NULL,
-                                                               NULL,
-                                                               TRUE,
-                                                               G_PARAM_READABLE));
-
-        /**
-         * GsmManager::fallback
-         *
-         * If %TRUE, the current session is running in the "fallback" mode;
-         * this is distinct from whether or not it was configured as default.
-         */
-        g_object_class_install_property (object_class,
-                                         PROP_FALLBACK,
-                                         g_param_spec_boolean ("fallback",
-                                                               NULL,
-                                                               NULL,
-                                                               FALSE,
-                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-
-        g_object_class_install_property (object_class,
-                                         PROP_CLIENT_STORE,
-                                         g_param_spec_object ("client-store",
-                                                              NULL,
-                                                              NULL,
-                                                              GSM_TYPE_STORE,
-                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-
-        g_type_class_add_private (klass, sizeof (GsmManagerPrivate));
-
-        dbus_g_object_type_install_info (GSM_TYPE_MANAGER, &dbus_glib_gsm_manager_object_info);
-        dbus_g_error_domain_register (GSM_MANAGER_ERROR, NULL, GSM_MANAGER_TYPE_ERROR);
-}
-
-static void
-on_presence_status_changed (GsmPresence  *presence,
-                            guint         status,
-                            GsmManager   *manager)
-{
-        GsmSystem *system;
-
-        system = gsm_get_system ();
-        gsm_system_set_session_idle (system,
-                                     (status == GSM_PRESENCE_STATUS_IDLE));
-        g_object_unref (system);
-}
-
-static void
-on_gsm_system_active_changed (GsmSystem  *system,
-                              GParamSpec *pspec,
-                              GsmManager *self)
-{
-        DBusGConnection *gconnection;
-        DBusConnection *connection;
-        DBusMessage *message;
-        DBusMessageIter iter;
-        DBusMessageIter subiter;
-        DBusMessageIter dict_iter;
-        DBusMessageIter v_iter;
-        dbus_bool_t is_active;
-        const char *iface_name = GSM_MANAGER_DBUS_NAME;
-        const char *prop_name = "SessionIsActive";
-
-        g_object_notify ((GObject*)self, "session-is-active");
-
-        g_debug ("emitting SessionIsActive");
-
-        /* Now, the following bits emit the PropertiesChanged signal
-         * that GDBus expects.  This code should just die in a port to
-         * GDBus.
-         */
-        gconnection = dbus_g_bus_get (DBUS_BUS_SESSION, NULL);
-        g_assert (gconnection);
-        connection = dbus_g_connection_get_connection (gconnection);
-        is_active = gsm_system_is_active (self->priv->system);
-        message = dbus_message_new_signal (GSM_MANAGER_DBUS_PATH, "org.freedesktop.DBus.Properties",
-                                           "PropertiesChanged");
-        g_assert (message != NULL);
-        dbus_message_iter_init_append (message, &iter);
-        dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &iface_name);
-        /* changed */
-        dbus_message_iter_open_container (&iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
-        dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &dict_iter);
-        dbus_message_iter_append_basic (&dict_iter, DBUS_TYPE_STRING, &prop_name);
-        dbus_message_iter_open_container (&dict_iter, DBUS_TYPE_VARIANT, "b", &v_iter);
-        dbus_message_iter_append_basic (&v_iter, DBUS_TYPE_BOOLEAN, &is_active);
-        dbus_message_iter_close_container (&dict_iter, &v_iter);
-        dbus_message_iter_close_container (&subiter, &dict_iter);
-        dbus_message_iter_close_container (&iter, &subiter);
-        /* invalidated */
-        dbus_message_iter_open_container (&iter, DBUS_TYPE_ARRAY, "s", &subiter);
-        dbus_message_iter_close_container (&iter, &subiter);
-
-        dbus_connection_send (connection, message, NULL);
-        dbus_message_unref (message);
-}
-
-static gboolean
-idle_timeout_get_mapping (GValue *value,
-                          GVariant *variant,
-                          gpointer user_data)
-{
-        guint32 idle_timeout;
-
-        idle_timeout = g_variant_get_uint32 (variant);
-        g_value_set_uint (value, idle_timeout * 1000);
-
-        return TRUE;
-}
-
-static void
-gsm_manager_init (GsmManager *manager)
-{
-
-        manager->priv = GSM_MANAGER_GET_PRIVATE (manager);
-
-        manager->priv->settings = g_settings_new (GSM_MANAGER_SCHEMA);
-        manager->priv->session_settings = g_settings_new (SESSION_SCHEMA);
-        manager->priv->screensaver_settings = g_settings_new (SCREENSAVER_SCHEMA);
-        manager->priv->lockdown_settings = g_settings_new (LOCKDOWN_SCHEMA);
-
-        manager->priv->inhibitors = gsm_store_new ();
-        g_signal_connect (manager->priv->inhibitors,
-                          "added",
-                          G_CALLBACK (on_store_inhibitor_added),
-                          manager);
-        g_signal_connect (manager->priv->inhibitors,
-                          "removed",
-                          G_CALLBACK (on_store_inhibitor_removed),
-                          manager);
-
-        manager->priv->apps = gsm_store_new ();
-
-        manager->priv->presence = gsm_presence_new ();
-        g_signal_connect (manager->priv->presence,
-                          "status-changed",
-                          G_CALLBACK (on_presence_status_changed),
-                          manager);
-
-        g_settings_bind_with_mapping (manager->priv->session_settings,
-                                      KEY_IDLE_DELAY,
-                                      manager->priv->presence,
-                                      "idle-timeout",
-                                      G_SETTINGS_BIND_GET,
-                                      idle_timeout_get_mapping,
-                                      NULL,
-                                      NULL, NULL);
-
-        manager->priv->system = gsm_get_system ();
-        g_signal_connect (manager->priv->system, "notify::active",
-                          G_CALLBACK (on_gsm_system_active_changed), manager);
-
-        manager->priv->shell = gsm_get_shell ();
-        manager->priv->end_session_cancellable = g_cancellable_new ();
-}
-
-GsmManager *
-gsm_manager_get (void)
-{
-        return manager_object;
-}
-
-GsmManager *
-gsm_manager_new (GsmStore *client_store,
-                 gboolean  failsafe)
-{
-        if (manager_object != NULL) {
-                g_object_ref (manager_object);
-        } else {
-                gboolean res;
-
-                manager_object = g_object_new (GSM_TYPE_MANAGER,
-                                               "client-store", client_store,
-                                               "failsafe", failsafe,
-                                               NULL);
-
-                g_object_add_weak_pointer (manager_object,
-                                           (gpointer *) &manager_object);
-                res = register_manager (manager_object);
-                if (! res) {
-                        g_object_unref (manager_object);
-                        return NULL;
-                }
-        }
-
-        return GSM_MANAGER (manager_object);
-}
-
-gboolean
-gsm_manager_setenv (GsmManager  *manager,
-                    const char  *variable,
-                    const char  *value,
-                    GError     **error)
-{
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-
-        if (manager->priv->phase > GSM_MANAGER_PHASE_INITIALIZATION) {
-                g_set_error (error,
-                             GSM_MANAGER_ERROR,
-                             GSM_MANAGER_ERROR_NOT_IN_INITIALIZATION,
-                             "Setenv interface is only available during the DisplayServer and Initialization phase");
-                return FALSE;
-        }
-
-        gsm_util_setenv (variable, value);
-
-        return TRUE;
-}
-
-static gboolean
-is_valid_category (int category)
-{
-	int categories[] = {
-		LC_CTYPE,
-		LC_NUMERIC,
-		LC_TIME,
-		LC_COLLATE,
-		LC_MONETARY,
-		LC_MESSAGES,
-#if defined (LC_PAPER)
-		LC_PAPER,
-#endif
-#if defined (LC_NAME)
-		LC_NAME,
-#endif
-#if defined (LC_ADDRESS)
-		LC_ADDRESS,
-#endif
-#if defined (LC_TELEPHONE)
-		LC_TELEPHONE,
-#endif
-#if defined (LC_MEASUREMENT)
-		LC_MEASUREMENT,
-#endif
-#if defined (LC_IDENTIFICATION)
-		LC_IDENTIFICATION,
-#endif
-		LC_ALL
-	};
-	guint i;
-
-	for (i = 0; i < G_N_ELEMENTS(categories); i++)
-		if (categories[i] == category)
-			return TRUE;
-
-	return FALSE;
-}
-
-gboolean
-gsm_manager_get_locale (GsmManager  *manager,
-                        int          category,
-                        const char **value,
-                        GError     **error)
-{
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-
-        if (!is_valid_category (category)) {
-                g_set_error (error,
-                             GSM_MANAGER_ERROR,
-                             GSM_MANAGER_ERROR_INVALID_OPTION,
-                             "GetLocale doesn't support locale category '%d'", category);
-                return FALSE;
-        }
-
-        *value = g_strdup (setlocale (category, NULL));
-        if (*value == NULL)
-                *value = g_strdup ("");
-
-        return TRUE;
-}
-
-gboolean
-gsm_manager_initialization_error (GsmManager  *manager,
-                                  const char  *message,
-                                  gboolean     fatal,
-                                  GError     **error)
-{
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-
-        if (manager->priv->phase != GSM_MANAGER_PHASE_INITIALIZATION) {
-                g_set_error (error,
-                             GSM_MANAGER_ERROR,
-                             GSM_MANAGER_ERROR_NOT_IN_INITIALIZATION,
-                             "InitializationError interface is only available during the Initialization phase");
-                return FALSE;
-        }
-
-        gsm_util_init_error (fatal, "%s", message);
-
-        return TRUE;
-}
-
-static void
-request_reboot (GsmManager *manager)
-{
-        g_debug ("GsmManager: requesting reboot");
-
-        /* FIXME: We need to support a more structured shutdown here,
-         * but that's blocking on an improved ConsoleKit api.
-         *
-         * See https://bugzilla.gnome.org/show_bug.cgi?id=585614
-         */
-        manager->priv->logout_type = GSM_MANAGER_LOGOUT_REBOOT_INTERACT;
-        end_phase (manager);
-}
-
-static void
-request_shutdown (GsmManager *manager)
-{
-        g_debug ("GsmManager: requesting shutdown");
-
-        /* See the comment in request_reboot() for some more details about
-         * what work needs to be done here. */
-        manager->priv->logout_type = GSM_MANAGER_LOGOUT_SHUTDOWN_INTERACT;
-        end_phase (manager);
-}
-
-static void
-request_logout (GsmManager           *manager,
-                GsmManagerLogoutMode  mode)
-{
-        g_debug ("GsmManager: requesting logout");
-
-        manager->priv->logout_mode = mode;
-        manager->priv->logout_type = GSM_MANAGER_LOGOUT_LOGOUT;
-
-        end_phase (manager);
-}
-
-static void
-disconnect_shell_dialog_signals (GsmManager *manager)
-{
-        if (manager->priv->shell_end_session_dialog_canceled_id != 0) {
-                g_signal_handler_disconnect (manager->priv->shell,
-                                             manager->priv->shell_end_session_dialog_canceled_id);
-                manager->priv->shell_end_session_dialog_canceled_id = 0;
-        }
-
-        if (manager->priv->shell_end_session_dialog_confirmed_logout_id != 0) {
-                g_signal_handler_disconnect (manager->priv->shell,
-                                             manager->priv->shell_end_session_dialog_confirmed_logout_id);
-                manager->priv->shell_end_session_dialog_confirmed_logout_id = 0;
-        }
-
-        if (manager->priv->shell_end_session_dialog_confirmed_shutdown_id != 0) {
-                g_signal_handler_disconnect (manager->priv->shell,
-                                             manager->priv->shell_end_session_dialog_confirmed_shutdown_id);
-                manager->priv->shell_end_session_dialog_confirmed_shutdown_id = 0;
-        }
-
-        if (manager->priv->shell_end_session_dialog_confirmed_reboot_id != 0) {
-                g_signal_handler_disconnect (manager->priv->shell,
-                                             manager->priv->shell_end_session_dialog_confirmed_reboot_id);
-                manager->priv->shell_end_session_dialog_confirmed_reboot_id = 0;
-        }
-
-        if (manager->priv->shell_end_session_dialog_open_failed_id != 0) {
-                g_signal_handler_disconnect (manager->priv->shell,
-                                             manager->priv->shell_end_session_dialog_open_failed_id);
-                manager->priv->shell_end_session_dialog_open_failed_id = 0;
-        }
-}
-
-static void
-on_shell_end_session_dialog_canceled (GsmShell   *shell,
-                                      GsmManager *manager)
-{
-        cancel_end_session (manager);
-        disconnect_shell_dialog_signals (manager);
-}
-
-static void
-_handle_end_session_dialog_response (GsmManager           *manager,
-                                     GsmManagerLogoutType  logout_type)
-{
-        /* Note we're checking for END_SESSION here and
-         * QUERY_END_SESSION in the fallback cases elsewhere.
-         *
-         * That's because they run at different times in the logout
-         * process. The shell combines the inhibit and
-         * confirmation dialogs, so it gets displayed after we've collected
-         * inhibitors. The fallback code has two distinct dialogs, once of
-         * which we can (and do show) before collecting the inhibitors.
-         */
-        if (manager->priv->phase >= GSM_MANAGER_PHASE_END_SESSION) {
-                /* Already shutting down, nothing more to do */
-                return;
-        }
-
-        manager->priv->logout_mode = GSM_MANAGER_LOGOUT_MODE_FORCE;
-        manager->priv->logout_type = logout_type;
-        end_phase (manager);
-}
-
-static void
-on_shell_end_session_dialog_confirmed_logout (GsmShell   *shell,
-                                              GsmManager *manager)
-{
-        _handle_end_session_dialog_response (manager, GSM_MANAGER_LOGOUT_LOGOUT);
-        disconnect_shell_dialog_signals (manager);
-}
-
-static void
-on_shell_end_session_dialog_confirmed_shutdown (GsmShell   *shell,
-                                                GsmManager *manager)
-{
-        _handle_end_session_dialog_response (manager, GSM_MANAGER_LOGOUT_SHUTDOWN);
-        disconnect_shell_dialog_signals (manager);
-}
-
-static void
-on_shell_end_session_dialog_confirmed_reboot (GsmShell   *shell,
-                                              GsmManager *manager)
-{
-        _handle_end_session_dialog_response (manager, GSM_MANAGER_LOGOUT_REBOOT);
-        disconnect_shell_dialog_signals (manager);
-}
-
-static void
-connect_shell_dialog_signals (GsmManager *manager)
-{
-        if (manager->priv->shell_end_session_dialog_canceled_id != 0)
-                return;
-
-        manager->priv->shell_end_session_dialog_canceled_id =
-                g_signal_connect (manager->priv->shell,
-                                  "end-session-dialog-canceled",
-                                  G_CALLBACK (on_shell_end_session_dialog_canceled),
-                                  manager);
-
-        manager->priv->shell_end_session_dialog_open_failed_id =
-                g_signal_connect (manager->priv->shell,
-                                  "end-session-dialog-open-failed",
-                                  G_CALLBACK (on_shell_end_session_dialog_canceled),
-                                  manager);
-
-        manager->priv->shell_end_session_dialog_confirmed_logout_id =
-                g_signal_connect (manager->priv->shell,
-                                  "end-session-dialog-confirmed-logout",
-                                  G_CALLBACK (on_shell_end_session_dialog_confirmed_logout),
-                                  manager);
-
-        manager->priv->shell_end_session_dialog_confirmed_shutdown_id =
-                g_signal_connect (manager->priv->shell,
-                                  "end-session-dialog-confirmed-shutdown",
-                                  G_CALLBACK (on_shell_end_session_dialog_confirmed_shutdown),
-                                  manager);
-
-        manager->priv->shell_end_session_dialog_confirmed_reboot_id =
-                g_signal_connect (manager->priv->shell,
-                                  "end-session-dialog-confirmed-reboot",
-                                  G_CALLBACK (on_shell_end_session_dialog_confirmed_reboot),
-                                  manager);
-}
-
-static void
-show_shell_end_session_dialog (GsmManager                   *manager,
-                               GsmShellEndSessionDialogType  type)
-{
-        if (!gsm_shell_is_running (manager->priv->shell))
-                return;
-
-        gsm_shell_open_end_session_dialog (manager->priv->shell,
-                                           type,
-                                           manager->priv->inhibitors);
-        connect_shell_dialog_signals (manager);
-}
-
-static void
-user_logout (GsmManager           *manager,
-             GsmManagerLogoutMode  mode)
-{
-        if (manager->priv->phase >= GSM_MANAGER_PHASE_QUERY_END_SESSION) {
-                /* Already shutting down, nothing more to do */
-                return;
-        }
-
-        request_logout (manager, mode);
-}
-
-/*
-  dbus-send --session --type=method_call --print-reply
-      --dest=org.gnome.SessionManager
-      /org/gnome/SessionManager
-      org.freedesktop.DBus.Introspectable.Introspect
-*/
-
-gboolean
-gsm_manager_set_phase (GsmManager      *manager,
-                       GsmManagerPhase  phase)
-{
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-        manager->priv->phase = phase;
-        return (TRUE);
-}
-
-static gboolean
-_log_out_is_locked_down (GsmManager *manager)
-{
-        return g_settings_get_boolean (manager->priv->lockdown_settings,
-                                       KEY_DISABLE_LOG_OUT);
-}
-
-static void
-complete_end_session_task (GsmManager            *manager,
-                           GAsyncResult          *result,
-                           DBusGMethodInvocation *context)
-{
-        GError *error = NULL;
-
-        if (!g_task_propagate_boolean (G_TASK (result), &error))
-                dbus_g_method_return_error (context, error);
-        else
-                dbus_g_method_return (context);
-}
-
-gboolean
-gsm_manager_shutdown (GsmManager            *manager,
-                      DBusGMethodInvocation *context)
-{
-        GTask *task;
-        GError *error = NULL;
-
-        g_debug ("GsmManager: Shutdown called");
-
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-
-        if (manager->priv->phase != GSM_MANAGER_PHASE_RUNNING) {
-                error = g_error_new (GSM_MANAGER_ERROR,
-                                     GSM_MANAGER_ERROR_NOT_IN_RUNNING,
-                                     "Shutdown interface is only available during the Running phase");
-                dbus_g_method_return_error (context, error);
-                g_error_free (error);
-                return FALSE;
-        }
-
-        if (_log_out_is_locked_down (manager)) {
-                error = g_error_new (GSM_MANAGER_ERROR,
-                                     GSM_MANAGER_ERROR_LOCKED_DOWN,
-                                     "Logout has been locked down");
-                dbus_g_method_return_error (context, error);
-                g_error_free (error);
-                return FALSE;
-        }
-
-        task = g_task_new (manager, manager->priv->end_session_cancellable, (GAsyncReadyCallback) complete_end_session_task, context);
-
-        manager->priv->pending_end_session_tasks = g_slist_prepend (manager->priv->pending_end_session_tasks,
-                                                                    task);
-
-        request_shutdown (manager);
-
-        return TRUE;
-}
-
-gboolean
-gsm_manager_reboot (GsmManager            *manager,
-                    DBusGMethodInvocation *context)
-{
-        GTask *task;
-        GError *error = NULL;
-
-        g_debug ("GsmManager: Reboot called");
-
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-
-        if (manager->priv->phase != GSM_MANAGER_PHASE_RUNNING) {
-                error = g_error_new (GSM_MANAGER_ERROR,
-                                     GSM_MANAGER_ERROR_NOT_IN_RUNNING,
-                                     "Reboot interface is only available during the Running phase");
-                dbus_g_method_return_error (context, error);
-                g_error_free (error);
-                return FALSE;
-        }
-
-        if (_log_out_is_locked_down (manager)) {
-                error = g_error_new (GSM_MANAGER_ERROR,
-                                     GSM_MANAGER_ERROR_LOCKED_DOWN,
-                                     "Logout has been locked down");
-                dbus_g_method_return_error (context, error);
-                g_error_free (error);
-                return FALSE;
-        }
-
-        task = g_task_new (manager, manager->priv->end_session_cancellable, (GAsyncReadyCallback) complete_end_session_task, context);
-
-        manager->priv->pending_end_session_tasks = g_slist_prepend (manager->priv->pending_end_session_tasks,
-                                                                    task);
-
-        request_reboot (manager);
-
-        return TRUE;
-}
-
-
-gboolean
-gsm_manager_can_shutdown (GsmManager *manager,
-                          gboolean   *shutdown_available,
-                          GError    **error)
-{
-        g_debug ("GsmManager: CanShutdown called");
-
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-
-        *shutdown_available = !_log_out_is_locked_down (manager) &&
-                              (gsm_system_can_stop (manager->priv->system)
-                               || gsm_system_can_restart (manager->priv->system)
-                               || gsm_system_can_suspend (manager->priv->system)
-                               || gsm_system_can_hibernate (manager->priv->system));
-
-        return TRUE;
-}
-
-gboolean
-gsm_manager_logout (GsmManager *manager,
-                    guint       logout_mode,
-                    GError    **error)
-{
-        g_debug ("GsmManager: Logout called");
-
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-
-        if (manager->priv->phase != GSM_MANAGER_PHASE_RUNNING) {
-                g_set_error (error,
-                             GSM_MANAGER_ERROR,
-                             GSM_MANAGER_ERROR_NOT_IN_RUNNING,
-                             "Logout interface is only available during the Running phase");
-                return FALSE;
-        }
-
-        if (_log_out_is_locked_down (manager)) {
-                g_set_error (error,
-                             GSM_MANAGER_ERROR,
-                             GSM_MANAGER_ERROR_LOCKED_DOWN,
-                             "Logout has been locked down");
-                return FALSE;
-        }
-
-        switch (logout_mode) {
-        case GSM_MANAGER_LOGOUT_MODE_NORMAL:
-        case GSM_MANAGER_LOGOUT_MODE_NO_CONFIRMATION:
-        case GSM_MANAGER_LOGOUT_MODE_FORCE:
-                user_logout (manager, logout_mode);
-                break;
-
-        default:
-                g_debug ("Unknown logout mode option");
-
-                g_set_error (error,
-                             GSM_MANAGER_ERROR,
-                             GSM_MANAGER_ERROR_INVALID_OPTION,
-                             "Unknown logout mode flag");
-                return FALSE;
-        }
-
-        return TRUE;
-}
-
-gboolean
-gsm_manager_register_client (GsmManager            *manager,
-                             const char            *app_id,
-                             const char            *startup_id,
-                             DBusGMethodInvocation *context)
-{
-        char      *new_startup_id;
-        char      *sender;
-        GsmClient *client;
-        GsmApp    *app;
-
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-
-        app = NULL;
-        client = NULL;
-
-        g_debug ("GsmManager: RegisterClient %s", startup_id);
-
-        if (manager->priv->phase >= GSM_MANAGER_PHASE_QUERY_END_SESSION) {
-                GError *new_error;
-
-                g_debug ("Unable to register client: shutting down");
-
-                new_error = g_error_new (GSM_MANAGER_ERROR,
-                                         GSM_MANAGER_ERROR_NOT_IN_RUNNING,
-                                         "Unable to register client");
-                dbus_g_method_return_error (context, new_error);
-                g_error_free (new_error);
-                return FALSE;
-        }
-
-        if (IS_STRING_EMPTY (startup_id)) {
-                new_startup_id = gsm_util_generate_startup_id ();
-        } else {
-
-                client = (GsmClient *)gsm_store_find (manager->priv->clients,
-                                                      (GsmStoreFunc)_client_has_startup_id,
-                                                      (char *)startup_id);
-                /* We can't have two clients with the same startup id. */
-                if (client != NULL) {
-                        GError *new_error;
-
-                        g_debug ("Unable to register client: already registered");
-
-                        new_error = g_error_new (GSM_MANAGER_ERROR,
-                                                 GSM_MANAGER_ERROR_ALREADY_REGISTERED,
-                                                 "Unable to register client");
-                        dbus_g_method_return_error (context, new_error);
-                        g_error_free (new_error);
-                        return FALSE;
-                }
-
-                new_startup_id = g_strdup (startup_id);
-        }
-
-        g_debug ("GsmManager: Adding new client %s to session", new_startup_id);
-
-        if (app == NULL && !IS_STRING_EMPTY (startup_id)) {
-                app = find_app_for_startup_id (manager, startup_id);
-        }
-        if (app == NULL && !IS_STRING_EMPTY (app_id)) {
-                /* try to associate this app id with a known app */
-                app = find_app_for_app_id (manager, app_id);
-        }
-
-        sender = dbus_g_method_get_sender (context);
-        client = gsm_dbus_client_new (new_startup_id, sender);
-        g_free (sender);
-        if (client == NULL) {
-                GError *new_error;
-
-                g_debug ("Unable to create client");
-
-                new_error = g_error_new (GSM_MANAGER_ERROR,
-                                         GSM_MANAGER_ERROR_GENERAL,
-                                         "Unable to register client");
-                dbus_g_method_return_error (context, new_error);
-                g_error_free (new_error);
-                return FALSE;
-        }
-
-        gsm_store_add (manager->priv->clients, gsm_client_peek_id (client), G_OBJECT (client));
-        /* the store will own the ref */
-        g_object_unref (client);
-
-        if (app != NULL) {
-                gsm_client_set_app_id (client, gsm_app_peek_app_id (app));
-                gsm_app_registered (app);
-        } else {
-                /* if an app id is specified store it in the client
-                   so we can save it later */
-                gsm_client_set_app_id (client, app_id);
-        }
-
-        gsm_client_set_status (client, GSM_CLIENT_REGISTERED);
-
-        g_assert (new_startup_id != NULL);
-        g_free (new_startup_id);
-
-        dbus_g_method_return (context, gsm_client_peek_id (client));
-
-        return TRUE;
-}
-
-gboolean
-gsm_manager_unregister_client (GsmManager            *manager,
-                               const char            *client_id,
-                               DBusGMethodInvocation *context)
-{
-        GsmClient *client;
-
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-
-        g_debug ("GsmManager: UnregisterClient %s", client_id);
-
-        client = (GsmClient *)gsm_store_lookup (manager->priv->clients, client_id);
-        if (client == NULL) {
-                GError *new_error;
-
-                g_debug ("Unable to unregister client: not registered");
-
-                new_error = g_error_new (GSM_MANAGER_ERROR,
-                                         GSM_MANAGER_ERROR_NOT_REGISTERED,
-                                         "Unable to unregister client");
-                dbus_g_method_return_error (context, new_error);
-                g_error_free (new_error);
-                return FALSE;
-        }
-
-        /* don't disconnect client here, only change the status.
-           Wait until it leaves the bus before disconnecting it */
-        gsm_client_set_status (client, GSM_CLIENT_UNREGISTERED);
-
-        dbus_g_method_return (context);
-
-        return TRUE;
-}
-
-gboolean
-gsm_manager_inhibit (GsmManager            *manager,
-                     const char            *app_id,
-                     guint                  toplevel_xid,
-                     const char            *reason,
-                     guint                  flags,
-                     DBusGMethodInvocation *context)
-{
-        GsmInhibitor *inhibitor;
-        guint         cookie;
-
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-
-        g_debug ("GsmManager: Inhibit xid=%u app_id=%s reason=%s flags=%u",
-                 toplevel_xid,
-                 app_id,
-                 reason,
-                 flags);
-
-        if (manager->priv->logout_mode == GSM_MANAGER_LOGOUT_MODE_FORCE) {
-                GError *new_error;
-
-                new_error = g_error_new (GSM_MANAGER_ERROR,
-                                         GSM_MANAGER_ERROR_GENERAL,
-                                         "Forced logout cannot be inhibited");
-                g_debug ("GsmManager: Unable to inhibit: %s", new_error->message);
-                dbus_g_method_return_error (context, new_error);
-                g_error_free (new_error);
-                return FALSE;
-        }
-
-        if (IS_STRING_EMPTY (app_id)) {
-                GError *new_error;
-
-                new_error = g_error_new (GSM_MANAGER_ERROR,
-                                         GSM_MANAGER_ERROR_GENERAL,
-                                         "Application ID not specified");
-                g_debug ("GsmManager: Unable to inhibit: %s", new_error->message);
-                dbus_g_method_return_error (context, new_error);
-                g_error_free (new_error);
-                return FALSE;
-        }
-
-        if (IS_STRING_EMPTY (reason)) {
-                GError *new_error;
-
-                new_error = g_error_new (GSM_MANAGER_ERROR,
-                                         GSM_MANAGER_ERROR_GENERAL,
-                                         "Reason not specified");
-                g_debug ("GsmManager: Unable to inhibit: %s", new_error->message);
-                dbus_g_method_return_error (context, new_error);
-                g_error_free (new_error);
-                return FALSE;
-        }
-
-        if (flags == 0) {
-                GError *new_error;
-
-                new_error = g_error_new (GSM_MANAGER_ERROR,
-                                         GSM_MANAGER_ERROR_GENERAL,
-                                         "Invalid inhibit flags");
-                g_debug ("GsmManager: Unable to inhibit: %s", new_error->message);
-                dbus_g_method_return_error (context, new_error);
-                g_error_free (new_error);
-                return FALSE;
-        }
-
-        cookie = _generate_unique_cookie (manager);
-        inhibitor = gsm_inhibitor_new (app_id,
-                                       toplevel_xid,
-                                       flags,
-                                       reason,
-                                       dbus_g_method_get_sender (context),
-                                       cookie);
-        gsm_store_add (manager->priv->inhibitors, gsm_inhibitor_peek_id (inhibitor), G_OBJECT (inhibitor));
-        g_object_unref (inhibitor);
-
-        dbus_g_method_return (context, cookie);
-
-        return TRUE;
-}
-
-gboolean
-gsm_manager_uninhibit (GsmManager            *manager,
-                       guint                  cookie,
-                       DBusGMethodInvocation *context)
-{
-        GsmInhibitor *inhibitor;
-
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-
-        g_debug ("GsmManager: Uninhibit %u", cookie);
-
-        inhibitor = (GsmInhibitor *)gsm_store_find (manager->priv->inhibitors,
-                                                    (GsmStoreFunc)_find_by_cookie,
-                                                    &cookie);
-        if (inhibitor == NULL) {
-                GError *new_error;
-
-                new_error = g_error_new (GSM_MANAGER_ERROR,
-                                         GSM_MANAGER_ERROR_GENERAL,
-                                         "Unable to uninhibit: Invalid cookie");
-                dbus_g_method_return_error (context, new_error);
-                g_debug ("Unable to uninhibit: %s", new_error->message);
-                g_error_free (new_error);
-                return FALSE;
-        }
-
-        g_debug ("GsmManager: removing inhibitor %s %u reason '%s' %u connection %s",
-                 gsm_inhibitor_peek_app_id (inhibitor),
-                 gsm_inhibitor_peek_toplevel_xid (inhibitor),
-                 gsm_inhibitor_peek_reason (inhibitor),
-                 gsm_inhibitor_peek_flags (inhibitor),
-                 gsm_inhibitor_peek_bus_name (inhibitor));
-
-        gsm_store_remove (manager->priv->inhibitors, gsm_inhibitor_peek_id (inhibitor));
-
-        dbus_g_method_return (context);
-
-        return TRUE;
-}
-
-gboolean
-gsm_manager_is_inhibited (GsmManager *manager,
-                          guint       flags,
-                          gboolean   *is_inhibited,
-                          GError     *error)
-{
-        GsmInhibitor *inhibitor;
-
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-
-        if (manager->priv->inhibitors == NULL
-            || gsm_store_size (manager->priv->inhibitors) == 0) {
-                *is_inhibited = FALSE;
-                return TRUE;
-        }
-
-        inhibitor = (GsmInhibitor *) gsm_store_find (manager->priv->inhibitors,
-                                                     (GsmStoreFunc)inhibitor_has_flag,
-                                                     GUINT_TO_POINTER (flags));
-        if (inhibitor == NULL) {
-                *is_inhibited = FALSE;
-        } else {
-                *is_inhibited = TRUE;
-        }
-
-        return TRUE;
-
-}
-
-static gboolean
-listify_store_ids (char       *id,
-                   GObject    *object,
-                   GPtrArray **array)
-{
-        g_ptr_array_add (*array, g_strdup (id));
-        return FALSE;
-}
-
-gboolean
-gsm_manager_get_clients (GsmManager *manager,
-                         GPtrArray **clients,
-                         GError    **error)
-{
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-
-        if (clients == NULL) {
-                return FALSE;
-        }
-
-        *clients = g_ptr_array_new ();
-        gsm_store_foreach (manager->priv->clients, (GsmStoreFunc)listify_store_ids, clients);
-
-        return TRUE;
-}
-
-gboolean
-gsm_manager_get_inhibitors (GsmManager *manager,
-                            GPtrArray **inhibitors,
-                            GError    **error)
-{
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-
-        if (inhibitors == NULL) {
-                return FALSE;
-        }
-
-        *inhibitors = g_ptr_array_new ();
-        gsm_store_foreach (manager->priv->inhibitors,
-                           (GsmStoreFunc) listify_store_ids,
-                           inhibitors);
-
-        return TRUE;
-}
-
-
-static gboolean
-_app_has_autostart_condition (const char *id,
-                              GsmApp     *app,
-                              const char *condition)
-{
-        gboolean has;
-        gboolean disabled;
-
-        has = gsm_app_has_autostart_condition (app, condition);
-        disabled = gsm_app_peek_is_disabled (app);
-
-        return has && !disabled;
-}
-
-gboolean
-gsm_manager_is_autostart_condition_handled (GsmManager *manager,
-                                            const char *condition,
-                                            gboolean   *handled,
-                                            GError    **error)
-{
-        GsmApp *app;
-
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-
-        app = (GsmApp *) gsm_store_find (manager->priv->apps,(
-                                         GsmStoreFunc) _app_has_autostart_condition,
-                                         (char *)condition);
-
-        if (app != NULL) {
-                *handled = TRUE;
-        } else {
-                *handled = FALSE;
-        }
-
-        return TRUE;
-}
-
-static void
-append_app (GsmManager *manager,
-            GsmApp     *app,
-            const char *provides,
-            gboolean    is_required)
-{
-        const char *id;
-        const char *app_id;
-        GsmApp     *dup;
-
-        id = gsm_app_peek_id (app);
-        if (IS_STRING_EMPTY (id)) {
-                g_debug ("GsmManager: not adding app: no id");
-                return;
-        }
-
-        dup = (GsmApp *)gsm_store_lookup (manager->priv->apps, id);
-        if (dup != NULL) {
-                g_debug ("GsmManager: not adding app: already added");
-                return;
-        }
-
-        app_id = gsm_app_peek_app_id (app);
-        if (IS_STRING_EMPTY (app_id)) {
-                g_debug ("GsmManager: not adding app: no app-id");
-                return;
-        }
-
-        dup = find_app_for_app_id (manager, app_id);
-        if (dup != NULL) {
-                g_debug ("GsmManager: not adding app: app-id '%s' already exists", app_id);
-
-                if (provides && GSM_IS_AUTOSTART_APP (dup))
-                        gsm_autostart_app_add_provides (GSM_AUTOSTART_APP (dup), provides);
-
-                if (is_required &&
-                    !g_slist_find (manager->priv->required_apps, dup)) {
-                        g_debug ("GsmManager: making app '%s' required", gsm_app_peek_app_id (dup));
-                        manager->priv->required_apps = g_slist_prepend (manager->priv->required_apps, dup);
-                }
-
-                return;
-        }
-
-        gsm_store_add (manager->priv->apps, id, G_OBJECT (app));
-        if (is_required) {
-                g_debug ("GsmManager: adding required app %s", gsm_app_peek_app_id (app));
-                manager->priv->required_apps = g_slist_prepend (manager->priv->required_apps, app);
-        }
-}
-
-static gboolean
-add_autostart_app_internal (GsmManager *manager,
-                            const char *path,
-                            const char *provides,
-                            gboolean    is_required)
-{
-        GsmApp  *app;
-        char   **internal_provides;
-        GError *error = NULL;
-
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-        g_return_val_if_fail (path != NULL, FALSE);
-
-        /* Note: if we cannot add the app because its service is already
-         * provided, because its app-id is taken, or because of any other
-         * reason meaning there is already an app playing its role, then we
-         * should make sure that relevant properties (like
-         * provides/is_required) are set in the pre-existing app if needed. */
-
-        /* first check to see if service is already provided */
-        if (provides != NULL) {
-                GsmApp *dup;
-
-                dup = (GsmApp *)gsm_store_find (manager->priv->apps,
-                                                (GsmStoreFunc)_find_app_provides,
-                                                (char *)provides);
-                if (dup != NULL) {
-                        g_debug ("GsmManager: service '%s' is already provided", provides);
-
-                        if (is_required &&
-                            !g_slist_find (manager->priv->required_apps, dup)) {
-                                g_debug ("GsmManager: making app '%s' required", gsm_app_peek_app_id (dup));
-                                manager->priv->required_apps = g_slist_prepend (manager->priv->required_apps, dup);
-                        }
-
-                        return FALSE;
-                }
-        }
-
-        app = gsm_autostart_app_new (path, &error);
-        if (app == NULL) {
-                g_warning ("%s", error->message);
-                g_clear_error (&error);
-                return FALSE;
-        }
-
-        internal_provides = gsm_app_get_provides (app);
-        if (internal_provides) {
-                int i;
-                gboolean provided = FALSE;
-
-                for (i = 0; internal_provides[i] != NULL; i++) {
-                        GsmApp *dup;
-
-                        dup = (GsmApp *)gsm_store_find (manager->priv->apps,
-                                                        (GsmStoreFunc)_find_app_provides,
-                                                        (char *)internal_provides[i]);
-                        if (dup != NULL) {
-                                g_debug ("GsmManager: service '%s' is already provided", internal_provides[i]);
-
-                                if (is_required &&
-                                    !g_slist_find (manager->priv->required_apps, dup)) {
-                                        g_debug ("GsmManager: making app '%s' required", gsm_app_peek_app_id (dup));
-                                        manager->priv->required_apps = g_slist_prepend (manager->priv->required_apps, dup);
-                                }
-
-                                provided = TRUE;
-                                break;
-                        }
-                }
-
-                g_strfreev (internal_provides);
-
-                if (provided) {
-                        g_object_unref (app);
-                        return FALSE;
-                }
-        }
-
-        if (provides)
-                gsm_autostart_app_add_provides (GSM_AUTOSTART_APP (app), provides);
-
-        g_debug ("GsmManager: read %s", path);
-        append_app (manager, app, provides, is_required);
-        g_object_unref (app);
-
-        return TRUE;
-}
-
-gboolean
-gsm_manager_add_autostart_app (GsmManager *manager,
-                               const char *path,
-                               const char *provides)
-{
-        return add_autostart_app_internal (manager,
-                                           path,
-                                           provides,
-                                           FALSE);
-}
-
-/**
- * gsm_manager_add_required_app:
- * @manager: a #GsmManager
- * @path: Path to desktop file
- * @provides: What the component provides, as a space separated list
- *
- * Similar to gsm_manager_add_autostart_app(), except marks the
- * component as being required; we then try harder to ensure
- * it's running and inform the user if we can't.
- *
- */
-gboolean
-gsm_manager_add_required_app (GsmManager *manager,
-                              const char *path,
-                              const char *provides)
-{
-        return add_autostart_app_internal (manager,
-                                           path,
-                                           provides,
-                                           TRUE);
-}
-
-
-gboolean
-gsm_manager_add_autostart_apps_from_dir (GsmManager *manager,
-                                         const char *path)
-{
-        GDir       *dir;
-        const char *name;
-
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-        g_return_val_if_fail (path != NULL, FALSE);
-
-        g_debug ("GsmManager: *** Adding autostart apps for %s", path);
-
-        dir = g_dir_open (path, 0, NULL);
-        if (dir == NULL) {
-                return FALSE;
-        }
-
-        while ((name = g_dir_read_name (dir))) {
-                char *desktop_file;
-
-                if (!g_str_has_suffix (name, ".desktop")) {
-                        continue;
-                }
-
-                desktop_file = g_build_filename (path, name, NULL);
-                gsm_manager_add_autostart_app (manager, desktop_file, NULL);
-                g_free (desktop_file);
-        }
-
-        g_dir_close (dir);
-
-        return TRUE;
-}
-
-gboolean
-gsm_manager_is_session_running (GsmManager *manager,
-                                gboolean   *running,
-                                GError    **error)
-{
-        g_return_val_if_fail (GSM_IS_MANAGER (manager), FALSE);
-
-        *running = (manager->priv->phase == GSM_MANAGER_PHASE_RUNNING);
-        return TRUE;
-}
-
-static void
-on_shutdown_prepared (GsmSystem  *system,
-                      gboolean    success,
-                      GsmManager *manager)
-{
-        g_debug ("GsmManager: on_shutdown_prepared, success: %d", success);
-        g_signal_handlers_disconnect_by_func (system, on_shutdown_prepared, manager);
-
-        if (success) {
-                /* move to end-session phase */
-                g_assert (manager->priv->phase == GSM_MANAGER_PHASE_QUERY_END_SESSION);
-                manager->priv->phase++;
-                start_phase (manager);
-        } else {
-                disconnect_shell_dialog_signals (manager);
-                gsm_shell_close_end_session_dialog (manager->priv->shell);
-                /* back to running phase */
-                cancel_end_session (manager);
-        }
-}
-
-static gboolean
-do_query_end_session_exit (GsmManager *manager)
-{
-        gboolean reboot = FALSE;
-        gboolean shutdown = FALSE;
-
-        switch (manager->priv->logout_type) {
-        case GSM_MANAGER_LOGOUT_LOGOUT:
-                break;
-        case GSM_MANAGER_LOGOUT_REBOOT:
-        case GSM_MANAGER_LOGOUT_REBOOT_INTERACT:
-                reboot = TRUE;
-                break;
-        case GSM_MANAGER_LOGOUT_SHUTDOWN:
-        case GSM_MANAGER_LOGOUT_SHUTDOWN_INTERACT:
-                shutdown = TRUE;
-                break;
-        default:
-                g_warning ("Unexpected logout type %d in do_query_end_session_exit()",
-                           manager->priv->logout_type);
-                break;
-        }
-
-        if (reboot || shutdown) {
-                g_signal_connect (manager->priv->system, "shutdown-prepared",
-                                  G_CALLBACK (on_shutdown_prepared), manager);
-                gsm_system_prepare_shutdown (manager->priv->system, reboot);
-                return FALSE; /* don't leave query end session yet */
-        }
-
-        return TRUE; /* go to end session phase */
-}
diff --git a/gnome-session/gsm-manager.h b/gnome-session/gsm-manager.h
deleted file mode 100644
index 71bc142..0000000
--- a/gnome-session/gsm-manager.h
+++ /dev/null
@@ -1,206 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2008 William Jon McCann <jmccann@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- */
-
-
-#ifndef __GSM_MANAGER_H
-#define __GSM_MANAGER_H
-
-#include <glib-object.h>
-#include <dbus/dbus-glib.h>
-
-#include "gsm-store.h"
-#include "gsm-manager-logout-mode.h"
-
-G_BEGIN_DECLS
-
-#define GSM_TYPE_MANAGER         (gsm_manager_get_type ())
-#define GSM_MANAGER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GSM_TYPE_MANAGER, GsmManager))
-#define GSM_MANAGER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GSM_TYPE_MANAGER, GsmManagerClass))
-#define GSM_IS_MANAGER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GSM_TYPE_MANAGER))
-#define GSM_IS_MANAGER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GSM_TYPE_MANAGER))
-#define GSM_MANAGER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GSM_TYPE_MANAGER, GsmManagerClass))
-
-typedef struct GsmManagerPrivate GsmManagerPrivate;
-
-typedef struct
-{
-        GObject            parent;
-        GsmManagerPrivate *priv;
-} GsmManager;
-
-typedef struct
-{
-        GObjectClass   parent_class;
-
-        void          (* session_running)     (GsmManager      *manager);
-        void          (* session_over)        (GsmManager      *manager);
-        void          (* session_over_notice) (GsmManager      *manager);
-
-        void          (* phase_changed)       (GsmManager      *manager,
-                                               const char      *phase);
-
-        void          (* client_added)        (GsmManager      *manager,
-                                               const char      *id);
-        void          (* client_removed)      (GsmManager      *manager,
-                                               const char      *id);
-        void          (* inhibitor_added)     (GsmManager      *manager,
-                                               const char      *id);
-        void          (* inhibitor_removed)   (GsmManager      *manager,
-                                               const char      *id);
-} GsmManagerClass;
-
-typedef enum {
-        /* gsm's own startup/initialization phase */
-        GSM_MANAGER_PHASE_STARTUP = 0,
-        /* gnome-initial-setup */
-        GSM_MANAGER_PHASE_EARLY_INITIALIZATION,
-        /* wayland compositor and XWayland */
-        GSM_MANAGER_PHASE_DISPLAY_SERVER,
-        /* xrandr setup, gnome-settings-daemon, etc */
-        GSM_MANAGER_PHASE_INITIALIZATION,
-        /* window/compositing managers */
-        GSM_MANAGER_PHASE_WINDOW_MANAGER,
-        /* apps that will create _NET_WM_WINDOW_TYPE_PANEL windows */
-        GSM_MANAGER_PHASE_PANEL,
-        /* apps that will create _NET_WM_WINDOW_TYPE_DESKTOP windows */
-        GSM_MANAGER_PHASE_DESKTOP,
-        /* everything else */
-        GSM_MANAGER_PHASE_APPLICATION,
-        /* done launching */
-        GSM_MANAGER_PHASE_RUNNING,
-        /* shutting down */
-        GSM_MANAGER_PHASE_QUERY_END_SESSION,
-        GSM_MANAGER_PHASE_END_SESSION,
-        GSM_MANAGER_PHASE_EXIT
-} GsmManagerPhase;
-
-typedef enum
-{
-        GSM_MANAGER_ERROR_GENERAL = 0,
-        GSM_MANAGER_ERROR_NOT_IN_INITIALIZATION,
-        GSM_MANAGER_ERROR_NOT_IN_RUNNING,
-        GSM_MANAGER_ERROR_ALREADY_REGISTERED,
-        GSM_MANAGER_ERROR_NOT_REGISTERED,
-        GSM_MANAGER_ERROR_INVALID_OPTION,
-        GSM_MANAGER_ERROR_LOCKED_DOWN,
-        GSM_MANAGER_NUM_ERRORS
-} GsmManagerError;
-
-#define GSM_MANAGER_ERROR gsm_manager_error_quark ()
-
-GType               gsm_manager_error_get_type                 (void);
-#define GSM_MANAGER_TYPE_ERROR (gsm_manager_error_get_type ())
-
-GQuark              gsm_manager_error_quark                    (void);
-GType               gsm_manager_get_type                       (void);
-
-GsmManager *        gsm_manager_new                            (GsmStore       *client_store,
-                                                                gboolean        failsafe);
-GsmManager *        gsm_manager_get                            (void);
-
-gboolean            gsm_manager_get_failsafe                   (GsmManager     *manager);
-
-gboolean            gsm_manager_add_autostart_app              (GsmManager     *manager,
-                                                                const char     *path,
-                                                                const char     *provides);
-gboolean            gsm_manager_add_required_app               (GsmManager     *manager,
-                                                                const char     *path,
-                                                                const char     *provides);
-gboolean            gsm_manager_add_autostart_apps_from_dir    (GsmManager     *manager,
-                                                                const char     *path);
-gboolean            gsm_manager_add_legacy_session_apps        (GsmManager     *manager,
-                                                                const char     *path);
-
-void                gsm_manager_start                          (GsmManager     *manager);
-
-const char *        _gsm_manager_get_default_session           (GsmManager     *manager);
-
-void                _gsm_manager_set_active_session            (GsmManager     *manager,
-                                                                const char     *session_name,
-                                                                gboolean        is_fallback);
-
-/* exported methods */
-
-gboolean            gsm_manager_register_client                (GsmManager            *manager,
-                                                                const char            *app_id,
-                                                                const char            *client_startup_id,
-                                                                DBusGMethodInvocation *context);
-gboolean            gsm_manager_unregister_client              (GsmManager            *manager,
-                                                                const char            *session_client_id,
-                                                                DBusGMethodInvocation *context);
-
-gboolean            gsm_manager_inhibit                        (GsmManager            *manager,
-                                                                const char            *app_id,
-                                                                guint                  toplevel_xid,
-                                                                const char            *reason,
-                                                                guint                  flags,
-                                                                DBusGMethodInvocation *context);
-gboolean            gsm_manager_uninhibit                      (GsmManager            *manager,
-                                                                guint                  inhibit_cookie,
-                                                                DBusGMethodInvocation *context);
-gboolean            gsm_manager_is_inhibited                   (GsmManager            *manager,
-                                                                guint                  flags,
-                                                                gboolean              *is_inhibited,
-                                                                GError                *error);
-
-gboolean            gsm_manager_shutdown                       (GsmManager     *manager,
-                                                                DBusGMethodInvocation *context);
-gboolean            gsm_manager_reboot                         (GsmManager     *manager,
-                                                                DBusGMethodInvocation *context);
-
-gboolean            gsm_manager_can_shutdown                   (GsmManager     *manager,
-                                                                gboolean       *shutdown_available,
-                                                                GError        **error);
-gboolean            gsm_manager_logout                         (GsmManager     *manager,
-                                                                guint           logout_mode,
-                                                                GError        **error);
-
-gboolean            gsm_manager_setenv                         (GsmManager     *manager,
-                                                                const char     *variable,
-                                                                const char     *value,
-                                                                GError        **error);
-gboolean            gsm_manager_get_locale                     (GsmManager     *manager,
-                                                                int             category,
-                                                                const char    **value,
-                                                                GError        **error);
-gboolean            gsm_manager_initialization_error           (GsmManager     *manager,
-                                                                const char     *message,
-                                                                gboolean        fatal,
-                                                                GError        **error);
-
-gboolean            gsm_manager_get_clients                    (GsmManager     *manager,
-                                                                GPtrArray     **clients,
-                                                                GError        **error);
-gboolean            gsm_manager_get_inhibitors                 (GsmManager     *manager,
-                                                                GPtrArray     **inhibitors,
-                                                                GError        **error);
-gboolean            gsm_manager_is_autostart_condition_handled (GsmManager     *manager,
-                                                                const char     *condition,
-                                                                gboolean       *handled,
-                                                                GError        **error);
-gboolean            gsm_manager_set_phase                      (GsmManager     *manager,
-                                                                GsmManagerPhase phase);
-gboolean            gsm_manager_is_session_running             (GsmManager     *manager,
-                                                                gboolean       *running,
-                                                                GError        **error);
-
-G_END_DECLS
-
-#endif /* __GSM_MANAGER_H */
diff --git a/gnome-session/gsm-presence-flag.h b/gnome-session/gsm-presence-flag.h
deleted file mode 100644
index 2a0b674..0000000
--- a/gnome-session/gsm-presence-flag.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2009 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#ifndef __GSM_PRESENCE_FLAG_H__
-#define __GSM_PRESENCE_FLAG_H__
-
-G_BEGIN_DECLS
-
-typedef enum {
-        GSM_PRESENCE_STATUS_AVAILABLE = 0,
-        GSM_PRESENCE_STATUS_INVISIBLE,
-        GSM_PRESENCE_STATUS_BUSY,
-        GSM_PRESENCE_STATUS_IDLE,
-} GsmPresenceStatus;
-
-G_END_DECLS
-
-#endif /* __GSM_PRESENCE_FLAG_H__ */
diff --git a/gnome-session/gsm-presence.c b/gnome-session/gsm-presence.c
deleted file mode 100644
index e42745f..0000000
--- a/gnome-session/gsm-presence.c
+++ /dev/null
@@ -1,560 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2009 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#include "config.h"
-
-#include <fcntl.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <unistd.h>
-
-#include <dbus/dbus-glib.h>
-
-#define GNOME_DESKTOP_USE_UNSTABLE_API
-#include <libgnome-desktop/gnome-idle-monitor.h>
-
-#include "gsm-presence.h"
-#include "gsm-presence-glue.h"
-
-#define GSM_PRESENCE_DBUS_PATH "/org/gnome/SessionManager/Presence"
-
-#define GS_NAME      "org.gnome.ScreenSaver"
-#define GS_PATH      "/org/gnome/ScreenSaver"
-#define GS_INTERFACE "org.gnome.ScreenSaver"
-
-#define MAX_STATUS_TEXT 140
-
-#define GSM_PRESENCE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSM_TYPE_PRESENCE, GsmPresencePrivate))
-
-struct GsmPresencePrivate
-{
-        guint             status;
-        guint             saved_status;
-        char             *status_text;
-        gboolean          idle_enabled;
-        GnomeIdleMonitor *idle_monitor;
-        guint             idle_watch_id;
-        guint             idle_timeout;
-        gboolean          screensaver_active;
-        DBusGConnection  *bus_connection;
-        DBusGProxy       *bus_proxy;
-        DBusGProxy       *screensaver_proxy;
-};
-
-enum {
-        PROP_0,
-        PROP_STATUS,
-        PROP_STATUS_TEXT,
-        PROP_IDLE_ENABLED,
-        PROP_IDLE_TIMEOUT,
-};
-
-
-enum {
-        STATUS_CHANGED,
-        STATUS_TEXT_CHANGED,
-        LAST_SIGNAL
-};
-
-static guint signals [LAST_SIGNAL] = { 0 };
-
-G_DEFINE_TYPE (GsmPresence, gsm_presence, G_TYPE_OBJECT)
-
-GQuark
-gsm_presence_error_quark (void)
-{
-        static GQuark ret = 0;
-        if (ret == 0) {
-                ret = g_quark_from_static_string ("gsm_presence_error");
-        }
-
-        return ret;
-}
-
-#define ENUM_ENTRY(NAME, DESC) { NAME, "" #NAME "", DESC }
-
-GType
-gsm_presence_error_get_type (void)
-{
-        static GType etype = 0;
-
-        if (etype == 0) {
-                static const GEnumValue values[] = {
-                        ENUM_ENTRY (GSM_PRESENCE_ERROR_GENERAL, "GeneralError"),
-                        { 0, 0, 0 }
-                };
-
-                g_assert (GSM_PRESENCE_NUM_ERRORS == G_N_ELEMENTS (values) - 1);
-
-                etype = g_enum_register_static ("GsmPresenceError", values);
-        }
-
-        return etype;
-}
-
-static void idle_became_active_cb (GnomeIdleMonitor *idle_monitor,
-                                   guint             id,
-                                   gpointer          user_data);
-
-static void
-set_session_idle (GsmPresence   *presence,
-                  gboolean       is_idle)
-{
-        g_debug ("GsmPresence: setting idle: %d", is_idle);
-
-        if (is_idle) {
-                if (presence->priv->status == GSM_PRESENCE_STATUS_IDLE) {
-                        g_debug ("GsmPresence: already idle, ignoring");
-                        return;
-                }
-
-                /* save current status */
-                presence->priv->saved_status = presence->priv->status;
-                gsm_presence_set_status (presence, GSM_PRESENCE_STATUS_IDLE, NULL);
-
-                gnome_idle_monitor_add_user_active_watch (presence->priv->idle_monitor,
-                                                          idle_became_active_cb,
-                                                          presence,
-                                                          NULL);
-        } else {
-                if (presence->priv->status != GSM_PRESENCE_STATUS_IDLE) {
-                        g_debug ("GsmPresence: already not idle, ignoring");
-                        return;
-                }
-
-                /* restore saved status */
-                gsm_presence_set_status (presence, presence->priv->saved_status, NULL);
-                g_debug ("GsmPresence: setting non-idle status %d", presence->priv->saved_status);
-                presence->priv->saved_status = GSM_PRESENCE_STATUS_AVAILABLE;
-        }
-}
-
-static void
-idle_became_idle_cb (GnomeIdleMonitor *idle_monitor,
-                     guint             id,
-                     gpointer          user_data)
-{
-        GsmPresence *presence = user_data;
-        /* We should already be idle,
-         * see on_screensaver_active_changed() */
-        if (!presence->priv->screensaver_active)
-                set_session_idle (presence, TRUE);
-}
-
-static void
-idle_became_active_cb (GnomeIdleMonitor *idle_monitor,
-                       guint             id,
-                       gpointer          user_data)
-{
-        GsmPresence *presence = user_data;
-        /* We can only be non-idle if the screensaver is gone */
-        if (!presence->priv->screensaver_active)
-                set_session_idle (presence, FALSE);
-}
-
-static void
-reset_idle_watch (GsmPresence  *presence)
-{
-        if (presence->priv->idle_watch_id > 0) {
-                g_debug ("GsmPresence: removing idle watch (%i)", presence->priv->idle_watch_id);
-                gnome_idle_monitor_remove_watch (presence->priv->idle_monitor,
-                                                 presence->priv->idle_watch_id);
-                presence->priv->idle_watch_id = 0;
-        }
-
-        if (presence->priv->idle_enabled
-            && presence->priv->idle_timeout > 0) {
-                presence->priv->idle_watch_id = gnome_idle_monitor_add_idle_watch (presence->priv->idle_monitor,
-                                                                                   presence->priv->idle_timeout,
-                                                                                   idle_became_idle_cb,
-                                                                                   presence,
-                                                                                   NULL);
-                g_debug ("GsmPresence: adding idle watch (%i) for %d secs",
-                         presence->priv->idle_watch_id,
-                         presence->priv->idle_timeout / 1000);
-        }
-}
-
-static void
-on_screensaver_active_changed (DBusGProxy  *proxy,
-                               gboolean     is_active,
-                               GsmPresence *presence)
-{
-        g_debug ("screensaver status changed: %d", is_active);
-        if (presence->priv->screensaver_active != is_active) {
-                presence->priv->screensaver_active = is_active;
-                set_session_idle (presence, is_active);
-        }
-}
-
-static void
-on_screensaver_proxy_destroy (GObject     *proxy,
-                              GsmPresence *presence)
-{
-        g_debug ("Detected that screensaver has left the bus");
-
-        presence->priv->screensaver_proxy = NULL;
-        presence->priv->screensaver_active = FALSE;
-        set_session_idle (presence, FALSE);
-}
-
-static void
-on_bus_name_owner_changed (DBusGProxy  *bus_proxy,
-                           const char  *service_name,
-                           const char  *old_service_name,
-                           const char  *new_service_name,
-                           GsmPresence *presence)
-{
-        GError *error;
-
-        if (service_name == NULL
-            || strcmp (service_name, GS_NAME) != 0) {
-                /* ignore */
-                return;
-        }
-
-        if (strlen (new_service_name) == 0
-            && strlen (old_service_name) > 0) {
-                /* service removed */
-                /* let destroy signal handle this? */
-        } else if (strlen (old_service_name) == 0
-                   && strlen (new_service_name) > 0) {
-                /* service added */
-
-                g_debug ("Detected that screensaver has appeared on the bus");
-
-                error = NULL;
-                presence->priv->screensaver_proxy = dbus_g_proxy_new_for_name_owner (presence->priv->bus_connection,
-                                                                                     GS_NAME,
-                                                                                     GS_PATH,
-                                                                                     GS_INTERFACE,
-                                                                                     &error);
-                if (presence->priv->screensaver_proxy != NULL) {
-                        g_signal_connect (presence->priv->screensaver_proxy,
-                                          "destroy",
-                                          G_CALLBACK (on_screensaver_proxy_destroy),
-                                          presence);
-                        dbus_g_proxy_add_signal (presence->priv->screensaver_proxy,
-                                                 "ActiveChanged",
-                                                 G_TYPE_BOOLEAN,
-                                                 G_TYPE_INVALID);
-                        dbus_g_proxy_connect_signal (presence->priv->screensaver_proxy,
-                                                     "ActiveChanged",
-                                                     G_CALLBACK (on_screensaver_active_changed),
-                                                     presence,
-                                                     NULL);
-                } else {
-                        g_warning ("Unable to get screensaver proxy: %s", error->message);
-                        g_error_free (error);
-                }
-        }
-}
-
-static gboolean
-register_presence (GsmPresence *presence)
-{
-        GError *error;
-
-        error = NULL;
-        presence->priv->bus_connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
-        if (presence->priv->bus_connection == NULL) {
-                if (error != NULL) {
-                        g_critical ("error getting session bus: %s", error->message);
-                        g_error_free (error);
-                }
-                return FALSE;
-        }
-
-        dbus_g_connection_register_g_object (presence->priv->bus_connection, GSM_PRESENCE_DBUS_PATH, G_OBJECT (presence));
-
-        return TRUE;
-}
-
-static GObject *
-gsm_presence_constructor (GType                  type,
-                          guint                  n_construct_properties,
-                          GObjectConstructParam *construct_properties)
-{
-        GsmPresence *presence;
-        gboolean     res;
-
-        presence = GSM_PRESENCE (G_OBJECT_CLASS (gsm_presence_parent_class)->constructor (type,
-                                                                                             n_construct_properties,
-                                                                                             construct_properties));
-
-        res = register_presence (presence);
-        if (! res) {
-                g_warning ("Unable to register presence with session bus");
-        }
-
-        presence->priv->bus_proxy = dbus_g_proxy_new_for_name (presence->priv->bus_connection,
-                                                               DBUS_SERVICE_DBUS,
-                                                               DBUS_PATH_DBUS,
-                                                               DBUS_INTERFACE_DBUS);
-        if (presence->priv->bus_proxy != NULL) {
-                dbus_g_proxy_add_signal (presence->priv->bus_proxy,
-                                         "NameOwnerChanged",
-                                         G_TYPE_STRING,
-                                         G_TYPE_STRING,
-                                         G_TYPE_STRING,
-                                         G_TYPE_INVALID);
-                dbus_g_proxy_connect_signal (presence->priv->bus_proxy,
-                                             "NameOwnerChanged",
-                                             G_CALLBACK (on_bus_name_owner_changed),
-                                             presence,
-                                             NULL);
-        }
-
-        return G_OBJECT (presence);
-}
-
-static void
-gsm_presence_init (GsmPresence *presence)
-{
-        presence->priv = GSM_PRESENCE_GET_PRIVATE (presence);
-
-        presence->priv->idle_monitor = gnome_idle_monitor_new ();
-}
-
-void
-gsm_presence_set_idle_enabled (GsmPresence  *presence,
-                               gboolean      enabled)
-{
-        g_return_if_fail (GSM_IS_PRESENCE (presence));
-
-        if (presence->priv->idle_enabled != enabled) {
-                presence->priv->idle_enabled = enabled;
-                reset_idle_watch (presence);
-                g_object_notify (G_OBJECT (presence), "idle-enabled");
-
-        }
-}
-
-gboolean
-gsm_presence_set_status_text (GsmPresence  *presence,
-                              const char   *status_text,
-                              GError      **error)
-{
-        g_return_val_if_fail (GSM_IS_PRESENCE (presence), FALSE);
-
-        g_free (presence->priv->status_text);
-
-        /* check length */
-        if (status_text != NULL && strlen (status_text) > MAX_STATUS_TEXT) {
-                g_set_error (error,
-                             GSM_PRESENCE_ERROR,
-                             GSM_PRESENCE_ERROR_GENERAL,
-                             "Status text too long");
-                return FALSE;
-        }
-
-        if (status_text != NULL) {
-                presence->priv->status_text = g_strdup (status_text);
-        } else {
-                presence->priv->status_text = g_strdup ("");
-        }
-        g_object_notify (G_OBJECT (presence), "status-text");
-        g_signal_emit (presence, signals[STATUS_TEXT_CHANGED], 0, presence->priv->status_text);
-        return TRUE;
-}
-
-gboolean
-gsm_presence_set_status (GsmPresence  *presence,
-                         guint         status,
-                         GError      **error)
-{
-        g_return_val_if_fail (GSM_IS_PRESENCE (presence), FALSE);
-
-        if (status != presence->priv->status) {
-                presence->priv->status = status;
-                g_object_notify (G_OBJECT (presence), "status");
-                g_signal_emit (presence, signals[STATUS_CHANGED], 0, presence->priv->status);
-        }
-        return TRUE;
-}
-
-void
-gsm_presence_set_idle_timeout (GsmPresence  *presence,
-                               guint         timeout)
-{
-        g_return_if_fail (GSM_IS_PRESENCE (presence));
-
-        if (timeout != presence->priv->idle_timeout) {
-                presence->priv->idle_timeout = timeout;
-                reset_idle_watch (presence);
-                g_object_notify (G_OBJECT (presence), "idle-timeout");
-        }
-}
-
-static void
-gsm_presence_set_property (GObject       *object,
-                           guint          prop_id,
-                           const GValue  *value,
-                           GParamSpec    *pspec)
-{
-        GsmPresence *self;
-
-        self = GSM_PRESENCE (object);
-
-        switch (prop_id) {
-        case PROP_STATUS:
-                gsm_presence_set_status (self, g_value_get_uint (value), NULL);
-                break;
-        case PROP_STATUS_TEXT:
-                gsm_presence_set_status_text (self, g_value_get_string (value), NULL);
-                break;
-        case PROP_IDLE_ENABLED:
-                gsm_presence_set_idle_enabled (self, g_value_get_boolean (value));
-                break;
-        case PROP_IDLE_TIMEOUT:
-                gsm_presence_set_idle_timeout (self, g_value_get_uint (value));
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_presence_get_property (GObject    *object,
-                           guint       prop_id,
-                           GValue     *value,
-                           GParamSpec *pspec)
-{
-        GsmPresence *self;
-
-        self = GSM_PRESENCE (object);
-
-        switch (prop_id) {
-        case PROP_STATUS:
-                g_value_set_uint (value, self->priv->status);
-                break;
-        case PROP_STATUS_TEXT:
-                g_value_set_string (value, self->priv->status_text);
-                break;
-        case PROP_IDLE_ENABLED:
-                g_value_set_boolean (value, self->priv->idle_enabled);
-                break;
-        case PROP_IDLE_TIMEOUT:
-                g_value_set_uint (value, self->priv->idle_timeout);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_presence_finalize (GObject *object)
-{
-        GsmPresence *presence = (GsmPresence *) object;
-
-        if (presence->priv->idle_watch_id > 0) {
-                gnome_idle_monitor_remove_watch (presence->priv->idle_monitor,
-                                                 presence->priv->idle_watch_id);
-                presence->priv->idle_watch_id = 0;
-        }
-
-        g_clear_pointer (&presence->priv->status_text, g_free);
-        g_clear_object (&presence->priv->idle_monitor);
-
-        G_OBJECT_CLASS (gsm_presence_parent_class)->finalize (object);
-}
-
-static void
-gsm_presence_class_init (GsmPresenceClass *klass)
-{
-        GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-        object_class->finalize             = gsm_presence_finalize;
-        object_class->constructor          = gsm_presence_constructor;
-        object_class->get_property         = gsm_presence_get_property;
-        object_class->set_property         = gsm_presence_set_property;
-
-        signals [STATUS_CHANGED] =
-                g_signal_new ("status-changed",
-                              G_TYPE_FROM_CLASS (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmPresenceClass, status_changed),
-                              NULL,
-                              NULL,
-                              g_cclosure_marshal_VOID__UINT,
-                              G_TYPE_NONE,
-                              1, G_TYPE_UINT);
-        signals [STATUS_TEXT_CHANGED] =
-                g_signal_new ("status-text-changed",
-                              G_TYPE_FROM_CLASS (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmPresenceClass, status_text_changed),
-                              NULL,
-                              NULL,
-                              g_cclosure_marshal_VOID__STRING,
-                              G_TYPE_NONE,
-                              1, G_TYPE_STRING);
-
-        g_object_class_install_property (object_class,
-                                         PROP_STATUS,
-                                         g_param_spec_uint ("status",
-                                                            "status",
-                                                            "status",
-                                                            0,
-                                                            G_MAXINT,
-                                                            0,
-                                                            G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-        g_object_class_install_property (object_class,
-                                         PROP_STATUS_TEXT,
-                                         g_param_spec_string ("status-text",
-                                                              "status text",
-                                                              "status text",
-                                                              "",
-                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-        g_object_class_install_property (object_class,
-                                         PROP_IDLE_ENABLED,
-                                         g_param_spec_boolean ("idle-enabled",
-                                                               NULL,
-                                                               NULL,
-                                                               FALSE,
-                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-        g_object_class_install_property (object_class,
-                                         PROP_IDLE_TIMEOUT,
-                                         g_param_spec_uint ("idle-timeout",
-                                                            "idle timeout",
-                                                            "idle timeout",
-                                                            0,
-                                                            G_MAXINT,
-                                                            120000,
-                                                            G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-
-        dbus_g_object_type_install_info (GSM_TYPE_PRESENCE, &dbus_glib_gsm_presence_object_info);
-        dbus_g_error_domain_register (GSM_PRESENCE_ERROR, NULL, GSM_PRESENCE_TYPE_ERROR);
-        g_type_class_add_private (klass, sizeof (GsmPresencePrivate));
-}
-
-GsmPresence *
-gsm_presence_new (void)
-{
-        GsmPresence *presence;
-
-        presence = g_object_new (GSM_TYPE_PRESENCE,
-                                 NULL);
-
-        return presence;
-}
diff --git a/gnome-session/gsm-presence.h b/gnome-session/gsm-presence.h
deleted file mode 100644
index 80ec520..0000000
--- a/gnome-session/gsm-presence.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2009 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#ifndef __GSM_PRESENCE_H__
-#define __GSM_PRESENCE_H__
-
-#include <glib-object.h>
-#include <sys/types.h>
-
-#include "gsm-presence-flag.h"
-
-G_BEGIN_DECLS
-
-#define GSM_TYPE_PRESENCE            (gsm_presence_get_type ())
-#define GSM_PRESENCE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSM_TYPE_PRESENCE, GsmPresence))
-#define GSM_PRESENCE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GSM_TYPE_PRESENCE, GsmPresenceClass))
-#define GSM_IS_PRESENCE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSM_TYPE_PRESENCE))
-#define GSM_IS_PRESENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GSM_TYPE_PRESENCE))
-#define GSM_PRESENCE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GSM_TYPE_PRESENCE, GsmPresenceClass))
-
-typedef struct _GsmPresence        GsmPresence;
-typedef struct _GsmPresenceClass   GsmPresenceClass;
-
-typedef struct GsmPresencePrivate GsmPresencePrivate;
-
-struct _GsmPresence
-{
-        GObject             parent;
-        GsmPresencePrivate *priv;
-};
-
-struct _GsmPresenceClass
-{
-        GObjectClass parent_class;
-
-        void          (* status_changed)        (GsmPresence     *presence,
-                                                 guint            status);
-        void          (* status_text_changed)   (GsmPresence     *presence,
-                                                 const char      *status_text);
-
-};
-
-typedef enum
-{
-        GSM_PRESENCE_ERROR_GENERAL = 0,
-        GSM_PRESENCE_NUM_ERRORS
-} GsmPresenceError;
-
-#define GSM_PRESENCE_ERROR gsm_presence_error_quark ()
-GType          gsm_presence_error_get_type       (void);
-#define GSM_PRESENCE_TYPE_ERROR (gsm_presence_error_get_type ())
-
-GQuark         gsm_presence_error_quark          (void);
-
-GType          gsm_presence_get_type             (void) G_GNUC_CONST;
-
-GsmPresence *  gsm_presence_new                  (void);
-
-void           gsm_presence_set_idle_enabled     (GsmPresence  *presence,
-                                                  gboolean      enabled);
-void           gsm_presence_set_idle_timeout     (GsmPresence  *presence,
-                                                  guint         n_seconds);
-
-/* exported to bus */
-gboolean       gsm_presence_set_status           (GsmPresence  *presence,
-                                                  guint         status,
-                                                  GError      **error);
-gboolean       gsm_presence_set_status_text      (GsmPresence  *presence,
-                                                  const char   *status_text,
-                                                  GError      **error);
-
-G_END_DECLS
-
-#endif /* __GSM_PRESENCE_H__ */
diff --git a/gnome-session/gsm-process-helper.c b/gnome-session/gsm-process-helper.c
deleted file mode 100644
index d7f3aae..0000000
--- a/gnome-session/gsm-process-helper.c
+++ /dev/null
@@ -1,138 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2010 Novell, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#include <config.h>
-
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <signal.h>
-
-#include <glib.h>
-#include <glib/gi18n.h>
-
-#include "gsm-process-helper.h"
-
-typedef struct {
-        const char *command_line;
-        GPid        pid;
-        gboolean    timed_out;
-        int         status;
-        GMainLoop  *loop;
-        guint       child_id;
-        guint       timeout_id;
-} GsmProcessHelper;
-
-static void
-on_child_exited (GPid     pid,
-                 gint     status,
-                 gpointer data)
-{
-        GsmProcessHelper *helper = data;
-
-        helper->timed_out = FALSE;
-        helper->status = status;
-
-        g_spawn_close_pid (pid);
-        g_main_loop_quit (helper->loop);
-}
-
-static gboolean
-on_child_timeout (gpointer data)
-{
-        GsmProcessHelper *helper = data;
-
-        kill (helper->pid, SIGTERM);
-        helper->timed_out = TRUE;
-        g_main_loop_quit (helper->loop);
-
-        return FALSE;
-}
-
-gboolean
-gsm_process_helper (const char   *command_line,
-                    unsigned int  timeout,
-                    GError      **error)
-{
-        GsmProcessHelper *helper;
-        gchar **argv = NULL;
-        GPid pid;
-        gboolean ret;
-
-        if (!g_shell_parse_argv (command_line, NULL, &argv, error))
-                return FALSE;
-
-        ret = g_spawn_async (NULL,
-                             argv,
-                             NULL,
-                             G_SPAWN_SEARCH_PATH|G_SPAWN_DO_NOT_REAP_CHILD,
-                             NULL,
-                             NULL,
-                             &pid,
-                             error);
-
-        g_strfreev (argv);
-
-        if (!ret)
-                return FALSE;
-
-        ret = FALSE;
-
-        helper = g_slice_new0 (GsmProcessHelper);
-
-        helper->command_line = command_line;
-        helper->pid = pid;
-        helper->timed_out = FALSE;
-        helper->status = -1;
-
-        helper->loop = g_main_loop_new (NULL, FALSE);
-        helper->child_id = g_child_watch_add (helper->pid, on_child_exited, helper);
-        helper->timeout_id = g_timeout_add (timeout, on_child_timeout, helper);
-
-        g_main_loop_run (helper->loop);
-
-        if (helper->timed_out) {
-                g_set_error_literal (error,
-                                     G_IO_CHANNEL_ERROR,
-                                     G_IO_CHANNEL_ERROR_FAILED,
-                                     "Timed out");
-        } else {
-                if (g_spawn_check_exit_status (helper->status, error))
-                        ret = TRUE;
-        }
-
-        if (helper->loop) {
-                g_main_loop_unref (helper->loop);
-                helper->loop = NULL;
-        }
-
-        if (helper->child_id) {
-                g_source_remove (helper->child_id);
-                helper->child_id = 0;
-        }
-
-        if (helper->timeout_id) {
-                g_source_remove (helper->timeout_id);
-                helper->timeout_id = 0;
-        }
-
-        g_slice_free (GsmProcessHelper, helper);
-
-        return ret;
-}
diff --git a/gnome-session/gsm-process-helper.h b/gnome-session/gsm-process-helper.h
deleted file mode 100644
index f02ca37..0000000
--- a/gnome-session/gsm-process-helper.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2010 Novell, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#ifndef __GSM_PROCESS_HELPER_H
-#define __GSM_PROCESS_HELPER_H
-
-#include <glib.h>
-
-G_BEGIN_DECLS
-
-int  gsm_process_helper (const char    *command_line,
-                         unsigned int   timeout,
-                         GError       **error);
-
-G_END_DECLS
-
-#endif /* __GSM_PROCESS_HELPER_H */
diff --git a/gnome-session/gsm-session-fill.c b/gnome-session/gsm-session-fill.c
deleted file mode 100644
index d01e34d..0000000
--- a/gnome-session/gsm-session-fill.c
+++ /dev/null
@@ -1,339 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2006, 2010 Novell, Inc.
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#include <config.h>
-
-#include "gsm-session-fill.h"
-
-#include "gsm-system.h"
-#include "gsm-manager.h"
-#include "gsm-process-helper.h"
-#include "gsm-util.h"
-
-#define GSM_KEYFILE_SESSION_GROUP "GNOME Session"
-#define GSM_KEYFILE_RUNNABLE_KEY "IsRunnableHelper"
-#define GSM_KEYFILE_FALLBACK_KEY "FallbackSession"
-#define GSM_KEYFILE_REQUIRED_COMPONENTS_KEY "RequiredComponents"
-
-/* See https://bugzilla.gnome.org/show_bug.cgi?id=641992 for discussion */
-#define GSM_RUNNABLE_HELPER_TIMEOUT 3000 /* ms */
-
-typedef void (*GsmFillHandleComponent) (const char *component,
-                                        const char *app_path,
-                                        gpointer    user_data);
-
-static void
-handle_required_components (GKeyFile               *keyfile,
-                            gboolean                look_in_saved_session,
-                            GsmFillHandleComponent  callback,
-                            gpointer                user_data)
-{
-        char **required_components;
-        int    i;
-
-        g_assert (keyfile != NULL);
-        g_assert (callback != NULL);
-
-        required_components = g_key_file_get_string_list (keyfile,
-                                                          GSM_KEYFILE_SESSION_GROUP,
-                                                          GSM_KEYFILE_REQUIRED_COMPONENTS_KEY,
-                                                          NULL, NULL);
-
-        if (!required_components)
-                return;
-
-        for (i = 0; required_components[i] != NULL; i++) {
-                char *app_path;
-
-                app_path = gsm_util_find_desktop_file_for_app_name (required_components[i],
-                                                                    look_in_saved_session, TRUE);
-                callback (required_components[i], app_path, user_data);
-                g_free (app_path);
-        }
-
-        g_strfreev (required_components);
-}
-
-static void
-check_required_components_helper (const char *component,
-                                  const char *app_path,
-                                  gpointer    user_data)
-{
-        gboolean *error = user_data;
-
-        if (app_path == NULL) {
-                g_warning ("Unable to find required component '%s'", component);
-                *error = TRUE;
-        }
-}
-
-static gboolean
-check_required (GKeyFile *keyfile)
-{
-        gboolean error = FALSE;
-
-        g_debug ("fill: *** Checking required components");
-
-        handle_required_components (keyfile, FALSE,
-                                    check_required_components_helper, &error);
-
-        g_debug ("fill: *** Done checking required components");
-
-        return !error;
-}
-
-static void
-maybe_load_saved_session_apps (GsmManager *manager)
-{
-        GsmSystem *system;
-        gboolean is_login;
-
-        system = gsm_get_system ();
-        is_login = gsm_system_is_login_session (system);
-        g_object_unref (system);
-
-        if (is_login)
-                return;
-
-        gsm_manager_add_autostart_apps_from_dir (manager, gsm_util_get_saved_session_dir ());
-}
-
-static void
-append_required_components_helper (const char *component,
-                                   const char *app_path,
-                                   gpointer    user_data)
-{
-        GsmManager *manager = user_data;
-
-        if (app_path == NULL)
-                g_warning ("Unable to find required component '%s'", component);
-        else
-                gsm_manager_add_required_app (manager, app_path, NULL);
-}
-
-
-static void
-load_standard_apps (GsmManager *manager,
-                    GKeyFile   *keyfile)
-{
-        g_debug ("fill: *** Adding required components");
-        handle_required_components (keyfile, !gsm_manager_get_failsafe (manager),
-                                    append_required_components_helper, manager);
-        g_debug ("fill: *** Done adding required components");
-
-        if (!gsm_manager_get_failsafe (manager)) {
-                char **autostart_dirs;
-                int    i;
-
-                autostart_dirs = gsm_util_get_autostart_dirs ();
-
-                maybe_load_saved_session_apps (manager);
-
-                for (i = 0; autostart_dirs[i]; i++) {
-                        gsm_manager_add_autostart_apps_from_dir (manager,
-                                                                 autostart_dirs[i]);
-                }
-
-                g_strfreev (autostart_dirs);
-        }
-}
-
-static GKeyFile *
-get_session_keyfile_if_valid (const char *path)
-{
-        GKeyFile  *keyfile;
-        gsize      len;
-        char     **list;
-
-        g_debug ("fill: *** Looking if %s is a valid session file", path);
-
-        keyfile = g_key_file_new ();
-
-        if (!g_key_file_load_from_file (keyfile, path, G_KEY_FILE_NONE, NULL)) {
-                g_debug ("Cannot use session '%s': non-existing or invalid file.", path);
-                goto error;
-        }
-
-        if (!g_key_file_has_group (keyfile, GSM_KEYFILE_SESSION_GROUP)) {
-                g_warning ("Cannot use session '%s': no '%s' group.", path, GSM_KEYFILE_SESSION_GROUP);
-                goto error;
-        }
-
-        /* check that we do have some required components */
-        if (len == 0) {
-                list = g_key_file_get_string_list (keyfile,
-                                                   GSM_KEYFILE_SESSION_GROUP,
-                                                   GSM_KEYFILE_REQUIRED_COMPONENTS_KEY,
-                                                   &len, NULL);
-                if (list)
-                        g_strfreev (list);
-                if (len == 0)
-                        g_warning ("Session '%s': no component in the session.", path);
-        }
-
-        return keyfile;
-
-error:
-        g_key_file_free (keyfile);
-        return NULL;
-}
-
-/**
- * find_valid_session_keyfile:
- * @session: name of session
- *
- * We look for the session file in XDG_CONFIG_HOME, XDG_CONFIG_DIRS and
- * XDG_DATA_DIRS. This enables users and sysadmins to override a specific
- * session that is shipped in XDG_DATA_DIRS.
- */
-static GKeyFile *
-find_valid_session_keyfile (const char *session)
-{
-        GPtrArray          *dirs;
-        const char * const *system_config_dirs;
-        const char * const *system_data_dirs;
-        int                 i;
-        GKeyFile           *keyfile;
-        char               *basename;
-        char               *path;
-
-        dirs = g_ptr_array_new ();
-
-        g_ptr_array_add (dirs, (gpointer) g_get_user_config_dir ());
-
-        system_config_dirs = g_get_system_config_dirs ();
-        for (i = 0; system_config_dirs[i]; i++)
-                g_ptr_array_add (dirs, (gpointer) system_config_dirs[i]);
-
-        system_data_dirs = g_get_system_data_dirs ();
-        for (i = 0; system_data_dirs[i]; i++)
-                g_ptr_array_add (dirs, (gpointer) system_data_dirs[i]);
-
-        keyfile = NULL;
-        basename = g_strdup_printf ("%s.session", session);
-        path = NULL;
-
-        for (i = 0; i < dirs->len; i++) {
-                path = g_build_filename (dirs->pdata[i], "gnome-session", "sessions", basename, NULL);
-                keyfile = get_session_keyfile_if_valid (path);
-                if (keyfile != NULL)
-                        break;
-        }
-
-        if (dirs)
-                g_ptr_array_free (dirs, TRUE);
-        if (basename)
-                g_free (basename);
-        if (path)
-                g_free (path);
-
-        return keyfile;
-}
-
-static GKeyFile *
-get_session_keyfile (const char *session,
-                     char      **actual_session,
-                     gboolean   *is_fallback)
-{
-        GKeyFile *keyfile;
-        gboolean  session_runnable;
-        char     *value;
-        GError *error = NULL;
-
-        *actual_session = NULL;
-
-        g_debug ("fill: *** Getting session '%s'", session);
-
-        keyfile = find_valid_session_keyfile (session);
-
-        if (!keyfile)
-                return NULL;
-
-        session_runnable = TRUE;
-
-        value = g_key_file_get_string (keyfile,
-                                       GSM_KEYFILE_SESSION_GROUP, GSM_KEYFILE_RUNNABLE_KEY,
-                                       NULL);
-        if (!IS_STRING_EMPTY (value)) {
-                g_debug ("fill: *** Launching helper '%s' to know if session is runnable", value);
-                session_runnable = gsm_process_helper (value, GSM_RUNNABLE_HELPER_TIMEOUT, &error);
-                if (!session_runnable) {
-                        g_warning ("Session '%s' runnable check failed: %s", session,
-                                   error->message);
-                        g_clear_error (&error);
-                }
-        }
-        g_free (value);
-
-        if (session_runnable) {
-                session_runnable = check_required (keyfile);
-        }
-
-        if (session_runnable) {
-                *actual_session = g_strdup (session);
-                if (is_fallback)
-                        *is_fallback = FALSE;
-                return keyfile;
-        }
-
-        g_debug ("fill: *** Session is not runnable");
-
-        /* We can't run this session, so try to use the fallback */
-        value = g_key_file_get_string (keyfile,
-                                       GSM_KEYFILE_SESSION_GROUP, GSM_KEYFILE_FALLBACK_KEY,
-                                       NULL);
-
-        g_key_file_free (keyfile);
-        keyfile = NULL;
-
-        if (!IS_STRING_EMPTY (value)) {
-                if (is_fallback)
-                        *is_fallback = TRUE;
-                keyfile = get_session_keyfile (value, actual_session, NULL);
-        }
-        g_free (value);
-
-        return keyfile;
-}
-
-gboolean
-gsm_session_fill (GsmManager  *manager,
-                  const char  *session)
-{
-        GKeyFile *keyfile;
-        gboolean is_fallback;
-        char *actual_session;
-
-        keyfile = get_session_keyfile (session, &actual_session, &is_fallback);
-
-        if (!keyfile)
-                return FALSE;
-
-        _gsm_manager_set_active_session (manager, actual_session, is_fallback);
-
-        g_free (actual_session);
-
-        load_standard_apps (manager, keyfile);
-
-        g_key_file_free (keyfile);
-
-        return TRUE;
-}
diff --git a/gnome-session/gsm-session-fill.h b/gnome-session/gsm-session-fill.h
deleted file mode 100644
index 608205c..0000000
--- a/gnome-session/gsm-session-fill.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2006, 2010 Novell, Inc.
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#ifndef __GSM_SESSION_FILL_H
-#define __GSM_SESSION_FILL_H
-
-#include "gsm-manager.h"
-
-G_BEGIN_DECLS
-
-gboolean gsm_session_fill (GsmManager  *manager,
-                           const char  *session);
-
-G_END_DECLS
-
-#endif /* __GSM_SESSION_FILL_H */
diff --git a/gnome-session/gsm-session-save.c b/gnome-session/gsm-session-save.c
deleted file mode 100644
index 917347f..0000000
--- a/gnome-session/gsm-session-save.c
+++ /dev/null
@@ -1,276 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- * gsm-session-save.c
- * Copyright (C) 2008 Lucas Rocha.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#include <config.h>
-
-#include <glib.h>
-#include <glib/gstdio.h>
-#include <gio/gio.h>
-
-#include "gsm-util.h"
-#include "gsm-autostart-app.h"
-#include "gsm-client.h"
-
-#include "gsm-session-save.h"
-
-#define GSM_MANAGER_SCHEMA        "org.gnome.SessionManager"
-#define KEY_AUTOSAVE_ONE_SHOT     "auto-save-session-one-shot"
-
-
-static gboolean gsm_session_clear_saved_session (const char *directory,
-                                                 GHashTable *discard_hash);
-
-typedef struct {
-        const char  *dir;
-        GHashTable  *discard_hash;
-        GError     **error;
-} SessionSaveData;
-
-static gboolean
-save_one_client (char            *id,
-                 GObject         *object,
-                 SessionSaveData *data)
-{
-        GsmClient  *client;
-        GKeyFile   *keyfile;
-        const char *app_id;
-        char       *path = NULL;
-        char       *filename = NULL;
-        char       *contents = NULL;
-        gsize       length = 0;
-        char       *discard_exec;
-        GError     *local_error;
-
-        client = GSM_CLIENT (object);
-
-        local_error = NULL;
-
-        keyfile = gsm_client_save (client, &local_error);
-
-        if (keyfile == NULL || local_error) {
-                goto out;
-        }
-
-        contents = g_key_file_to_data (keyfile, &length, &local_error);
-
-        if (local_error) {
-                goto out;
-        }
-
-        app_id = gsm_client_peek_app_id (client);
-        if (!IS_STRING_EMPTY (app_id)) {
-                if (g_str_has_suffix (app_id, ".desktop"))
-                        filename = g_strdup (app_id);
-                else
-                        filename = g_strdup_printf ("%s.desktop", app_id);
-
-                path = g_build_filename (data->dir, filename, NULL);
-        }
-
-        if (!path || g_file_test (path, G_FILE_TEST_EXISTS)) {
-                if (filename)
-                        g_free (filename);
-                if (path)
-                        g_free (path);
-
-                filename = g_strdup_printf ("%s.desktop",
-                                            gsm_client_peek_startup_id (client));
-                path = g_build_filename (data->dir, filename, NULL);
-        }
-
-        g_file_set_contents (path,
-                             contents,
-                             length,
-                             &local_error);
-
-        if (local_error) {
-                goto out;
-        }
-
-        discard_exec = g_key_file_get_string (keyfile,
-                                              G_KEY_FILE_DESKTOP_GROUP,
-                                              GSM_AUTOSTART_APP_DISCARD_KEY,
-                                              NULL);
-        if (discard_exec) {
-                g_hash_table_insert (data->discard_hash,
-                                     discard_exec, discard_exec);
-        }
-
-        g_debug ("GsmSessionSave: saved client %s to %s", id, filename);
-
-out:
-        if (keyfile != NULL) {
-                g_key_file_free (keyfile);
-        }
-
-        g_free (contents);
-        g_free (filename);
-        g_free (path);
-
-        /* in case of any error, stop saving session */
-        if (local_error) {
-                g_propagate_error (data->error, local_error);
-                g_error_free (local_error);
-
-                return TRUE;
-        }
-
-        return FALSE;
-}
-
-void
-gsm_session_save (GsmStore  *client_store,
-                  GError   **error)
-{
-        GSettings       *settings;
-        const char      *save_dir;
-        SessionSaveData  data;
-
-        g_debug ("GsmSessionSave: Saving session");
-
-        /* Clear one shot key autosave in the event its set (so that it's actually
-         * one shot only)
-         */
-        settings = g_settings_new (GSM_MANAGER_SCHEMA);
-        g_settings_set_boolean (settings, KEY_AUTOSAVE_ONE_SHOT, FALSE);
-        g_object_unref (settings);
-
-        save_dir = gsm_util_get_saved_session_dir ();
-        if (save_dir == NULL) {
-                g_warning ("GsmSessionSave: cannot create saved session directory");
-                return;
-        }
-
-        data.dir = save_dir;
-        data.discard_hash = g_hash_table_new_full (g_str_hash, g_str_equal,
-                                                   g_free, NULL);
-        /* remove old saved session */
-        gsm_session_clear_saved_session (save_dir, data.discard_hash);
-        data.error = error;
-
-        gsm_store_foreach (client_store,
-                           (GsmStoreFunc) save_one_client,
-                           &data);
-
-        g_hash_table_destroy (data.discard_hash);
-}
-
-static gboolean
-gsm_session_clear_one_client (const char *filename,
-                              GHashTable *discard_hash)
-{
-        gboolean  result = TRUE;
-        GKeyFile *key_file;
-        char     *discard_exec = NULL;
-
-        g_debug ("GsmSessionSave: removing '%s' from saved session", filename);
-
-        key_file = g_key_file_new ();
-        if (g_key_file_load_from_file (key_file, filename,
-                                       G_KEY_FILE_NONE, NULL)) {
-                char **argv;
-                int    argc;
-
-                discard_exec = g_key_file_get_string (key_file,
-                                                      G_KEY_FILE_DESKTOP_GROUP,
-                                                      GSM_AUTOSTART_APP_DISCARD_KEY,
-                                                      NULL);
-                if (!discard_exec)
-                        goto out;
-
-                if (discard_hash && g_hash_table_lookup (discard_hash, discard_exec))
-                        goto out;
-
-                if (!g_shell_parse_argv (discard_exec, &argc, &argv, NULL))
-                        goto out;
-
-                result = g_spawn_async (NULL, argv, NULL, G_SPAWN_SEARCH_PATH,
-                                        NULL, NULL, NULL, NULL) && result;
-
-                g_strfreev (argv);
-        } else {
-                result = FALSE;
-        }
-
-out:
-        if (key_file)
-                g_key_file_free (key_file);
-        if (discard_exec)
-                g_free (discard_exec);
-
-        result = (g_unlink (filename) == 0) && result;
-
-        return result;
-}
-
-static gboolean
-gsm_session_clear_saved_session (const char *directory,
-                                 GHashTable *discard_hash)
-{
-        GDir       *dir;
-        const char *filename;
-        gboolean    result = TRUE;
-        GError     *error;
-
-        g_debug ("GsmSessionSave: clearing currently saved session at %s",
-                 directory);
-
-        if (directory == NULL) {
-                return FALSE;
-        }
-
-        error = NULL;
-        dir = g_dir_open (directory, 0, &error);
-        if (error) {
-                g_warning ("GsmSessionSave: error loading saved session directory: %s", error->message);
-                g_error_free (error);
-                return FALSE;
-        }
-
-        while ((filename = g_dir_read_name (dir))) {
-                char *path = g_build_filename (directory,
-                                               filename, NULL);
-
-                result = gsm_session_clear_one_client (path, discard_hash)
-                         && result;
-
-                g_free (path);
-        }
-
-        g_dir_close (dir);
-
-        return result;
-}
-
-void
-gsm_session_save_clear (void)
-{
-        const char *save_dir;
-
-        g_debug ("GsmSessionSave: Clearing saved session");
-
-        save_dir = gsm_util_get_saved_session_dir ();
-        if (save_dir == NULL) {
-                g_warning ("GsmSessionSave: cannot create saved session directory");
-                return;
-        }
-
-	gsm_session_clear_saved_session (save_dir, NULL);
-}
diff --git a/gnome-session/gsm-session-save.h b/gnome-session/gsm-session-save.h
deleted file mode 100644
index 10b5005..0000000
--- a/gnome-session/gsm-session-save.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/* gsm-session-save.h
- * Copyright (C) 2008 Lucas Rocha.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#ifndef __GSM_SESSION_SAVE_H__
-#define __GSM_SESSION_SAVE_H__
-
-#include <glib.h>
-
-#include "gsm-store.h"
-
-G_BEGIN_DECLS
-
-void      gsm_session_save                 (GsmStore  *client_store,
-                                            GError   **error);
-void      gsm_session_save_clear           (void);
-
-G_END_DECLS
-
-#endif /* __GSM_SESSION_SAVE_H__ */
diff --git a/gnome-session/gsm-shell-extensions.c b/gnome-session/gsm-shell-extensions.c
deleted file mode 100644
index acc0eae..0000000
--- a/gnome-session/gsm-shell-extensions.c
+++ /dev/null
@@ -1,205 +0,0 @@
-/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
-/*
- * Copyright (C) 2011 Red Hat, Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- *
- * Authors:
- *      Jasper St. Pierre <jstpierre@mecheye.net>
- */
-
-#include <config.h>
-
-#include <glib.h>
-#include <gio/gio.h>
-#include <json-glib/json-glib.h>
-
-#include "gsm-shell-extensions.h"
-
-#define SHELL_SCHEMA "org.gnome.shell"
-#define ENABLED_EXTENSIONS_KEY "enabled-extensions"
-
-#define SHELL_EXTENSIONS_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSM_TYPE_SHELL_EXTENSIONS, GsmShellExtensionsPrivate))
-
-struct _GsmShellExtensionsPrivate
-{
-  GSettings *settings;
-  guint num_extensions;
-};
-
-G_DEFINE_TYPE (GsmShellExtensions, gsm_shell_extensions, G_TYPE_OBJECT);
-
-/**
- * gsm_shell_extensions_finalize:
- * @object: (in): A #GsmShellExtensions.
- *
- * Finalizer for a #GsmShellExtensions instance.  Frees any resources held by
- * the instance.
- */
-static void
-gsm_shell_extensions_finalize (GObject *object)
-{
-  GsmShellExtensions *extensions = GSM_SHELL_EXTENSIONS (object);
-  GsmShellExtensionsPrivate *priv = extensions->priv;
-
-  g_clear_object (&priv->settings);
-
-  G_OBJECT_CLASS (gsm_shell_extensions_parent_class)->finalize (object);
-}
-
-/**
- * gsm_shell_extensions_class_init:
- * @klass: (in): A #GsmShellExtensionsClass.
- *
- * Initializes the #GsmShellExtensionsClass and prepares the vtable.
- */
-static void
-gsm_shell_extensions_class_init (GsmShellExtensionsClass *klass)
-{
-  GObjectClass *object_class;
-
-  object_class = G_OBJECT_CLASS (klass);
-  object_class->finalize = gsm_shell_extensions_finalize;
-  g_type_class_add_private (object_class, sizeof (GsmShellExtensionsPrivate));
-}
-
-static void
-gsm_shell_extensions_scan_dir (GsmShellExtensions *self,
-                               GFile              *dir)
-{
-  GFileEnumerator *enumerator;
-  GFileInfo *info;
-  JsonParser *metadata_parser;
-
-  metadata_parser = json_parser_new ();
-
-  enumerator = g_file_enumerate_children (dir,
-                                          "standard::*",
-                                          G_FILE_QUERY_INFO_NONE,
-                                          NULL,
-                                          NULL);
-
-  if (enumerator == NULL)
-    return;
-
-  while ((info = g_file_enumerator_next_file (enumerator, NULL, NULL)) != NULL)
-    {
-      gchar *metadata_filename;
-      const gchar *metadata_uuid;
-      gchar *dir_uuid;
-      JsonObject *metadata_root;
-
-      dir_uuid = (char *) g_file_info_get_name (info);
-
-      metadata_filename = g_build_filename (g_file_get_path (dir),
-                                            dir_uuid,
-                                            "metadata.json",
-                                            NULL);
-
-      if (!json_parser_load_from_file (metadata_parser, metadata_filename, NULL))
-        continue;
-
-      g_free (metadata_filename);
-
-      metadata_root = json_node_get_object (json_parser_get_root (metadata_parser));
-
-      metadata_uuid = json_object_get_string_member (metadata_root, "uuid");
-      if (!g_str_equal (metadata_uuid, dir_uuid))
-        {
-          g_warning ("Extension with dirname '%s' does not match metadata's UUID of '%s'. Skipping.",
-                     dir_uuid, metadata_uuid);
-          continue;
-        }
-
-      self->priv->num_extensions++;
-    }
-}
-
-static void
-gsm_shell_extensions_scan (GsmShellExtensions *self)
-{
-  gchar *dirname;
-  GFile *dir;
-  const gchar * const * system_data_dirs;
-
-  /* User data dir first. */
-  dirname = g_build_filename (g_get_user_data_dir (), "gnome-shell", "extensions", NULL);
-  dir = g_file_new_for_path (dirname);
-  g_free (dirname);
-
-  gsm_shell_extensions_scan_dir (self, dir);
-  g_object_unref (dir);
-
-  system_data_dirs = g_get_system_data_dirs ();
-  while ((*system_data_dirs) != '\0')
-    {
-      dirname = g_build_filename (*system_data_dirs, "gnome-shell", "extensions", NULL);
-      dir = g_file_new_for_path (dirname);
-      g_free (dirname);
-
-      gsm_shell_extensions_scan_dir (self, dir);
-      g_object_unref (dir);
-      system_data_dirs ++;
-    }
-}
-
-/**
- * gsm_shell_extensions_init:
- * @self: (in): A #GsmShellExtensions.
- *
- * Initializes the newly created #GsmShellExtensions instance.
- */
-static void
-gsm_shell_extensions_init (GsmShellExtensions *self)
-{
-  const gchar * const * schemas;
-
-  self->priv = SHELL_EXTENSIONS_PRIVATE (self);
-
-  /* Unfortunately, gsettings does not have a way to test
-   * for the existance of a schema, so hack around it. */
-  schemas = g_settings_list_schemas ();
-  while (schemas != NULL)
-    {
-      if (g_str_equal (*schemas, SHELL_SCHEMA))
-        {
-          self->priv->settings = g_settings_new (SHELL_SCHEMA);
-          break;
-        }
-
-      schemas ++;
-    }
-
-  if (self->priv->settings != NULL)
-    gsm_shell_extensions_scan (self);
-}
-
-gboolean
-gsm_shell_extensions_disable_all (GsmShellExtensions *self)
-{
-  return g_settings_set_strv (self->priv->settings,
-                              ENABLED_EXTENSIONS_KEY,
-                              NULL);
-}
-
-guint
-gsm_shell_extensions_n_extensions (GsmShellExtensions *self)
-{
-  if (self->priv->settings == NULL)
-    return 0;
-
-  return self->priv->num_extensions;
-}
diff --git a/gnome-session/gsm-shell-extensions.h b/gnome-session/gsm-shell-extensions.h
deleted file mode 100644
index c4761e4..0000000
--- a/gnome-session/gsm-shell-extensions.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
-/*
- * Copyright (C) 2011 Red Hat, Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- *
- * Authors:
- *      Jasper St. Pierre <jstpierre@mecheye.net>
- */
-
-#ifndef __GSM_SHELL_EXTENSIONS_H
-#define __GSM_SHELL_EXTENSIONS_H
-
-#include <glib-object.h>
-
-G_BEGIN_DECLS
-
-#define GSM_TYPE_SHELL_EXTENSIONS            (gsm_shell_extensions_get_type ())
-#define GSM_SHELL_EXTENSIONS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSM_TYPE_SHELL_EXTENSIONS, GsmShellExtensions))
-#define GSM_SHELL_EXTENSIONS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  GSM_TYPE_SHELL_EXTENSIONS, GsmShellExtensionsClass))
-#define GSM_IS_SHELL_EXTENSIONS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSM_TYPE_SHELL_EXTENSIONS))
-#define GSM_IS_SHELL_EXTENSIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  GSM_TYPE_SHELL_EXTENSIONS))
-#define GSM_SHELL_EXTENSIONS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  GSM_TYPE_SHELL_EXTENSIONS, GsmShellExtensionsClass))
-
-typedef struct _GsmShellExtensions        GsmShellExtensions;
-typedef struct _GsmShellExtensionsClass   GsmShellExtensionsClass;
-typedef struct _GsmShellExtensionsPrivate GsmShellExtensionsPrivate;
-
-struct _GsmShellExtensions
-{
-    GObject parent;
-
-    /*< private >*/
-    GsmShellExtensionsPrivate *priv;
-};
-
-struct _GsmShellExtensionsClass
-{
-    GObjectClass parent_class;
-};
-
-GType gsm_shell_extensions_get_type                   (void) G_GNUC_CONST;
-
-gboolean gsm_shell_extensions_disable_all             (GsmShellExtensions *self);
-
-guint gsm_shell_extensions_n_extensions               (GsmShellExtensions *self);
-
-G_END_DECLS
-
-#endif /* __GSM_SHELL_EXTENSIONS_H */
diff --git a/gnome-session/gsm-shell.c b/gnome-session/gsm-shell.c
deleted file mode 100644
index 450ca40..0000000
--- a/gnome-session/gsm-shell.c
+++ /dev/null
@@ -1,700 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2010 Red Hat, Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#include "config.h"
-
-#include <errno.h>
-#include <string.h>
-#include <unistd.h>
-
-#include <glib.h>
-#include <glib-object.h>
-#include <glib/gi18n.h>
-
-#include <dbus/dbus-glib.h>
-#include <dbus/dbus-glib-lowlevel.h>
-
-#include "gsm-inhibitor.h"
-#include "gsm-shell.h"
-
-#define SHELL_NAME      "org.gnome.Shell"
-#define SHELL_PATH      "/org/gnome/Shell"
-#define SHELL_INTERFACE "org.gnome.Shell"
-
-#define SHELL_END_SESSION_DIALOG_PATH      "/org/gnome/SessionManager/EndSessionDialog"
-#define SHELL_END_SESSION_DIALOG_INTERFACE "org.gnome.SessionManager.EndSessionDialog"
-
-#define GSM_SHELL_DBUS_TYPE_G_OBJECT_PATH_ARRAY (dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH))
-
-#define AUTOMATIC_ACTION_TIMEOUT 60
-
-#define GSM_SHELL_GET_PRIVATE(o)                                   \
-        (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSM_TYPE_SHELL, GsmShellPrivate))
-
-struct _GsmShellPrivate
-{
-        DBusGConnection *bus_connection;
-        DBusGProxy      *bus_proxy;
-        DBusGProxy      *proxy;
-        DBusGProxy      *end_session_dialog_proxy;
-        GsmStore        *inhibitors;
-
-        guint32          is_running : 1;
-
-        DBusGProxyCall  *end_session_open_call;
-        GsmShellEndSessionDialogType end_session_dialog_type;
-
-        guint            update_idle_id;
-};
-
-enum {
-        PROP_0,
-        PROP_IS_RUNNING
-};
-
-enum {
-        END_SESSION_DIALOG_OPENED = 0,
-        END_SESSION_DIALOG_OPEN_FAILED,
-        END_SESSION_DIALOG_CLOSED,
-        END_SESSION_DIALOG_CANCELED,
-        END_SESSION_DIALOG_CONFIRMED_LOGOUT,
-        END_SESSION_DIALOG_CONFIRMED_SHUTDOWN,
-        END_SESSION_DIALOG_CONFIRMED_REBOOT,
-        NUMBER_OF_SIGNALS
-};
-
-static guint signals[NUMBER_OF_SIGNALS] = { 0 };
-
-static void     gsm_shell_class_init   (GsmShellClass *klass);
-static void     gsm_shell_init         (GsmShell      *ck);
-static void     gsm_shell_finalize     (GObject            *object);
-
-static void     gsm_shell_disconnect_from_bus    (GsmShell      *shell);
-
-static DBusHandlerResult gsm_shell_bus_filter (DBusConnection *connection,
-                                                DBusMessage    *message,
-                                                void           *user_data);
-
-static void     gsm_shell_on_name_owner_changed (DBusGProxy *bus_proxy,
-                                                 const char *name,
-                                                 const char *prev_owner,
-                                                 const char *new_owner,
-                                                 GsmShell   *shell);
-static void     queue_end_session_dialog_update (GsmShell *shell);
-
-G_DEFINE_TYPE (GsmShell, gsm_shell, G_TYPE_OBJECT);
-
-static void
-gsm_shell_get_property (GObject    *object,
-                             guint       prop_id,
-                             GValue     *value,
-                             GParamSpec *pspec)
-{
-        GsmShell *shell = GSM_SHELL (object);
-
-        switch (prop_id) {
-        case PROP_IS_RUNNING:
-                g_value_set_boolean (value,
-                                     shell->priv->is_running);
-                break;
-
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object,
-                                                   prop_id,
-                                                   pspec);
-        }
-}
-
-static void
-gsm_shell_class_init (GsmShellClass *shell_class)
-{
-        GObjectClass *object_class;
-        GParamSpec   *param_spec;
-
-        object_class = G_OBJECT_CLASS (shell_class);
-
-        object_class->finalize = gsm_shell_finalize;
-        object_class->get_property = gsm_shell_get_property;
-
-        param_spec = g_param_spec_boolean ("is-running",
-                                           "Is running",
-                                           "Whether GNOME Shell is running in the session",
-                                           FALSE,
-                                           G_PARAM_READABLE);
-
-        g_object_class_install_property (object_class, PROP_IS_RUNNING,
-                                         param_spec);
-
-        signals [END_SESSION_DIALOG_OPENED] =
-                g_signal_new ("end-session-dialog-opened",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmShellClass, end_session_dialog_opened),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE, 0);
-
-        signals [END_SESSION_DIALOG_OPEN_FAILED] =
-                g_signal_new ("end-session-dialog-open-failed",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmShellClass, end_session_dialog_open_failed),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE, 0);
-
-        signals [END_SESSION_DIALOG_CLOSED] =
-                g_signal_new ("end-session-dialog-closed",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmShellClass, end_session_dialog_closed),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE, 0);
-
-        signals [END_SESSION_DIALOG_CANCELED] =
-                g_signal_new ("end-session-dialog-canceled",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmShellClass, end_session_dialog_canceled),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE, 0);
-
-        signals [END_SESSION_DIALOG_CONFIRMED_LOGOUT] =
-                g_signal_new ("end-session-dialog-confirmed-logout",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmShellClass, end_session_dialog_confirmed_logout),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE, 0);
-
-        signals [END_SESSION_DIALOG_CONFIRMED_SHUTDOWN] =
-                g_signal_new ("end-session-dialog-confirmed-shutdown",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmShellClass, end_session_dialog_confirmed_shutdown),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE, 0);
-
-        signals [END_SESSION_DIALOG_CONFIRMED_REBOOT] =
-                g_signal_new ("end-session-dialog-confirmed-reboot",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmShellClass, end_session_dialog_confirmed_reboot),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE, 0);
-
-        g_type_class_add_private (shell_class, sizeof (GsmShellPrivate));
-}
-
-static DBusHandlerResult
-gsm_shell_bus_filter (DBusConnection *connection,
-                       DBusMessage    *message,
-                       void           *user_data)
-{
-        GsmShell *shell;
-
-        shell = GSM_SHELL (user_data);
-
-        if (dbus_message_is_signal (message,
-                                    DBUS_INTERFACE_LOCAL, "Disconnected") &&
-            strcmp (dbus_message_get_path (message), DBUS_PATH_LOCAL) == 0) {
-                gsm_shell_disconnect_from_bus (shell);
-                /* let other filters get this disconnected signal, so that they
-                 * can handle it too */
-        }
-
-        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-}
-
-static gboolean
-gsm_shell_ensure_connection (GsmShell  *shell,
-                             GError   **error)
-{
-        GError  *connection_error;
-        gboolean is_running;
-
-        connection_error = NULL;
-
-        if (shell->priv->bus_connection == NULL) {
-                DBusConnection *connection;
-
-                shell->priv->bus_connection = dbus_g_bus_get (DBUS_BUS_SESSION,
-                                                               &connection_error);
-
-                if (shell->priv->bus_connection == NULL) {
-                        g_propagate_error (error, connection_error);
-                        is_running = FALSE;
-                        goto out;
-                }
-
-                connection = dbus_g_connection_get_connection (shell->priv->bus_connection);
-                dbus_connection_set_exit_on_disconnect (connection, FALSE);
-                dbus_connection_add_filter (connection,
-                                            gsm_shell_bus_filter,
-                                            shell, NULL);
-        }
-
-        if (shell->priv->bus_proxy == NULL) {
-                shell->priv->bus_proxy =
-                        dbus_g_proxy_new_for_name_owner (shell->priv->bus_connection,
-                                                         DBUS_SERVICE_DBUS,
-                                                         DBUS_PATH_DBUS,
-                                                         DBUS_INTERFACE_DBUS,
-                                                         &connection_error);
-
-                if (shell->priv->bus_proxy == NULL) {
-                        g_propagate_error (error, connection_error);
-                        is_running = FALSE;
-                        goto out;
-                }
-
-                dbus_g_proxy_add_signal (shell->priv->bus_proxy,
-                                         "NameOwnerChanged",
-                                         G_TYPE_STRING,
-                                         G_TYPE_STRING,
-                                         G_TYPE_STRING,
-                                         G_TYPE_INVALID);
-
-                dbus_g_proxy_connect_signal (shell->priv->bus_proxy,
-                                             "NameOwnerChanged",
-                                             G_CALLBACK (gsm_shell_on_name_owner_changed),
-                                             shell, NULL);
-        }
-
-        if (shell->priv->proxy == NULL) {
-                shell->priv->proxy =
-                        dbus_g_proxy_new_for_name_owner (shell->priv->bus_connection,
-                                                         SHELL_NAME,
-                                                         SHELL_PATH,
-                                                         SHELL_INTERFACE,
-                                                         &connection_error);
-
-                if (shell->priv->proxy == NULL) {
-                        g_propagate_error (error, connection_error);
-                        is_running = FALSE;
-                        goto out;
-                }
-        }
-
-        g_debug ("GsmShell: Connected to the shell");
-
-        is_running = TRUE;
-
- out:
-        if (shell->priv->is_running != is_running) {
-                shell->priv->is_running = is_running;
-                g_object_notify (G_OBJECT (shell), "is-running");
-        }
-
-        if (!is_running) {
-                g_debug ("GsmShell: Not connected to the shell");
-
-                if (shell->priv->bus_connection == NULL) {
-                        g_clear_object (&shell->priv->bus_proxy);
-                        g_clear_object (&shell->priv->proxy);
-                } else if (shell->priv->bus_proxy == NULL) {
-                        g_clear_object (&shell->priv->proxy);
-                }
-        }
-
-        return is_running;
-}
-
-static void
-gsm_shell_on_name_owner_changed (DBusGProxy    *bus_proxy,
-                                 const char    *name,
-                                 const char    *prev_owner,
-                                 const char    *new_owner,
-                                 GsmShell      *shell)
-{
-        if (name != NULL && strcmp (name, SHELL_NAME) != 0) {
-                return;
-        }
-
-        g_clear_object (&shell->priv->proxy);
-
-        gsm_shell_ensure_connection (shell, NULL);
-}
-
-static void
-gsm_shell_init (GsmShell *shell)
-{
-        shell->priv = GSM_SHELL_GET_PRIVATE (shell);
-
-        gsm_shell_ensure_connection (shell, NULL);
-}
-
-static void
-gsm_shell_disconnect_from_bus (GsmShell *shell)
-{
-        g_clear_object (&shell->priv->bus_proxy);
-        g_clear_object (&shell->priv->proxy);
-
-        if (shell->priv->bus_connection != NULL) {
-                DBusConnection *connection;
-                connection = dbus_g_connection_get_connection (shell->priv->bus_connection);
-                dbus_connection_remove_filter (connection,
-                                               gsm_shell_bus_filter,
-                                               shell);
-
-                dbus_g_connection_unref (shell->priv->bus_connection);
-                shell->priv->bus_connection = NULL;
-        }
-}
-
-static void
-gsm_shell_finalize (GObject *object)
-{
-        GsmShell *shell;
-        GObjectClass  *parent_class;
-
-        shell = GSM_SHELL (object);
-
-        parent_class = G_OBJECT_CLASS (gsm_shell_parent_class);
-
-        g_object_unref (shell->priv->inhibitors);
-
-        gsm_shell_disconnect_from_bus (shell);
-
-        if (parent_class->finalize != NULL) {
-                parent_class->finalize (object);
-        }
-}
-
-GsmShell *
-gsm_shell_new (void)
-{
-        GsmShell *shell;
-
-        shell = g_object_new (GSM_TYPE_SHELL, NULL);
-
-        return shell;
-}
-
-GsmShell *
-gsm_get_shell (void)
-{
-        static GsmShell *shell = NULL;
-
-        if (shell == NULL) {
-                shell = gsm_shell_new ();
-        }
-
-        return g_object_ref (shell);
-}
-
-gboolean
-gsm_shell_is_running (GsmShell *shell)
-{
-        gsm_shell_ensure_connection (shell, NULL);
-
-        return shell->priv->is_running;
-}
-
-static gboolean
-add_inhibitor_to_array (const char   *id,
-                        GsmInhibitor *inhibitor,
-                        GPtrArray    *array)
-{
-
-        g_ptr_array_add (array,
-                         g_strdup (gsm_inhibitor_peek_id (inhibitor)));
-        return FALSE;
-}
-
-static GPtrArray *
-get_array_from_store (GsmStore *inhibitors)
-{
-        GPtrArray *array;
-
-        array = g_ptr_array_new ();
-
-        gsm_store_foreach (inhibitors,
-                           (GsmStoreFunc) add_inhibitor_to_array,
-                           array);
-
-        return array;
-}
-
-static void
-on_open_finished (DBusGProxy     *proxy,
-                  DBusGProxyCall *call,
-                  GsmShell       *shell)
-{
-        GError         *error;
-        gboolean        res;
-
-        g_assert (shell->priv->end_session_open_call == call);
-
-        error = NULL;
-        res = dbus_g_proxy_end_call (proxy,
-                                     call,
-                                     &error,
-                                     G_TYPE_INVALID);
-        shell->priv->end_session_open_call = NULL;
-
-        if (shell->priv->update_idle_id != 0) {
-                g_source_remove (shell->priv->update_idle_id);
-                shell->priv->update_idle_id = 0;
-        }
-
-        if (!res) {
-                g_warning ("Unable to open shell end session dialog");
-                g_signal_emit (G_OBJECT (shell), signals[END_SESSION_DIALOG_OPEN_FAILED], 0);
-                return;
-        }
-
-        g_signal_emit (G_OBJECT (shell), signals[END_SESSION_DIALOG_OPENED], 0);
-}
-
-static void
-on_end_session_dialog_closed (DBusGProxy *proxy,
-                              GsmShell   *shell)
-{
-        if (shell->priv->update_idle_id != 0) {
-                g_source_remove (shell->priv->update_idle_id);
-                shell->priv->update_idle_id = 0;
-        }
-
-        g_signal_handlers_disconnect_by_func (shell->priv->inhibitors,
-                                              G_CALLBACK (queue_end_session_dialog_update),
-                                              shell);
-
-        g_signal_emit (G_OBJECT (shell), signals[END_SESSION_DIALOG_CLOSED], 0);
-}
-
-static void
-on_end_session_dialog_canceled (DBusGProxy *proxy,
-                                GsmShell   *shell)
-{
-        if (shell->priv->update_idle_id != 0) {
-                g_source_remove (shell->priv->update_idle_id);
-                shell->priv->update_idle_id = 0;
-        }
-
-        g_signal_handlers_disconnect_by_func (shell->priv->inhibitors,
-                                              G_CALLBACK (queue_end_session_dialog_update),
-                                              shell);
-
-        g_signal_emit (G_OBJECT (shell), signals[END_SESSION_DIALOG_CANCELED], 0);
-}
-
-static void
-on_end_session_dialog_confirmed_logout (DBusGProxy *proxy,
-                                        GsmShell   *shell)
-{
-        if (shell->priv->update_idle_id != 0) {
-                g_source_remove (shell->priv->update_idle_id);
-                shell->priv->update_idle_id = 0;
-        }
-
-        g_signal_emit (G_OBJECT (shell), signals[END_SESSION_DIALOG_CONFIRMED_LOGOUT], 0);
-}
-
-static void
-on_end_session_dialog_confirmed_shutdown (DBusGProxy *proxy,
-                                          GsmShell   *shell)
-{
-        if (shell->priv->update_idle_id != 0) {
-                g_source_remove (shell->priv->update_idle_id);
-                shell->priv->update_idle_id = 0;
-        }
-
-        g_signal_emit (G_OBJECT (shell), signals[END_SESSION_DIALOG_CONFIRMED_SHUTDOWN], 0);
-}
-
-static void
-on_end_session_dialog_confirmed_reboot (DBusGProxy *proxy,
-                                        GsmShell   *shell)
-{
-        if (shell->priv->update_idle_id != 0) {
-                g_source_remove (shell->priv->update_idle_id);
-                shell->priv->update_idle_id = 0;
-        }
-
-        g_signal_emit (G_OBJECT (shell), signals[END_SESSION_DIALOG_CONFIRMED_REBOOT], 0);
-}
-
-static void
-on_end_session_dialog_proxy_destroyed (DBusGProxy *proxy,
-                                       GsmShell   *shell)
-{
-        /* FIXME - is this right? */
-        if (shell->priv->end_session_dialog_proxy != NULL) {
-                g_object_unref (shell->priv->proxy);
-                shell->priv->end_session_dialog_proxy = NULL;
-        }
-}
-
-static gboolean
-on_need_end_session_dialog_update (GsmShell *shell)
-{
-        /* No longer need an update */
-        if (shell->priv->update_idle_id == 0)
-                return FALSE;
-
-        shell->priv->update_idle_id = 0;
-
-        gsm_shell_open_end_session_dialog (shell,
-                                           shell->priv->end_session_dialog_type,
-                                           shell->priv->inhibitors);
-        return FALSE;
-}
-
-static void
-queue_end_session_dialog_update (GsmShell *shell)
-{
-        if (shell->priv->update_idle_id != 0)
-                return;
-
-        shell->priv->update_idle_id = g_idle_add ((GSourceFunc) on_need_end_session_dialog_update,
-                                                  shell);
-}
-
-gboolean
-gsm_shell_open_end_session_dialog (GsmShell *shell,
-                                   GsmShellEndSessionDialogType type,
-                                   GsmStore *inhibitors)
-{
-        DBusGProxyCall  *call;
-        GPtrArray *inhibitor_array;
-        GError *error;
-
-        error = NULL;
-        if (!gsm_shell_ensure_connection (shell, &error)) {
-                g_warning ("Could not connect to the shell: %s",
-                           error->message);
-                g_error_free (error);
-                return FALSE;
-        }
-
-        if (shell->priv->end_session_open_call != NULL) {
-                g_return_val_if_fail (shell->priv->end_session_dialog_type == type,
-                                      FALSE);
-
-                return TRUE;
-        }
-
-        if (shell->priv->end_session_dialog_proxy == NULL) {
-                DBusGProxy *proxy;
-
-                proxy = dbus_g_proxy_new_for_name (shell->priv->bus_connection,
-                                                   SHELL_NAME,
-                                                   SHELL_END_SESSION_DIALOG_PATH,
-                                                   SHELL_END_SESSION_DIALOG_INTERFACE);
-
-                g_assert (proxy != NULL);
-
-                shell->priv->end_session_dialog_proxy = proxy;
-
-                g_signal_connect (proxy, "destroy",
-                                  G_CALLBACK (on_end_session_dialog_proxy_destroyed),
-                                  shell);
-
-                dbus_g_proxy_add_signal (shell->priv->end_session_dialog_proxy,
-                                         "Closed", G_TYPE_INVALID);
-                dbus_g_proxy_connect_signal (shell->priv->end_session_dialog_proxy,
-                                             "Closed",
-                                             G_CALLBACK (on_end_session_dialog_closed),
-                                             shell, NULL);
-
-                dbus_g_proxy_add_signal (shell->priv->end_session_dialog_proxy,
-                                         "Canceled", G_TYPE_INVALID);
-                dbus_g_proxy_connect_signal (shell->priv->end_session_dialog_proxy,
-                                             "Canceled",
-                                             G_CALLBACK (on_end_session_dialog_canceled),
-                                             shell, NULL);
-                dbus_g_proxy_add_signal (shell->priv->end_session_dialog_proxy,
-                                         "ConfirmedLogout", G_TYPE_INVALID);
-                dbus_g_proxy_connect_signal (shell->priv->end_session_dialog_proxy,
-                                             "ConfirmedLogout",
-                                             G_CALLBACK (on_end_session_dialog_confirmed_logout),
-                                             shell, NULL);
-                dbus_g_proxy_add_signal (shell->priv->end_session_dialog_proxy,
-                                         "ConfirmedShutdown", G_TYPE_INVALID);
-                dbus_g_proxy_connect_signal (shell->priv->end_session_dialog_proxy,
-                                             "ConfirmedShutdown",
-                                             G_CALLBACK (on_end_session_dialog_confirmed_shutdown),
-                                             shell, NULL);
-                dbus_g_proxy_add_signal (shell->priv->end_session_dialog_proxy,
-                                         "ConfirmedReboot", G_TYPE_INVALID);
-                dbus_g_proxy_connect_signal (shell->priv->end_session_dialog_proxy,
-                                             "ConfirmedReboot",
-                                             G_CALLBACK (on_end_session_dialog_confirmed_reboot),
-                                             shell, NULL);
-        }
-
-        inhibitor_array = get_array_from_store (inhibitors);
-
-        call = dbus_g_proxy_begin_call_with_timeout (shell->priv->end_session_dialog_proxy,
-                                                     "Open",
-                                                     (DBusGProxyCallNotify)
-                                                     on_open_finished,
-                                                     shell,
-                                                     NULL,
-                                                     INT_MAX,
-                                                     G_TYPE_UINT,
-                                                     (guint) type,
-                                                     G_TYPE_UINT,
-                                                     (guint) 0,
-                                                     G_TYPE_UINT,
-                                                     AUTOMATIC_ACTION_TIMEOUT,
-                                                     GSM_SHELL_DBUS_TYPE_G_OBJECT_PATH_ARRAY,
-                                                     inhibitor_array,
-                                                     G_TYPE_INVALID);
-        g_ptr_array_foreach (inhibitor_array, (GFunc) g_free, NULL);
-        g_ptr_array_free (inhibitor_array, TRUE);
-
-        if (call == NULL) {
-                g_warning ("Unable to make Open call");
-                return FALSE;
-        }
-
-        g_object_ref (inhibitors);
-
-        if (shell->priv->inhibitors != NULL) {
-                g_signal_handlers_disconnect_by_func (shell->priv->inhibitors,
-                                                      G_CALLBACK (queue_end_session_dialog_update),
-                                                      shell);
-                g_object_unref (shell->priv->inhibitors);
-        }
-
-        shell->priv->inhibitors = inhibitors;
-
-        g_signal_connect_swapped (inhibitors, "added",
-                                  G_CALLBACK (queue_end_session_dialog_update),
-                                  shell);
-
-        g_signal_connect_swapped (inhibitors, "removed",
-                                  G_CALLBACK (queue_end_session_dialog_update),
-                                  shell);
-
-        shell->priv->end_session_open_call = call;
-        shell->priv->end_session_dialog_type = type;
-
-        return TRUE;
-}
-
-void
-gsm_shell_close_end_session_dialog (GsmShell *shell)
-{
-        if (!shell->priv->end_session_dialog_proxy)
-                return;
-
-        dbus_g_proxy_call_no_reply (shell->priv->end_session_dialog_proxy, "Close", G_TYPE_INVALID);
-}
diff --git a/gnome-session/gsm-shell.h b/gnome-session/gsm-shell.h
deleted file mode 100644
index 77c8f03..0000000
--- a/gnome-session/gsm-shell.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2010 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- *
- * Authors:
- *    Ray Strode <rstrode@redhat.com>
- */
-
-#ifndef __GSM_SHELL_H__
-#define __GSM_SHELL_H__
-
-#include <glib.h>
-#include <glib-object.h>
-
-#include "gsm-store.h"
-
-G_BEGIN_DECLS
-
-#define GSM_TYPE_SHELL             (gsm_shell_get_type ())
-#define GSM_SHELL(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSM_TYPE_SHELL, GsmShell))
-#define GSM_SHELL_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSM_TYPE_SHELL, GsmShellClass))
-#define GSM_IS_SHELL(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSM_TYPE_SHELL))
-#define GSM_IS_SHELL_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSM_TYPE_SHELL))
-#define GSM_SHELL_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS((obj), GSM_TYPE_SHELL, GsmShellClass))
-#define GSM_SHELL_ERROR            (gsm_shell_error_quark ())
-
-typedef struct _GsmShell        GsmShell;
-typedef struct _GsmShellClass   GsmShellClass;
-typedef struct _GsmShellPrivate GsmShellPrivate;
-
-typedef enum
-{
-    GSM_SHELL_END_SESSION_DIALOG_TYPE_LOGOUT = 0,
-    GSM_SHELL_END_SESSION_DIALOG_TYPE_SHUTDOWN,
-    GSM_SHELL_END_SESSION_DIALOG_TYPE_RESTART,
-} GsmShellEndSessionDialogType;
-
-struct _GsmShell
-{
-        GObject               parent;
-
-        GsmShellPrivate *priv;
-};
-
-struct _GsmShellClass
-{
-        GObjectClass parent_class;
-
-        void (* end_session_dialog_opened)        (GsmShell *shell);
-        void (* end_session_dialog_open_failed)   (GsmShell *shell);
-        void (* end_session_dialog_closed)        (GsmShell *shell);
-        void (* end_session_dialog_canceled)      (GsmShell *shell);
-
-        void (* end_session_dialog_confirmed_logout)   (GsmShell *shell);
-        void (* end_session_dialog_confirmed_shutdown) (GsmShell *shell);
-        void (* end_session_dialog_confirmed_reboot)   (GsmShell *shell);
-
-};
-
-GType            gsm_shell_get_type           (void);
-
-GsmShell        *gsm_shell_new                (void);
-
-GsmShell        *gsm_get_shell                (void);
-gboolean         gsm_shell_is_running         (GsmShell *shell);
-
-gboolean         gsm_shell_open_end_session_dialog (GsmShell *shell,
-                                                    GsmShellEndSessionDialogType type,
-                                                    GsmStore *inhibitors);
-void             gsm_shell_close_end_session_dialog (GsmShell *shell);
-
-G_END_DECLS
-
-#endif /* __GSM_SHELL_H__ */
diff --git a/gnome-session/gsm-store.c b/gnome-session/gsm-store.c
deleted file mode 100644
index 2d1708f..0000000
--- a/gnome-session/gsm-store.c
+++ /dev/null
@@ -1,409 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2007-2008 William Jon McCann <mccann@jhu.edu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- */
-
-#include "config.h"
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <string.h>
-
-#include <glib.h>
-#include <glib/gi18n.h>
-#include <glib-object.h>
-
-#include "gsm-store.h"
-
-#define GSM_STORE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSM_TYPE_STORE, GsmStorePrivate))
-
-struct GsmStorePrivate
-{
-        GHashTable *objects;
-        gboolean    locked;
-};
-
-enum {
-        ADDED,
-        REMOVED,
-        LAST_SIGNAL
-};
-
-enum {
-        PROP_0,
-        PROP_LOCKED
-};
-
-static guint signals [LAST_SIGNAL] = { 0 };
-
-static void     gsm_store_class_init    (GsmStoreClass *klass);
-static void     gsm_store_init          (GsmStore      *store);
-static void     gsm_store_finalize      (GObject       *object);
-
-G_DEFINE_TYPE (GsmStore, gsm_store, G_TYPE_OBJECT)
-
-GQuark
-gsm_store_error_quark (void)
-{
-        static GQuark ret = 0;
-        if (ret == 0) {
-                ret = g_quark_from_static_string ("gsm_store_error");
-        }
-
-        return ret;
-}
-
-guint
-gsm_store_size (GsmStore    *store)
-{
-        return g_hash_table_size (store->priv->objects);
-}
-
-gboolean
-gsm_store_remove (GsmStore   *store,
-                  const char *id)
-{
-        GObject *found;
-        gboolean removed;
-        char    *id_copy;
-
-        g_return_val_if_fail (store != NULL, FALSE);
-
-        found = g_hash_table_lookup (store->priv->objects, id);
-        if (found == NULL) {
-                return FALSE;
-        }
-
-        id_copy = g_strdup (id);
-
-        g_object_ref (found);
-
-        removed = g_hash_table_remove (store->priv->objects, id_copy);
-        g_assert (removed);
-
-        g_signal_emit (store, signals [REMOVED], 0, id_copy);
-
-        g_object_unref (found);
-        g_free (id_copy);
-
-        return TRUE;
-}
-
-void
-gsm_store_foreach (GsmStore    *store,
-                   GsmStoreFunc func,
-                   gpointer     user_data)
-{
-        g_return_if_fail (store != NULL);
-        g_return_if_fail (func != NULL);
-
-        g_hash_table_find (store->priv->objects,
-                           (GHRFunc)func,
-                           user_data);
-}
-
-GObject *
-gsm_store_find (GsmStore    *store,
-                GsmStoreFunc predicate,
-                gpointer     user_data)
-{
-        GObject *object;
-
-        g_return_val_if_fail (store != NULL, NULL);
-        g_return_val_if_fail (predicate != NULL, NULL);
-
-        object = g_hash_table_find (store->priv->objects,
-                                    (GHRFunc)predicate,
-                                    user_data);
-        return object;
-}
-
-GObject *
-gsm_store_lookup (GsmStore   *store,
-                  const char *id)
-{
-        GObject *object;
-
-        g_return_val_if_fail (store != NULL, NULL);
-        g_return_val_if_fail (id != NULL, NULL);
-
-        object = g_hash_table_lookup (store->priv->objects, id);
-
-        return object;
-}
-
-
-typedef struct
-{
-        GsmStoreFunc func;
-        gpointer     user_data;
-        GsmStore    *store;
-        GList       *removed;
-} WrapperData;
-
-static gboolean
-foreach_remove_wrapper (const char  *id,
-                        GObject     *object,
-                        WrapperData *data)
-{
-        gboolean res;
-
-        res = (data->func) (id, object, data->user_data);
-        if (res) {
-                data->removed = g_list_prepend (data->removed, g_strdup (id));
-        }
-
-        return res;
-}
-
-guint
-gsm_store_foreach_remove (GsmStore    *store,
-                          GsmStoreFunc func,
-                          gpointer     user_data)
-{
-        guint       ret;
-        WrapperData data;
-
-        g_return_val_if_fail (store != NULL, 0);
-        g_return_val_if_fail (func != NULL, 0);
-
-        data.store = store;
-        data.user_data = user_data;
-        data.func = func;
-        data.removed = NULL;
-
-        ret = g_hash_table_foreach_remove (store->priv->objects,
-                                           (GHRFunc)foreach_remove_wrapper,
-                                           &data);
-
-        while (data.removed != NULL) {
-                char *id;
-                id = data.removed->data;
-                g_debug ("GsmStore: emitting removed for %s", id);
-                g_signal_emit (store, signals [REMOVED], 0, id);
-                g_free (data.removed->data);
-                data.removed->data = NULL;
-                data.removed = g_list_delete_link (data.removed, data.removed);
-        }
-
-        return ret;
-}
-
-static gboolean
-_remove_all (const char *id,
-             GObject    *object,
-             gpointer    data)
-{
-        return TRUE;
-}
-
-void
-gsm_store_clear (GsmStore *store)
-{
-        g_return_if_fail (store != NULL);
-
-        g_debug ("GsmStore: Clearing object store");
-
-        gsm_store_foreach_remove (store,
-                                  _remove_all,
-                                  NULL);
-}
-
-gboolean
-gsm_store_add (GsmStore   *store,
-               const char *id,
-               GObject    *object)
-{
-        g_return_val_if_fail (store != NULL, FALSE);
-        g_return_val_if_fail (id != NULL, FALSE);
-        g_return_val_if_fail (object != NULL, FALSE);
-
-        /* If we're locked, we don't accept any new session
-           objects. */
-        if (store->priv->locked) {
-                return FALSE;
-        }
-
-        g_debug ("GsmStore: Adding object id %s to store", id);
-
-        g_hash_table_insert (store->priv->objects,
-                             g_strdup (id),
-                             g_object_ref (object));
-
-        g_signal_emit (store, signals [ADDED], 0, id);
-
-        return TRUE;
-}
-
-void
-gsm_store_set_locked (GsmStore *store,
-                      gboolean  locked)
-{
-        g_return_if_fail (GSM_IS_STORE (store));
-
-        store->priv->locked = locked;
-}
-
-gboolean
-gsm_store_get_locked (GsmStore *store)
-{
-        g_return_val_if_fail (GSM_IS_STORE (store), FALSE);
-
-        return store->priv->locked;
-}
-
-static void
-gsm_store_set_property (GObject      *object,
-                        guint         prop_id,
-                        const GValue *value,
-                        GParamSpec   *pspec)
-{
-        GsmStore *self;
-
-        self = GSM_STORE (object);
-
-        switch (prop_id) {
-        case PROP_LOCKED:
-                gsm_store_set_locked (self, g_value_get_boolean (value));
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_store_get_property (GObject    *object,
-                        guint       prop_id,
-                        GValue     *value,
-                        GParamSpec *pspec)
-{
-        GsmStore *self;
-
-        self = GSM_STORE (object);
-
-        switch (prop_id) {
-        case PROP_LOCKED:
-                g_value_set_boolean (value, self->priv->locked);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_store_dispose (GObject *object)
-{
-        GsmStore *store;
-
-        g_return_if_fail (object != NULL);
-        g_return_if_fail (GSM_IS_STORE (object));
-
-        store = GSM_STORE (object);
-
-        gsm_store_clear (store);
-
-        G_OBJECT_CLASS (gsm_store_parent_class)->dispose (object);
-}
-
-static void
-gsm_store_class_init (GsmStoreClass *klass)
-{
-        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
-
-        object_class->get_property = gsm_store_get_property;
-        object_class->set_property = gsm_store_set_property;
-        object_class->finalize = gsm_store_finalize;
-        object_class->dispose = gsm_store_dispose;
-
-        signals [ADDED] =
-                g_signal_new ("added",
-                              G_TYPE_FROM_CLASS (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmStoreClass, added),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE,
-                              1, G_TYPE_STRING);
-        signals [REMOVED] =
-                g_signal_new ("removed",
-                              G_TYPE_FROM_CLASS (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmStoreClass, removed),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE,
-                              1, G_TYPE_STRING);
-        g_object_class_install_property (object_class,
-                                         PROP_LOCKED,
-                                         g_param_spec_boolean ("locked",
-                                                               NULL,
-                                                               NULL,
-                                                               FALSE,
-                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-
-        g_type_class_add_private (klass, sizeof (GsmStorePrivate));
-}
-
-static void
-_destroy_object (GObject *object)
-{
-        g_debug ("GsmStore: Unreffing object: %p", object);
-        g_object_unref (object);
-}
-
-static void
-gsm_store_init (GsmStore *store)
-{
-
-        store->priv = GSM_STORE_GET_PRIVATE (store);
-
-        store->priv->objects = g_hash_table_new_full (g_str_hash,
-                                                      g_str_equal,
-                                                      g_free,
-                                                      (GDestroyNotify) _destroy_object);
-}
-
-static void
-gsm_store_finalize (GObject *object)
-{
-        GsmStore *store;
-
-        g_return_if_fail (object != NULL);
-        g_return_if_fail (GSM_IS_STORE (object));
-
-        store = GSM_STORE (object);
-
-        g_return_if_fail (store->priv != NULL);
-
-        g_hash_table_destroy (store->priv->objects);
-
-        G_OBJECT_CLASS (gsm_store_parent_class)->finalize (object);
-}
-
-GsmStore *
-gsm_store_new (void)
-{
-        GObject *object;
-
-        object = g_object_new (GSM_TYPE_STORE,
-                               NULL);
-
-        return GSM_STORE (object);
-}
diff --git a/gnome-session/gsm-store.h b/gnome-session/gsm-store.h
deleted file mode 100644
index 3cc9a42..0000000
--- a/gnome-session/gsm-store.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2007-2008 William Jon McCann <mccann@jhu.edu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- */
-
-
-#ifndef __GSM_STORE_H
-#define __GSM_STORE_H
-
-#include <glib-object.h>
-
-G_BEGIN_DECLS
-
-#define GSM_TYPE_STORE         (gsm_store_get_type ())
-#define GSM_STORE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GSM_TYPE_STORE, GsmStore))
-#define GSM_STORE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GSM_TYPE_STORE, GsmStoreClass))
-#define GSM_IS_STORE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GSM_TYPE_STORE))
-#define GSM_IS_STORE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GSM_TYPE_STORE))
-#define GSM_STORE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GSM_TYPE_STORE, GsmStoreClass))
-
-typedef struct GsmStorePrivate GsmStorePrivate;
-
-typedef struct
-{
-        GObject          parent;
-        GsmStorePrivate *priv;
-} GsmStore;
-
-typedef struct
-{
-        GObjectClass   parent_class;
-
-        void          (* added)    (GsmStore   *store,
-                                    const char *id);
-        void          (* removed)  (GsmStore   *store,
-                                    const char *id);
-} GsmStoreClass;
-
-typedef enum
-{
-         GSM_STORE_ERROR_GENERAL
-} GsmStoreError;
-
-#define GSM_STORE_ERROR gsm_store_error_quark ()
-
-typedef gboolean (*GsmStoreFunc) (const char *id,
-                                  GObject    *object,
-                                  gpointer    user_data);
-
-GQuark              gsm_store_error_quark              (void);
-GType               gsm_store_get_type                 (void);
-
-GsmStore *          gsm_store_new                      (void);
-
-gboolean            gsm_store_get_locked               (GsmStore    *store);
-void                gsm_store_set_locked               (GsmStore    *store,
-                                                        gboolean     locked);
-
-guint               gsm_store_size                     (GsmStore    *store);
-gboolean            gsm_store_add                      (GsmStore    *store,
-                                                        const char  *id,
-                                                        GObject     *object);
-void                gsm_store_clear                    (GsmStore    *store);
-gboolean            gsm_store_remove                   (GsmStore    *store,
-                                                        const char  *id);
-
-void                gsm_store_foreach                  (GsmStore    *store,
-                                                        GsmStoreFunc func,
-                                                        gpointer     user_data);
-guint               gsm_store_foreach_remove           (GsmStore    *store,
-                                                        GsmStoreFunc func,
-                                                        gpointer     user_data);
-GObject *           gsm_store_find                     (GsmStore    *store,
-                                                        GsmStoreFunc predicate,
-                                                        gpointer     user_data);
-GObject *           gsm_store_lookup                   (GsmStore    *store,
-                                                        const char  *id);
-
-
-G_END_DECLS
-
-#endif /* __GSM_STORE_H */
diff --git a/gnome-session/gsm-system.c b/gnome-session/gsm-system.c
deleted file mode 100644
index 0be1bf7..0000000
--- a/gnome-session/gsm-system.c
+++ /dev/null
@@ -1,213 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2012 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#include "config.h"
-
-#include <glib-object.h>
-#include <glib/gi18n.h>
-
-#include "gsm-system.h"
-#include "gsm-consolekit.h"
-#include "gsm-systemd.h"
-
-enum {
-        REQUEST_COMPLETED,
-        SHUTDOWN_PREPARED,
-        LAST_SIGNAL
-};
-
-enum {
-        PROP_0,
-        PROP_ACTIVE
-};
-
-static guint signals[LAST_SIGNAL] = { 0 };
-
-G_DEFINE_INTERFACE (GsmSystem, gsm_system, G_TYPE_OBJECT)
-
-static void
-gsm_system_default_init (GsmSystemInterface *iface)
-{
-        GParamSpec *pspec;
-        signals [REQUEST_COMPLETED] =
-                g_signal_new ("request-completed",
-                              GSM_TYPE_SYSTEM,
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmSystemInterface, request_completed),
-                              NULL, NULL, NULL,
-                              G_TYPE_NONE,
-                              1, G_TYPE_POINTER);
-        signals[SHUTDOWN_PREPARED] =
-                 g_signal_new ("shutdown-prepared",
-                               GSM_TYPE_SYSTEM,
-                               G_SIGNAL_RUN_LAST,
-                               G_STRUCT_OFFSET (GsmSystemInterface, shutdown_prepared),
-                               NULL, NULL, NULL,
-                               G_TYPE_NONE,
-                               1, G_TYPE_BOOLEAN);
-        pspec = g_param_spec_boolean ("active",
-                                      "Active",
-                                      "Whether or not session is active",
-                                      TRUE,
-                                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT);
-        g_object_interface_install_property (iface, pspec);
-}
-
-GQuark
-gsm_system_error_quark (void)
-{
-        static GQuark error_quark = 0;
-
-        if (error_quark == 0) {
-                error_quark = g_quark_from_static_string ("gsm-system-error");
-        }
-
-        return error_quark;
-}
-
-gboolean
-gsm_system_can_switch_user (GsmSystem *system)
-{
-        return GSM_SYSTEM_GET_IFACE (system)->can_switch_user (system);
-}
-
-gboolean
-gsm_system_can_stop (GsmSystem *system)
-{
-        return GSM_SYSTEM_GET_IFACE (system)->can_stop (system);
-}
-
-gboolean
-gsm_system_can_restart (GsmSystem *system)
-{
-        return GSM_SYSTEM_GET_IFACE (system)->can_restart (system);
-}
-
-gboolean
-gsm_system_can_suspend (GsmSystem *system)
-{
-        return GSM_SYSTEM_GET_IFACE (system)->can_suspend (system);
-}
-
-gboolean
-gsm_system_can_hibernate (GsmSystem *system)
-{
-        return GSM_SYSTEM_GET_IFACE (system)->can_hibernate (system);
-}
-
-void
-gsm_system_attempt_stop (GsmSystem *system)
-{
-        GSM_SYSTEM_GET_IFACE (system)->attempt_stop (system);
-}
-
-void
-gsm_system_attempt_restart (GsmSystem *system)
-{
-        GSM_SYSTEM_GET_IFACE (system)->attempt_restart (system);
-}
-
-void
-gsm_system_suspend (GsmSystem *system)
-{
-        GSM_SYSTEM_GET_IFACE (system)->suspend (system);
-}
-
-void
-gsm_system_hibernate (GsmSystem *system)
-{
-        GSM_SYSTEM_GET_IFACE (system)->hibernate (system);
-}
-
-void
-gsm_system_set_session_idle (GsmSystem *system,
-                             gboolean   is_idle)
-{
-        GSM_SYSTEM_GET_IFACE (system)->set_session_idle (system, is_idle);
-}
-
-void
-gsm_system_add_inhibitor (GsmSystem        *system,
-                          const gchar      *id,
-                          GsmInhibitorFlag  flag)
-{
-        GSM_SYSTEM_GET_IFACE (system)->add_inhibitor (system, id, flag);
-}
-
-void
-gsm_system_remove_inhibitor (GsmSystem   *system,
-                             const gchar *id)
-{
-        GSM_SYSTEM_GET_IFACE (system)->remove_inhibitor (system, id);
-}
-
-gboolean
-gsm_system_is_login_session (GsmSystem *system)
-{
-        return GSM_SYSTEM_GET_IFACE (system)->is_login_session (system);
-}
-
-/**
- * gsm_system_is_active:
- *
- * Returns: %TRUE if the current session is in the foreground
- * Since: 3.8
- */
-gboolean
-gsm_system_is_active (GsmSystem *system)
-{
-        gboolean is_active;
-        g_object_get ((GObject*)system, "active", &is_active, NULL);
-        return is_active;
-}
-
-void
-gsm_system_prepare_shutdown  (GsmSystem *system,
-                              gboolean   restart)
-{
-        GSM_SYSTEM_GET_IFACE (system)->prepare_shutdown (system, restart);
-}
-
-void
-gsm_system_complete_shutdown (GsmSystem *system)
-{
-        GSM_SYSTEM_GET_IFACE (system)->complete_shutdown (system);
-}
-
-GsmSystem *
-gsm_get_system (void)
-{
-        static GsmSystem *system = NULL;
-
-        if (system == NULL) {
-                system = GSM_SYSTEM (gsm_systemd_new ());
-                if (system != NULL) {
-                        g_debug ("Using systemd for session tracking");
-                }
-        }
-        if (system == NULL) {
-                system = GSM_SYSTEM (gsm_consolekit_new ());
-                if (system != NULL) {
-                        g_debug ("Using ConsoleKit for session tracking");
-                }
-        }
-
-        return g_object_ref (system);
-}
diff --git a/gnome-session/gsm-system.h b/gnome-session/gsm-system.h
deleted file mode 100644
index c1c0d76..0000000
--- a/gnome-session/gsm-system.h
+++ /dev/null
@@ -1,127 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2008 Jon McCann <jmccann@redhat.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- *
- * Authors:
- *	Jon McCann <jmccann@redhat.com>
- */
-
-#ifndef __GSM_SYSTEM_H__
-#define __GSM_SYSTEM_H__
-
-#include <glib.h>
-#include <glib-object.h>
-
-#include "gsm-inhibitor.h"
-
-G_BEGIN_DECLS
-
-#define GSM_TYPE_SYSTEM             (gsm_system_get_type ())
-#define GSM_SYSTEM(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSM_TYPE_SYSTEM, GsmSystem))
-#define GSM_SYSTEM_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSM_TYPE_SYSTEM, GsmSystemInterface))
-#define GSM_IS_SYSTEM(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSM_TYPE_SYSTEM))
-#define GSM_SYSTEM_GET_IFACE(obj)   (G_TYPE_INSTANCE_GET_INTERFACE((obj), GSM_TYPE_SYSTEM, GsmSystemInterface))
-#define GSM_SYSTEM_ERROR            (gsm_system_error_quark ())
-
-typedef struct _GsmSystem          GsmSystem;
-typedef struct _GsmSystemInterface GsmSystemInterface;
-typedef enum   _GsmSystemError     GsmSystemError;
-
-struct _GsmSystemInterface
-{
-        GTypeInterface base_interface;
-
-        void (* request_completed)    (GsmSystem *system,
-                                       GError    *error);
-
-        void (* shutdown_prepared)    (GsmSystem *system,
-                                       gboolean   success);
-
-        gboolean (* can_switch_user)  (GsmSystem *system);
-        gboolean (* can_stop)         (GsmSystem *system);
-        gboolean (* can_restart)      (GsmSystem *system);
-        gboolean (* can_suspend)      (GsmSystem *system);
-        gboolean (* can_hibernate)    (GsmSystem *system);
-        void     (* attempt_stop)     (GsmSystem *system);
-        void     (* attempt_restart)  (GsmSystem *system);
-        void     (* suspend)          (GsmSystem *system);
-        void     (* hibernate)        (GsmSystem *system);
-        void     (* set_session_idle) (GsmSystem *system,
-                                       gboolean   is_idle);
-        gboolean (* is_login_session) (GsmSystem *system);
-        void     (* add_inhibitor)    (GsmSystem        *system,
-                                       const gchar      *id,
-                                       GsmInhibitorFlag  flags);
-        void     (* remove_inhibitor) (GsmSystem        *system,
-                                       const gchar      *id);
-        void     (* prepare_shutdown) (GsmSystem   *system,
-                                       gboolean     restart);
-        void     (* complete_shutdown)(GsmSystem   *system);
-};
-
-enum _GsmSystemError {
-        GSM_SYSTEM_ERROR_RESTARTING = 0,
-        GSM_SYSTEM_ERROR_STOPPING
-};
-
-GType      gsm_system_get_type         (void);
-
-GQuark     gsm_system_error_quark      (void);
-
-GsmSystem *gsm_get_system              (void);
-
-gboolean   gsm_system_can_switch_user  (GsmSystem *system);
-
-gboolean   gsm_system_can_stop         (GsmSystem *system);
-
-gboolean   gsm_system_can_restart      (GsmSystem *system);
-
-gboolean   gsm_system_can_suspend      (GsmSystem *system);
-
-gboolean   gsm_system_can_hibernate    (GsmSystem *system);
-
-void       gsm_system_attempt_stop     (GsmSystem *system);
-
-void       gsm_system_attempt_restart  (GsmSystem *system);
-
-void       gsm_system_suspend          (GsmSystem *system);
-
-void       gsm_system_hibernate        (GsmSystem *system);
-
-void       gsm_system_set_session_idle (GsmSystem *system,
-                                        gboolean   is_idle);
-
-gboolean   gsm_system_is_login_session (GsmSystem *system);
-
-gboolean   gsm_system_is_active        (GsmSystem *system);
-
-void       gsm_system_add_inhibitor    (GsmSystem        *system,
-                                        const gchar      *id,
-                                        GsmInhibitorFlag  flags);
-
-void       gsm_system_remove_inhibitor (GsmSystem        *system,
-                                        const gchar      *id);
-void       gsm_system_prepare_shutdown  (GsmSystem  *system,
-                                         gboolean    restart);
-void       gsm_system_complete_shutdown (GsmSystem  *system);
-
-
-
-G_END_DECLS
-
-#endif /* __GSM_SYSTEM_H__ */
diff --git a/gnome-session/gsm-systemd.c b/gnome-session/gsm-systemd.c
deleted file mode 100644
index c00b1d0..0000000
--- a/gnome-session/gsm-systemd.c
+++ /dev/null
@@ -1,959 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- *
- * Author: Matthias Clasen
- */
-
-#include "config.h"
-#include "gsm-systemd.h"
-
-#ifdef HAVE_SYSTEMD
-
-#include <errno.h>
-#include <string.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <pwd.h>
-
-#include <systemd/sd-login.h>
-
-#include <glib.h>
-#include <glib-object.h>
-#include <glib/gi18n.h>
-#include <gio/gio.h>
-#include <gio/gunixfdlist.h>
-
-#include "gsm-system.h"
-
-#define SD_NAME              "org.freedesktop.login1"
-#define SD_PATH              "/org/freedesktop/login1"
-#define SD_INTERFACE         "org.freedesktop.login1.Manager"
-#define SD_SEAT_INTERFACE    "org.freedesktop.login1.Seat"
-#define SD_SESSION_INTERFACE "org.freedesktop.login1.Session"
-
-struct _GsmSystemdPrivate
-{
-        GSource         *sd_source;
-        GDBusProxy      *sd_proxy;
-        char            *session_id;
-        gchar           *session_path;
-
-        GSList          *inhibitors;
-        gint             inhibit_fd;
-
-        gboolean         is_active;
-
-        gint             delay_inhibit_fd;
-        gboolean         prepare_for_shutdown_expected;
-};
-
-enum {
-        PROP_0,
-        PROP_ACTIVE
-};
-
-static void gsm_systemd_system_init (GsmSystemInterface *iface);
-
-G_DEFINE_TYPE_WITH_CODE (GsmSystemd, gsm_systemd, G_TYPE_OBJECT,
-                         G_IMPLEMENT_INTERFACE (GSM_TYPE_SYSTEM,
-                                                gsm_systemd_system_init))
-
-static void
-drop_system_inhibitor (GsmSystemd *manager)
-{
-        if (manager->priv->inhibit_fd != -1) {
-                g_debug ("GsmSystemd: Dropping system inhibitor");
-                close (manager->priv->inhibit_fd);
-                manager->priv->inhibit_fd = -1;
-        }
-}
-
-static void
-drop_delay_inhibitor (GsmSystemd *manager)
-{
-        if (manager->priv->delay_inhibit_fd != -1) {
-                g_debug ("GsmSystemd: Dropping delay inhibitor");
-                close (manager->priv->delay_inhibit_fd);
-                manager->priv->delay_inhibit_fd = -1;
-        }
-}
-
-static void
-gsm_systemd_finalize (GObject *object)
-{
-        GsmSystemd *systemd = GSM_SYSTEMD (object);
-
-        g_clear_object (&systemd->priv->sd_proxy);
-        free (systemd->priv->session_id);
-        g_free (systemd->priv->session_path);
-
-        if (systemd->priv->sd_source) {
-                g_source_destroy (systemd->priv->sd_source);
-        }
-
-        if (systemd->priv->inhibitors != NULL) {
-                g_slist_free_full (systemd->priv->inhibitors, g_free);
-        }
-        drop_system_inhibitor (systemd);
-        drop_delay_inhibitor (systemd);
-
-        G_OBJECT_CLASS (gsm_systemd_parent_class)->finalize (object);
-}
-
-static void
-gsm_systemd_set_property (GObject      *object,
-                          guint         prop_id,
-                          const GValue *value,
-                          GParamSpec   *pspec)
-{
-        GsmSystemd *self = GSM_SYSTEMD (object);
-
-        switch (prop_id) {
-        case PROP_ACTIVE:
-                self->priv->is_active = g_value_get_boolean (value);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-        }
-}
-
-static void
-gsm_systemd_get_property (GObject    *object,
-                          guint       prop_id,
-                          GValue     *value,
-                          GParamSpec *pspec)
-{
-        GsmSystemd *self = GSM_SYSTEMD (object);
-
-        switch (prop_id) {
-        case PROP_ACTIVE:
-                g_value_set_boolean (value, self->priv->is_active);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_systemd_class_init (GsmSystemdClass *manager_class)
-{
-        GObjectClass *object_class;
-
-        object_class = G_OBJECT_CLASS (manager_class);
-
-        object_class->get_property = gsm_systemd_get_property;
-        object_class->set_property = gsm_systemd_set_property;
-        object_class->finalize = gsm_systemd_finalize;
-
-        g_object_class_override_property (object_class, PROP_ACTIVE, "active");
-
-        g_type_class_add_private (manager_class, sizeof (GsmSystemdPrivate));
-}
-
-typedef struct
-{
-        GSource source;
-        GPollFD pollfd;
-        sd_login_monitor *monitor;
-} SdSource;
-
-static gboolean
-sd_source_prepare (GSource *source,
-                   gint    *timeout)
-{
-        *timeout = -1;
-        return FALSE;
-}
-
-static gboolean
-sd_source_check (GSource *source)
-{
-        SdSource *sd_source = (SdSource *)source;
-
-        return sd_source->pollfd.revents != 0;
-}
-
-static gboolean
-sd_source_dispatch (GSource     *source,
-                    GSourceFunc  callback,
-                    gpointer     user_data)
-
-{
-        SdSource *sd_source = (SdSource *)source;
-        gboolean ret;
-
-        g_warn_if_fail (callback != NULL);
-
-        ret = (*callback) (user_data);
-
-        sd_login_monitor_flush (sd_source->monitor);
-        return ret;
-}
-
-static void
-sd_source_finalize (GSource *source)
-{
-        SdSource *sd_source = (SdSource*)source;
-
-        sd_login_monitor_unref (sd_source->monitor);
-}
-
-static GSourceFuncs sd_source_funcs = {
-        sd_source_prepare,
-        sd_source_check,
-        sd_source_dispatch,
-        sd_source_finalize
-};
-
-static GSource *
-sd_source_new (void)
-{
-        GSource *source;
-        SdSource *sd_source;
-        int ret;
-
-        source = g_source_new (&sd_source_funcs, sizeof (SdSource));
-        sd_source = (SdSource *)source;
-
-        if ((ret = sd_login_monitor_new (NULL, &sd_source->monitor)) < 0) {
-                g_warning ("Error getting login monitor: %d", ret);
-        } else {
-                sd_source->pollfd.fd = sd_login_monitor_get_fd (sd_source->monitor);
-                sd_source->pollfd.events = G_IO_IN;
-                g_source_add_poll (source, &sd_source->pollfd);
-        }
-
-        return source;
-}
-
-static gboolean
-on_sd_source_changed (gpointer user_data)
-{
-        GsmSystemd *self = user_data;
-        int active_r;
-        gboolean active;
-
-        active_r = sd_session_is_active (self->priv->session_id);
-        if (active_r < 0)
-                active = FALSE;
-        else
-                active = active_r;
-        if (active != self->priv->is_active) {
-                self->priv->is_active = active;
-                g_object_notify (G_OBJECT (self), "active");
-        }
-
-        return TRUE;
-}
-
-static void sd_proxy_signal_cb (GDBusProxy  *proxy,
-                                const gchar *sender_name,
-                                const gchar *signal_name,
-                                GVariant    *parameters,
-                                gpointer     user_data);
-
-static void
-gsm_systemd_init (GsmSystemd *manager)
-{
-        GError *error = NULL;
-        GDBusConnection *bus;
-        GVariant *res;
-
-        manager->priv = G_TYPE_INSTANCE_GET_PRIVATE (manager,
-                                                     GSM_TYPE_SYSTEMD,
-                                                     GsmSystemdPrivate);
-
-        manager->priv->inhibit_fd = -1;
-        manager->priv->delay_inhibit_fd = -1;
-
-        bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, &error);
-        if (bus == NULL)
-                g_error ("Failed to connect to system bus: %s",
-                         error->message);
-        manager->priv->sd_proxy =
-                g_dbus_proxy_new_sync (bus,
-                                       0,
-                                       NULL,
-                                       SD_NAME,
-                                       SD_PATH,
-                                       SD_INTERFACE,
-                                       NULL,
-                                       &error);
-        if (manager->priv->sd_proxy == NULL) {
-                g_warning ("Failed to connect to systemd: %s",
-                           error->message);
-                g_clear_error (&error);
-        }
-
-        g_signal_connect (manager->priv->sd_proxy, "g-signal",
-                          G_CALLBACK (sd_proxy_signal_cb), manager);
-
-        sd_pid_get_session (getpid (), &manager->priv->session_id);
-
-        if (manager->priv->session_id == NULL) {
-                g_warning ("Could not get session id for session. Check that logind is "
-                           "properly installed and pam_systemd is getting used at login.");
-                return;
-        }
-
-        res = g_dbus_proxy_call_sync (manager->priv->sd_proxy,
-                                      "GetSession",
-                                      g_variant_new ("(s)", manager->priv->session_id),
-                                      0,
-                                      G_MAXINT,
-                                      NULL,
-                                      NULL);
-        if (res == NULL) {
-                g_warning ("Could not get session id for session. Check that logind is "
-                           "properly installed and pam_systemd is getting used at login.");
-                return;
-        }
-
-        g_variant_get (res, "(o)", &manager->priv->session_path);
-        g_variant_unref (res);
-
-        manager->priv->sd_source = sd_source_new ();
-        g_source_set_callback (manager->priv->sd_source, on_sd_source_changed, manager, NULL);
-        g_source_attach (manager->priv->sd_source, NULL);
-
-        on_sd_source_changed (manager);
-
-        g_object_unref (bus);
-}
-
-static void
-emit_restart_complete (GsmSystemd *manager,
-                       GError     *error)
-{
-        GError *call_error;
-
-        call_error = NULL;
-
-        if (error != NULL) {
-                call_error = g_error_new_literal (GSM_SYSTEM_ERROR,
-                                                  GSM_SYSTEM_ERROR_RESTARTING,
-                                                  error->message);
-        }
-
-        g_signal_emit_by_name (G_OBJECT (manager),
-                               "request_completed", call_error);
-
-        if (call_error != NULL) {
-                g_error_free (call_error);
-        }
-}
-
-static void
-emit_stop_complete (GsmSystemd *manager,
-                    GError     *error)
-{
-        GError *call_error;
-
-        call_error = NULL;
-
-        if (error != NULL) {
-                call_error = g_error_new_literal (GSM_SYSTEM_ERROR,
-                                                  GSM_SYSTEM_ERROR_STOPPING,
-                                                  error->message);
-        }
-
-        g_signal_emit_by_name (G_OBJECT (manager),
-                               "request_completed", call_error);
-
-        if (call_error != NULL) {
-                g_error_free (call_error);
-        }
-}
-
-static void
-restart_done (GObject      *source,
-              GAsyncResult *result,
-              gpointer      user_data)
-{
-        GDBusProxy *proxy = G_DBUS_PROXY (source);
-        GsmSystemd *manager = user_data;
-        GError *error = NULL;
-        GVariant *res;
-
-        res = g_dbus_proxy_call_finish (proxy, result, &error);
-
-        if (!res) {
-                g_warning ("Unable to restart system: %s", error->message);
-                emit_restart_complete (manager, error);
-                g_error_free (error);
-        } else {
-                emit_restart_complete (manager, NULL);
-                g_variant_unref (res);
-        }
-}
-
-static void
-gsm_systemd_attempt_restart (GsmSystem *system)
-{
-        GsmSystemd *manager = GSM_SYSTEMD (system);
-
-        g_dbus_proxy_call (manager->priv->sd_proxy,
-                           "Reboot",
-                           g_variant_new ("(b)", TRUE),
-                           0,
-                           G_MAXINT,
-                           NULL,
-                           restart_done,
-                           manager);
-}
-
-static void
-stop_done (GObject      *source,
-           GAsyncResult *result,
-           gpointer      user_data)
-{
-        GDBusProxy *proxy = G_DBUS_PROXY (source);
-        GsmSystemd *manager = user_data;
-        GError *error = NULL;
-        GVariant *res;
-
-        res = g_dbus_proxy_call_finish (proxy, result, &error);
-
-        if (!res) {
-                g_warning ("Unable to stop system: %s", error->message);
-                emit_stop_complete (manager, error);
-                g_error_free (error);
-        } else {
-                emit_stop_complete (manager, NULL);
-                g_variant_unref (res);
-        }
-}
-
-static void
-gsm_systemd_attempt_stop (GsmSystem *system)
-{
-        GsmSystemd *manager = GSM_SYSTEMD (system);
-
-        g_dbus_proxy_call (manager->priv->sd_proxy,
-                           "PowerOff",
-                           g_variant_new ("(b)", TRUE),
-                           0,
-                           G_MAXINT,
-                           NULL,
-                           stop_done,
-                           manager);
-}
-
-static void
-gsm_systemd_set_session_idle (GsmSystem *system,
-                              gboolean   is_idle)
-{
-        GsmSystemd *manager = GSM_SYSTEMD (system);
-        GDBusConnection *bus;
-
-        g_debug ("Updating systemd idle status: %d", is_idle);
-        bus = g_dbus_proxy_get_connection (manager->priv->sd_proxy);
-        g_dbus_connection_call (bus,
-                                SD_NAME,
-                                manager->priv->session_path,
-                                SD_SESSION_INTERFACE,
-                                "SetIdleHint",
-                                g_variant_new ("(b)", is_idle),
-                                G_VARIANT_TYPE_BOOLEAN,
-                                0,
-                                G_MAXINT,
-                                NULL, NULL, NULL);
-}
-
-static gboolean
-gsm_systemd_can_switch_user (GsmSystem *system)
-{
-        GsmSystemd *manager = GSM_SYSTEMD (system);
-        gchar *seat;
-        gint ret;
-
-        sd_session_get_seat (manager->priv->session_id, &seat);
-        ret = sd_seat_can_multi_session (seat);
-        free (seat);
-
-        return ret > 0;
-}
-
-static gboolean
-gsm_systemd_can_restart (GsmSystem *system)
-{
-        GsmSystemd *manager = GSM_SYSTEMD (system);
-        gchar *rv;
-        GVariant *res;
-        gboolean can_restart;
-
-        res = g_dbus_proxy_call_sync (manager->priv->sd_proxy,
-                                      "CanReboot",
-                                      NULL,
-                                      0,
-                                      G_MAXINT,
-                                      NULL,
-                                      NULL);
-        if (!res) {
-                g_warning ("Calling CanReboot failed. Check that logind is "
-                           "properly installed and pam_systemd is getting used at login.");
-                return FALSE;
-        }
-
-        g_variant_get (res, "(s)", &rv);
-        g_variant_unref (res);
-
-        can_restart = g_strcmp0 (rv, "yes") == 0 ||
-                      g_strcmp0 (rv, "challenge") == 0;
-
-        g_free (rv);
-
-        return can_restart;
-}
-
-static gboolean
-gsm_systemd_can_stop (GsmSystem *system)
-{
-        GsmSystemd *manager = GSM_SYSTEMD (system);
-        gchar *rv;
-        GVariant *res;
-        gboolean can_stop;
-
-        res = g_dbus_proxy_call_sync (manager->priv->sd_proxy,
-                                      "CanPowerOff",
-                                      NULL,
-                                      0,
-                                      G_MAXINT,
-                                      NULL,
-                                      NULL);
-        if (!res) {
-                g_warning ("Calling CanPowerOff failed. Check that logind is "
-                           "properly installed and pam_systemd is getting used at login.");
-                return FALSE;
-        }
-
-        g_variant_get (res, "(s)", &rv);
-        g_variant_unref (res);
-
-        can_stop = g_strcmp0 (rv, "yes") == 0 ||
-                   g_strcmp0 (rv, "challenge") == 0;
-
-        g_free (rv);
-
-        return can_stop;
-}
-
-static gboolean
-gsm_systemd_is_login_session (GsmSystem *system)
-{
-        GsmSystemd *manager = GSM_SYSTEMD (system);
-        int res;
-        gboolean ret;
-        gchar *session_class = NULL;
-
-        ret = FALSE;
-
-        if (manager->priv->session_id == NULL) {
-                return ret;
-        }
-
-        res = sd_session_get_class (manager->priv->session_id, &session_class);
-        if (res < 0) {
-                g_warning ("Could not get session class: %s", strerror (-res));
-                return FALSE;
-        }
-        ret = (g_strcmp0 (session_class, "greeter") == 0);
-        free (session_class);
-
-        return ret;
-}
-
-static gboolean
-gsm_systemd_can_suspend (GsmSystem *system)
-{
-        GsmSystemd *manager = GSM_SYSTEMD (system);
-        gchar *rv;
-        GVariant *res;
-        gboolean can_suspend;
-
-        res = g_dbus_proxy_call_sync (manager->priv->sd_proxy,
-                                      "CanSuspend",
-                                      NULL,
-                                      0,
-                                      G_MAXINT,
-                                      NULL,
-                                      NULL);
-        if (!res) {
-                g_warning ("Calling CanSuspend failed. Check that logind is "
-                           "properly installed and pam_systemd is getting used at login.");
-                return FALSE;
-        }
-
-        g_variant_get (res, "(s)", &rv);
-        g_variant_unref (res);
-
-        can_suspend = g_strcmp0 (rv, "yes") == 0 ||
-                      g_strcmp0 (rv, "challenge") == 0;
-
-        g_free (rv);
-
-        return can_suspend;
-}
-
-static gboolean
-gsm_systemd_can_hibernate (GsmSystem *system)
-{
-        GsmSystemd *manager = GSM_SYSTEMD (system);
-        gchar *rv;
-        GVariant *res;
-        gboolean can_hibernate;
-
-        res = g_dbus_proxy_call_sync (manager->priv->sd_proxy,
-                                      "CanHibernate",
-                                      NULL,
-                                      0,
-                                      G_MAXINT,
-                                      NULL,
-                                      NULL);
-        if (!res) {
-                g_warning ("Calling CanHibernate failed. Check that logind is "
-                           "properly installed and pam_systemd is getting used at login.");
-                return FALSE;
-        }
-
-        g_variant_get (res, "(s)", &rv);
-        g_variant_unref (res);
-
-        can_hibernate = g_strcmp0 (rv, "yes") == 0 ||
-                        g_strcmp0 (rv, "challenge") == 0;
-
-        g_free (rv);
-
-        return can_hibernate;
-}
-
-static void
-suspend_done (GObject      *source,
-              GAsyncResult *result,
-              gpointer      user_data)
-{
-        GDBusProxy *proxy = G_DBUS_PROXY (source);
-        GError *error = NULL;
-        GVariant *res;
-
-        res = g_dbus_proxy_call_finish (proxy, result, &error);
-
-        if (!res) {
-                g_warning ("Unable to suspend system: %s", error->message);
-                g_error_free (error);
-        } else {
-                g_variant_unref (res);
-        }
-}
-
-static void
-hibernate_done (GObject      *source,
-                GAsyncResult *result,
-              gpointer      user_data)
-{
-        GDBusProxy *proxy = G_DBUS_PROXY (source);
-        GError *error = NULL;
-        GVariant *res;
-
-        res = g_dbus_proxy_call_finish (proxy, result, &error);
-
-        if (!res) {
-                g_warning ("Unable to hibernate system: %s", error->message);
-                g_error_free (error);
-        } else {
-                g_variant_unref (res);
-        }
-}
-
-static void
-gsm_systemd_suspend (GsmSystem *system)
-{
-        GsmSystemd *manager = GSM_SYSTEMD (system);
-
-        g_dbus_proxy_call (manager->priv->sd_proxy,
-                           "Suspend",
-                           g_variant_new ("(b)", TRUE),
-                           0,
-                           G_MAXINT,
-                           NULL,
-                           hibernate_done,
-                           manager);
-}
-
-static void
-gsm_systemd_hibernate (GsmSystem *system)
-{
-        GsmSystemd *manager = GSM_SYSTEMD (system);
-
-        g_dbus_proxy_call (manager->priv->sd_proxy,
-                           "Hibernate",
-                           g_variant_new ("(b)", TRUE),
-                           0,
-                           G_MAXINT,
-                           NULL,
-                           suspend_done,
-                           manager);
-}
-
-static void
-inhibit_done (GObject      *source,
-              GAsyncResult *result,
-              gpointer      user_data)
-{
-        GDBusProxy *proxy = G_DBUS_PROXY (source);
-        GsmSystemd *manager = GSM_SYSTEMD (user_data);
-        GError *error = NULL;
-        GVariant *res;
-        GUnixFDList *fd_list = NULL;
-        gint idx;
-
-        res = g_dbus_proxy_call_with_unix_fd_list_finish (proxy, &fd_list, result, &error);
-
-        if (!res) {
-                g_warning ("Unable to inhibit system: %s", error->message);
-                g_error_free (error);
-        } else {
-                g_variant_get (res, "(h)", &idx);
-                manager->priv->inhibit_fd = g_unix_fd_list_get (fd_list, idx, &error);
-                if (manager->priv->inhibit_fd == -1) {
-                        g_warning ("Failed to receive system inhibitor fd: %s", error->message);
-                        g_error_free (error);
-                }
-                g_debug ("System inhibitor fd is %d", manager->priv->inhibit_fd);
-                g_object_unref (fd_list);
-                g_variant_unref (res);
-        }
-
-        if (manager->priv->inhibitors == NULL) {
-                drop_system_inhibitor (manager);
-        }
-}
-
-static void
-gsm_systemd_add_inhibitor (GsmSystem        *system,
-                           const gchar      *id,
-                           GsmInhibitorFlag  flag)
-{
-        GsmSystemd *manager = GSM_SYSTEMD (system);
-
-        if ((flag & GSM_INHIBITOR_FLAG_SUSPEND) == 0)
-                return;
-
-        if (manager->priv->inhibitors == NULL) {
-                g_debug ("Adding system inhibitor");
-                g_dbus_proxy_call_with_unix_fd_list (manager->priv->sd_proxy,
-                                                     "Inhibit",
-                                                     g_variant_new ("(ssss)",
-                                                                    "sleep:shutdown",
-                                                                    g_get_user_name (),
-                                                                    "user session inhibited",
-                                                                    "block"),
-                                                     0,
-                                                     G_MAXINT,
-                                                     NULL,
-                                                     NULL,
-                                                     inhibit_done,
-                                                     manager);
-        }
-        manager->priv->inhibitors = g_slist_prepend (manager->priv->inhibitors, g_strdup (id));
-}
-
-static void
-gsm_systemd_remove_inhibitor (GsmSystem   *system,
-                              const gchar *id)
-{
-        GsmSystemd *manager = GSM_SYSTEMD (system);
-        GSList *l;
-
-        l = g_slist_find_custom (manager->priv->inhibitors, id, (GCompareFunc)g_strcmp0);
-        if (l == NULL)
-                return;
-
-        g_free (l->data);
-        manager->priv->inhibitors = g_slist_delete_link (manager->priv->inhibitors, l);
-        if (manager->priv->inhibitors == NULL) {
-                drop_system_inhibitor (manager);
-        }
-}
-
-static void
-reboot_or_poweroff_done (GObject      *source,
-                         GAsyncResult *res,
-                         gpointer      user_data)
-{
-        GsmSystemd *systemd = user_data;
-        GVariant *result;
-        GError *error = NULL;
-
-        result = g_dbus_proxy_call_finish (G_DBUS_PROXY (source),
-                                           res,
-                                           &error);
-
-        if (result == NULL) {
-                if (!g_error_matches (error, G_DBUS_ERROR, G_DBUS_ERROR_ACCESS_DENIED)) {
-                        g_warning ("Shutdown failed: %s", error->message);
-                }
-                g_error_free (error);
-                drop_delay_inhibitor (systemd);
-                g_debug ("GsmSystemd: shutdown preparation failed");
-                systemd->priv->prepare_for_shutdown_expected = FALSE;
-                g_signal_emit_by_name (systemd, "shutdown-prepared", FALSE);
-        } else {
-                g_variant_unref (result);
-        }
-}
-
-static void
-gsm_systemd_prepare_shutdown (GsmSystem *system,
-                              gboolean   restart)
-{
-        GsmSystemd *systemd = GSM_SYSTEMD (system);
-        GUnixFDList *fd_list;
-        GVariant *res;
-        GError *error = NULL;
-        gint idx;
-
-        g_debug ("GsmSystemd: prepare shutdown");
-
-        res = g_dbus_proxy_call_with_unix_fd_list_sync (systemd->priv->sd_proxy,
-                                                        "Inhibit",
-                                                        g_variant_new ("(ssss)",
-                                                                       "shutdown",
-                                                                       g_get_user_name (),
-                                                                       "Preparing to end the session",
-                                                                       "delay"),
-                                                        0,
-                                                        G_MAXINT,
-                                                        NULL,
-                                                        &fd_list,
-                                                        NULL,
-                                                        &error);
-        if (res == NULL) {
-                g_warning ("Failed to get delay inhibitor: %s", error->message);
-                g_error_free (error);
-                g_signal_emit_by_name (systemd, "shutdown-prepared", FALSE);
-                return;
-        }
-
-        g_variant_get (res, "(h)", &idx);
-
-        systemd->priv->delay_inhibit_fd = g_unix_fd_list_get (fd_list, idx, NULL);
-
-        g_debug ("GsmSystemd: got delay inhibitor, fd = %d", systemd->priv->delay_inhibit_fd);
-
-        g_variant_unref (res);
-        g_object_unref (fd_list);
-
-        systemd->priv->prepare_for_shutdown_expected = TRUE;
-
-        g_dbus_proxy_call (systemd->priv->sd_proxy,
-                           restart ? "Reboot" : "PowerOff",
-                           g_variant_new ("(b)", TRUE),
-                           0,
-                           G_MAXINT,
-                           NULL,
-                           reboot_or_poweroff_done,
-                           systemd);
-}
-
-static void
-gsm_systemd_complete_shutdown (GsmSystem *system)
-{
-        GsmSystemd *systemd = GSM_SYSTEMD (system);
-
-        /* remove delay inhibitor, if any */
-        drop_delay_inhibitor (systemd);
-}
-
-static void
-gsm_systemd_system_init (GsmSystemInterface *iface)
-{
-        iface->can_switch_user = gsm_systemd_can_switch_user;
-        iface->can_stop = gsm_systemd_can_stop;
-        iface->can_restart = gsm_systemd_can_restart;
-        iface->can_suspend = gsm_systemd_can_suspend;
-        iface->can_hibernate = gsm_systemd_can_hibernate;
-        iface->attempt_stop = gsm_systemd_attempt_stop;
-        iface->attempt_restart = gsm_systemd_attempt_restart;
-        iface->suspend = gsm_systemd_suspend;
-        iface->hibernate = gsm_systemd_hibernate;
-        iface->set_session_idle = gsm_systemd_set_session_idle;
-        iface->is_login_session = gsm_systemd_is_login_session;
-        iface->add_inhibitor = gsm_systemd_add_inhibitor;
-        iface->remove_inhibitor = gsm_systemd_remove_inhibitor;
-        iface->prepare_shutdown = gsm_systemd_prepare_shutdown;
-        iface->complete_shutdown = gsm_systemd_complete_shutdown;
-}
-
-GsmSystemd *
-gsm_systemd_new (void)
-{
-        GsmSystemd *manager;
-
-        /* logind is not running ? */
-        if (access("/run/systemd/seats/", F_OK) < 0)
-                return NULL;
-
-        manager = g_object_new (GSM_TYPE_SYSTEMD, NULL);
-
-        return manager;
-}
-
-static void
-sd_proxy_signal_cb (GDBusProxy  *proxy,
-                    const gchar *sender_name,
-                    const gchar *signal_name,
-                    GVariant    *parameters,
-                    gpointer     user_data)
-{
-        GsmSystemd *systemd = user_data;
-        gboolean is_about_to_shutdown;
-
-        g_debug ("GsmSystemd: received logind signal: %s", signal_name);
-
-        if (g_strcmp0 (signal_name, "PrepareForShutdown") != 0) {
-                g_debug ("GsmSystemd: ignoring %s signal", signal_name);
-                return;
-        }
-
-        g_variant_get (parameters, "(b)", &is_about_to_shutdown);
-        if (!is_about_to_shutdown) {
-                g_debug ("GsmSystemd: ignoring %s signal since about-to-shutdown is FALSE", signal_name);
-                return;
-        }
-
-        if (systemd->priv->prepare_for_shutdown_expected) {
-                g_debug ("GsmSystemd: shutdown successfully prepared");
-                g_signal_emit_by_name (systemd, "shutdown-prepared", TRUE);
-                systemd->priv->prepare_for_shutdown_expected = FALSE;
-        }
-}
-
-#else
-
-GsmSystemd *
-gsm_systemd_new (void)
-{
-        return NULL;
-}
-
-#endif
-
diff --git a/gnome-session/gsm-systemd.h b/gnome-session/gsm-systemd.h
deleted file mode 100644
index a6a3827..0000000
--- a/gnome-session/gsm-systemd.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2012 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- *
- * Authors:
- *	Matthias Clasen <mclasen@redhat.com>
- */
-
-#ifndef __GSM_SYSTEMD_H__
-#define __GSM_SYSTEMD_H__
-
-#include <glib.h>
-#include <glib-object.h>
-
-G_BEGIN_DECLS
-
-#define GSM_TYPE_SYSTEMD             (gsm_systemd_get_type ())
-#define GSM_SYSTEMD(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSM_TYPE_SYSTEMD, GsmSystemd))
-#define GSM_SYSTEMD_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSM_TYPE_SYSTEMD, GsmSystemdClass))
-#define GSM_IS_SYSTEMD(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSM_TYPE_SYSTEMD))
-#define GSM_IS_SYSTEMD_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSM_TYPE_SYSTEMD))
-#define GSM_SYSTEMD_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS((obj), GSM_TYPE_SYSTEMD, GsmSystemdClass))
-
-typedef struct _GsmSystemd        GsmSystemd;
-typedef struct _GsmSystemdClass   GsmSystemdClass;
-typedef struct _GsmSystemdPrivate GsmSystemdPrivate;
-
-struct _GsmSystemd
-{
-        GObject            parent;
-
-        GsmSystemdPrivate *priv;
-};
-
-struct _GsmSystemdClass
-{
-        GObjectClass parent_class;
-};
-
-GType         gsm_systemd_get_type (void);
-
-GsmSystemd   *gsm_systemd_new      (void) G_GNUC_MALLOC;
-
-G_END_DECLS
-
-#endif /* __GSM_SYSTEMD_H__ */
diff --git a/gnome-session/gsm-xsmp-client.c b/gnome-session/gsm-xsmp-client.c
deleted file mode 100644
index f52d29f..0000000
--- a/gnome-session/gsm-xsmp-client.c
+++ /dev/null
@@ -1,1352 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2007 Novell, Inc.
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#include "config.h"
-
-#include <fcntl.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <unistd.h>
-#include <errno.h>
-
-#include <gio/gio.h>
-#include <glib/gi18n.h>
-
-#include "gsm-xsmp-client.h"
-
-#include "gsm-util.h"
-#include "gsm-autostart-app.h"
-#include "gsm-icon-names.h"
-#include "gsm-manager.h"
-
-#define GsmDesktopFile "_GSM_DesktopFile"
-
-#define GSM_XSMP_CLIENT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSM_TYPE_XSMP_CLIENT, GsmXSMPClientPrivate))
-
-struct GsmXSMPClientPrivate
-{
-
-        SmsConn    conn;
-        IceConn    ice_connection;
-
-        guint      watch_id;
-
-        char      *description;
-        GPtrArray *props;
-
-        /* SaveYourself state */
-        int        current_save_yourself;
-        int        next_save_yourself;
-        guint      next_save_yourself_allow_interact : 1;
-};
-
-enum {
-        PROP_0,
-        PROP_ICE_CONNECTION
-};
-
-enum {
-        REGISTER_REQUEST,
-        REGISTER_CONFIRMED,
-        LOGOUT_REQUEST,
-        LAST_SIGNAL
-};
-
-static guint signals[LAST_SIGNAL] = { 0 };
-
-G_DEFINE_TYPE (GsmXSMPClient, gsm_xsmp_client, GSM_TYPE_CLIENT)
-
-static gboolean
-client_iochannel_watch (GIOChannel    *channel,
-                        GIOCondition   condition,
-                        GsmXSMPClient *client)
-{
-        gboolean keep_going;
-
-        g_object_ref (client);
-        switch (IceProcessMessages (client->priv->ice_connection, NULL, NULL)) {
-        case IceProcessMessagesSuccess:
-                keep_going = TRUE;
-                break;
-
-        case IceProcessMessagesIOError:
-                g_debug ("GsmXSMPClient: IceProcessMessagesIOError on '%s'", client->priv->description);
-                gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);
-                /* Emitting "disconnected" will eventually cause
-                 * IceCloseConnection() to be called.
-                 */
-                gsm_client_disconnected (GSM_CLIENT (client));
-                keep_going = FALSE;
-                break;
-
-        case IceProcessMessagesConnectionClosed:
-                g_debug ("GsmXSMPClient: IceProcessMessagesConnectionClosed on '%s'",
-                         client->priv->description);
-                client->priv->ice_connection = NULL;
-                keep_going = FALSE;
-                break;
-
-        default:
-                g_assert_not_reached ();
-        }
-        g_object_unref (client);
-
-        return keep_going;
-}
-
-static SmProp *
-find_property (GsmXSMPClient *client,
-               const char    *name,
-               int           *index)
-{
-        SmProp *prop;
-        int i;
-
-        for (i = 0; i < client->priv->props->len; i++) {
-                prop = client->priv->props->pdata[i];
-
-                if (!strcmp (prop->name, name)) {
-                        if (index) {
-                                *index = i;
-                        }
-                        return prop;
-                }
-        }
-
-        return NULL;
-}
-
-static void
-set_description (GsmXSMPClient *client)
-{
-        SmProp     *prop;
-        const char *id;
-
-        prop = find_property (client, SmProgram, NULL);
-        id = gsm_client_peek_startup_id (GSM_CLIENT (client));
-
-        g_free (client->priv->description);
-        if (prop) {
-                client->priv->description = g_strdup_printf ("%p [%.*s %s]",
-                                                             client,
-                                                             prop->vals[0].length,
-                                                             (char *)prop->vals[0].value,
-                                                             id);
-        } else if (id != NULL) {
-                client->priv->description = g_strdup_printf ("%p [%s]", client, id);
-        } else {
-                client->priv->description = g_strdup_printf ("%p", client);
-        }
-}
-
-static void
-setup_connection (GsmXSMPClient *client)
-{
-        GIOChannel    *channel;
-        int            fd;
-
-        g_debug ("GsmXSMPClient: Setting up new connection");
-
-        fd = IceConnectionNumber (client->priv->ice_connection);
-        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);
-        channel = g_io_channel_unix_new (fd);
-        client->priv->watch_id = g_io_add_watch (channel,
-                                                 G_IO_IN | G_IO_ERR,
-                                                 (GIOFunc)client_iochannel_watch,
-                                                 client);
-        g_io_channel_unref (channel);
-
-        set_description (client);
-
-        g_debug ("GsmXSMPClient: New client '%s'", client->priv->description);
-}
-
-static GObject *
-gsm_xsmp_client_constructor (GType                  type,
-                             guint                  n_construct_properties,
-                             GObjectConstructParam *construct_properties)
-{
-        GsmXSMPClient *client;
-
-        client = GSM_XSMP_CLIENT (G_OBJECT_CLASS (gsm_xsmp_client_parent_class)->constructor (type,
-                                                                                              n_construct_properties,
-                                                                                              construct_properties));
-        setup_connection (client);
-
-        return G_OBJECT (client);
-}
-
-static void
-gsm_xsmp_client_init (GsmXSMPClient *client)
-{
-        client->priv = GSM_XSMP_CLIENT_GET_PRIVATE (client);
-
-        client->priv->props = g_ptr_array_new ();
-        client->priv->current_save_yourself = -1;
-        client->priv->next_save_yourself = -1;
-        client->priv->next_save_yourself_allow_interact = FALSE;
-}
-
-
-static void
-delete_property (GsmXSMPClient *client,
-                 const char    *name)
-{
-        int     index;
-        SmProp *prop;
-
-        prop = find_property (client, name, &index);
-        if (!prop) {
-                return;
-        }
-
-#if 0
-        /* This is wrong anyway; we can't unconditionally run the current
-         * discard command; if this client corresponds to a GsmAppResumed,
-         * and the current discard command is identical to the app's
-         * discard_command, then we don't run the discard command now,
-         * because that would delete a saved state we may want to resume
-         * again later.
-         */
-        if (!strcmp (name, SmDiscardCommand)) {
-                gsm_client_run_discard (GSM_CLIENT (client));
-        }
-#endif
-
-        g_ptr_array_remove_index_fast (client->priv->props, index);
-        SmFreeProperty (prop);
-}
-
-
-static void
-debug_print_property (SmProp *prop)
-{
-        GString *tmp;
-        int      i;
-
-        switch (prop->type[0]) {
-        case 'C': /* CARD8 */
-                g_debug ("GsmXSMPClient:   %s = %d", prop->name, *(unsigned char *)prop->vals[0].value);
-                break;
-
-        case 'A': /* ARRAY8 */
-                g_debug ("GsmXSMPClient:   %s = '%s'", prop->name, (char *)prop->vals[0].value);
-                break;
-
-        case 'L': /* LISTofARRAY8 */
-                tmp = g_string_new (NULL);
-                for (i = 0; i < prop->num_vals; i++) {
-                        g_string_append_printf (tmp, "'%.*s' ", prop->vals[i].length,
-                                                (char *)prop->vals[i].value);
-                }
-                g_debug ("GsmXSMPClient:   %s = %s", prop->name, tmp->str);
-                g_string_free (tmp, TRUE);
-                break;
-
-        default:
-                g_debug ("GsmXSMPClient:   %s = ??? (%s)", prop->name, prop->type);
-                break;
-        }
-}
-
-
-static void
-set_properties_callback (SmsConn     conn,
-                         SmPointer   manager_data,
-                         int         num_props,
-                         SmProp    **props)
-{
-        GsmXSMPClient *client = manager_data;
-        int            i;
-
-        g_debug ("GsmXSMPClient: Set properties from client '%s'", client->priv->description);
-
-        for (i = 0; i < num_props; i++) {
-                delete_property (client, props[i]->name);
-                g_ptr_array_add (client->priv->props, props[i]);
-
-                debug_print_property (props[i]);
-
-                if (!strcmp (props[i]->name, SmProgram))
-                        set_description (client);
-        }
-
-        free (props);
-
-}
-
-static void
-delete_properties_callback (SmsConn     conn,
-                            SmPointer   manager_data,
-                            int         num_props,
-                            char      **prop_names)
-{
-        GsmXSMPClient *client = manager_data;
-        int i;
-
-        g_debug ("GsmXSMPClient: Delete properties from '%s'", client->priv->description);
-
-        for (i = 0; i < num_props; i++) {
-                delete_property (client, prop_names[i]);
-
-                g_debug ("  %s", prop_names[i]);
-        }
-
-        free (prop_names);
-}
-
-static void
-get_properties_callback (SmsConn   conn,
-                         SmPointer manager_data)
-{
-        GsmXSMPClient *client = manager_data;
-
-        g_debug ("GsmXSMPClient: Get properties request from '%s'", client->priv->description);
-
-        SmsReturnProperties (conn,
-                             client->priv->props->len,
-                             (SmProp **)client->priv->props->pdata);
-}
-
-static char *
-prop_to_command (SmProp *prop)
-{
-        GString *str;
-        int i, j;
-        gboolean need_quotes;
-
-        str = g_string_new (NULL);
-        for (i = 0; i < prop->num_vals; i++) {
-                char *val = prop->vals[i].value;
-
-                need_quotes = FALSE;
-                for (j = 0; j < prop->vals[i].length; j++) {
-                        if (!g_ascii_isalnum (val[j]) && !strchr ("-_=:./", val[j])) {
-                                need_quotes = TRUE;
-                                break;
-                        }
-                }
-
-                if (i > 0) {
-                        g_string_append_c (str, ' ');
-                }
-
-                if (!need_quotes) {
-                        g_string_append_printf (str,
-                                                "%.*s",
-                                                prop->vals[i].length,
-                                                (char *)prop->vals[i].value);
-                } else {
-                        g_string_append_c (str, '\'');
-                        while (val < (char *)prop->vals[i].value + prop->vals[i].length) {
-                                if (*val == '\'') {
-                                        g_string_append (str, "'\''");
-                                } else {
-                                        g_string_append_c (str, *val);
-                                }
-                                val++;
-                        }
-                        g_string_append_c (str, '\'');
-                }
-        }
-
-        return g_string_free (str, FALSE);
-}
-
-static char *
-xsmp_get_restart_command (GsmClient *client)
-{
-        SmProp *prop;
-
-        prop = find_property (GSM_XSMP_CLIENT (client), SmRestartCommand, NULL);
-
-        if (!prop || strcmp (prop->type, SmLISTofARRAY8) != 0) {
-                return NULL;
-        }
-
-        return prop_to_command (prop);
-}
-
-static char *
-xsmp_get_discard_command (GsmClient *client)
-{
-        SmProp *prop;
-
-        prop = find_property (GSM_XSMP_CLIENT (client), SmDiscardCommand, NULL);
-
-        if (!prop || strcmp (prop->type, SmLISTofARRAY8) != 0) {
-                return NULL;
-        }
-
-        return prop_to_command (prop);
-}
-
-static void
-do_save_yourself (GsmXSMPClient *client,
-                  int            save_type,
-                  gboolean       allow_interact)
-{
-        g_assert (client->priv->conn != NULL);
-
-        if (client->priv->next_save_yourself != -1) {
-                /* Either we're currently doing a shutdown and there's a checkpoint
-                 * queued after it, or vice versa. Either way, the new SaveYourself
-                 * is redundant.
-                 */
-                g_debug ("GsmXSMPClient:   skipping redundant SaveYourself for '%s'",
-                         client->priv->description);
-        } else if (client->priv->current_save_yourself != -1) {
-                g_debug ("GsmXSMPClient:   queuing new SaveYourself for '%s'",
-                         client->priv->description);
-                client->priv->next_save_yourself = save_type;
-                client->priv->next_save_yourself_allow_interact = allow_interact;
-        } else {
-                client->priv->current_save_yourself = save_type;
-                /* make sure we don't have anything queued */
-                client->priv->next_save_yourself = -1;
-                client->priv->next_save_yourself_allow_interact = FALSE;
-
-                switch (save_type) {
-                case SmSaveLocal:
-                        /* Save state */
-                        SmsSaveYourself (client->priv->conn,
-                                         SmSaveLocal,
-                                         FALSE,
-                                         SmInteractStyleNone,
-                                         FALSE);
-                        break;
-
-                default:
-                        /* Logout */
-                        if (!allow_interact) {
-                                SmsSaveYourself (client->priv->conn,
-                                                 save_type, /* save type */
-                                                 TRUE, /* shutdown */
-                                                 SmInteractStyleNone, /* interact style */
-                                                 TRUE); /* fast */
-                        } else {
-                                SmsSaveYourself (client->priv->conn,
-                                                 save_type, /* save type */
-                                                 TRUE, /* shutdown */
-                                                 SmInteractStyleAny, /* interact style */
-                                                 FALSE /* fast */);
-                        }
-                        break;
-                }
-        }
-}
-
-static void
-xsmp_save_yourself_phase2 (GsmClient *client)
-{
-        GsmXSMPClient *xsmp = (GsmXSMPClient *) client;
-
-        g_debug ("GsmXSMPClient: xsmp_save_yourself_phase2 ('%s')", xsmp->priv->description);
-
-        SmsSaveYourselfPhase2 (xsmp->priv->conn);
-}
-
-static void
-xsmp_interact (GsmClient *client)
-{
-        GsmXSMPClient *xsmp = (GsmXSMPClient *) client;
-
-        g_debug ("GsmXSMPClient: xsmp_interact ('%s')", xsmp->priv->description);
-
-        SmsInteract (xsmp->priv->conn);
-}
-
-static gboolean
-xsmp_cancel_end_session (GsmClient *client,
-                         GError   **error)
-{
-        GsmXSMPClient *xsmp = (GsmXSMPClient *) client;
-
-        g_debug ("GsmXSMPClient: xsmp_cancel_end_session ('%s')", xsmp->priv->description);
-
-        if (xsmp->priv->conn == NULL) {
-                g_set_error (error,
-                             GSM_CLIENT_ERROR,
-                             GSM_CLIENT_ERROR_NOT_REGISTERED,
-                             "Client is not registered");
-                return FALSE;
-        }
-
-        SmsShutdownCancelled (xsmp->priv->conn);
-
-        /* reset the state */
-        xsmp->priv->current_save_yourself = -1;
-        xsmp->priv->next_save_yourself = -1;
-        xsmp->priv->next_save_yourself_allow_interact = FALSE;
-
-        return TRUE;
-}
-
-static char *
-get_desktop_file_path (GsmXSMPClient *client)
-{
-        SmProp     *prop;
-        char       *desktop_file_path = NULL;
-        const char *program_name;
-
-        /* XSMP clients using eggsmclient defines a special property
-         * pointing to their respective desktop entry file */
-        prop = find_property (client, GsmDesktopFile, NULL);
-
-        if (prop) {
-                GFile *file = g_file_new_for_uri (prop->vals[0].value);
-                desktop_file_path = g_file_get_path (file);
-                g_object_unref (file);
-                goto out;
-        }
-
-        /* If we can't get desktop file from GsmDesktopFile then we
-         * try to find the desktop file from its program name */
-        prop = find_property (client, SmProgram, NULL);
-
-        if (!prop) {
-                goto out;
-        }
-
-        program_name = prop->vals[0].value;
-        desktop_file_path =
-                gsm_util_find_desktop_file_for_app_name (program_name,
-                                                         TRUE, FALSE);
-
-out:
-        g_debug ("GsmXSMPClient: desktop file for client %s is %s",
-                 gsm_client_peek_id (GSM_CLIENT (client)),
-                 desktop_file_path ? desktop_file_path : "(null)");
-
-        return desktop_file_path;
-}
-
-static void
-set_desktop_file_keys_from_client (GsmClient *client,
-                                   GKeyFile  *keyfile)
-{
-        SmProp     *prop;
-        const char *name;
-        char       *comment;
-
-        prop = find_property (GSM_XSMP_CLIENT (client), SmProgram, NULL);
-        if (prop) {
-                name = prop->vals[0].value;
-        } else {
-                /* It'd be really surprising to reach this code: if we're here,
-                 * then the XSMP client already has set several XSMP
-                 * properties. But it could still be that SmProgram is not set.
-                 */
-                name = _("Remembered Application");
-        }
-
-        comment = g_strdup_printf ("Client %s which was automatically saved",
-                                   gsm_client_peek_startup_id (client));
-
-        g_key_file_set_string (keyfile,
-                               G_KEY_FILE_DESKTOP_GROUP,
-                               G_KEY_FILE_DESKTOP_KEY_NAME,
-                               name);
-
-        g_key_file_set_string (keyfile,
-                               G_KEY_FILE_DESKTOP_GROUP,
-                               G_KEY_FILE_DESKTOP_KEY_COMMENT,
-                               comment);
-
-        g_key_file_set_string (keyfile,
-                               G_KEY_FILE_DESKTOP_GROUP,
-                               G_KEY_FILE_DESKTOP_KEY_ICON,
-                               GSM_ICON_XSMP_DEFAULT);
-
-        g_key_file_set_string (keyfile,
-                               G_KEY_FILE_DESKTOP_GROUP,
-                               G_KEY_FILE_DESKTOP_KEY_TYPE,
-                               "Application");
-
-        g_key_file_set_boolean (keyfile,
-                                G_KEY_FILE_DESKTOP_GROUP,
-                                G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY,
-                                TRUE);
-
-        g_free (comment);
-}
-
-static GKeyFile *
-create_client_key_file (GsmClient   *client,
-                        const char  *desktop_file_path,
-                        GError     **error) {
-        GKeyFile *keyfile;
-
-        keyfile = g_key_file_new ();
-
-        if (desktop_file_path != NULL) {
-                g_key_file_load_from_file (keyfile,
-                                           desktop_file_path,
-                                           G_KEY_FILE_KEEP_COMMENTS |
-                                           G_KEY_FILE_KEEP_TRANSLATIONS,
-                                           error);
-        } else {
-                set_desktop_file_keys_from_client (client, keyfile);
-        }
-
-        return keyfile;
-}
-
-static GsmClientRestartStyle
-xsmp_get_restart_style_hint (GsmClient *client);
-
-static GKeyFile *
-xsmp_save (GsmClient *client,
-           GError   **error)
-{
-        GsmClientRestartStyle restart_style;
-
-        GKeyFile *keyfile = NULL;
-        char     *desktop_file_path = NULL;
-        char     *exec_program = NULL;
-        char     *exec_discard = NULL;
-        char     *startup_id = NULL;
-        GError   *local_error;
-
-        g_debug ("GsmXSMPClient: saving client with id %s",
-                 gsm_client_peek_id (client));
-
-        local_error = NULL;
-
-        restart_style = xsmp_get_restart_style_hint (client);
-        if (restart_style == GSM_CLIENT_RESTART_NEVER) {
-                goto out;
-        }
-
-        exec_program = xsmp_get_restart_command (client);
-        if (!exec_program) {
-                goto out;
-        }
-
-        desktop_file_path = get_desktop_file_path (GSM_XSMP_CLIENT (client));
-
-        /* this can accept desktop_file_path == NULL */
-        keyfile = create_client_key_file (client,
-                                          desktop_file_path,
-                                          &local_error);
-
-        if (local_error) {
-                goto out;
-        }
-
-        g_object_get (client,
-                      "startup-id", &startup_id,
-                      NULL);
-
-        g_key_file_set_string (keyfile,
-                               G_KEY_FILE_DESKTOP_GROUP,
-                               GSM_AUTOSTART_APP_STARTUP_ID_KEY,
-                               startup_id);
-
-        g_key_file_set_string (keyfile,
-                               G_KEY_FILE_DESKTOP_GROUP,
-                               G_KEY_FILE_DESKTOP_KEY_EXEC,
-                               exec_program);
-
-        exec_discard = xsmp_get_discard_command (client);
-        if (exec_discard)
-                g_key_file_set_string (keyfile,
-                                       G_KEY_FILE_DESKTOP_GROUP,
-                                       GSM_AUTOSTART_APP_DISCARD_KEY,
-                                       exec_discard);
-
-out:
-        g_free (desktop_file_path);
-        g_free (exec_program);
-        g_free (exec_discard);
-        g_free (startup_id);
-
-        if (local_error != NULL) {
-                g_propagate_error (error, local_error);
-                g_key_file_free (keyfile);
-
-                return NULL;
-        }
-
-        return keyfile;
-}
-
-static gboolean
-xsmp_stop (GsmClient *client,
-           GError   **error)
-{
-        GsmXSMPClient *xsmp = (GsmXSMPClient *) client;
-
-        g_debug ("GsmXSMPClient: xsmp_stop ('%s')", xsmp->priv->description);
-
-        if (xsmp->priv->conn == NULL) {
-                g_set_error (error,
-                             GSM_CLIENT_ERROR,
-                             GSM_CLIENT_ERROR_NOT_REGISTERED,
-                             "Client is not registered");
-                return FALSE;
-        }
-
-        SmsDie (xsmp->priv->conn);
-
-        return TRUE;
-}
-
-static gboolean
-xsmp_query_end_session (GsmClient                *client,
-                        GsmClientEndSessionFlag   flags,
-                        GError                  **error)
-{
-        gboolean allow_interact;
-        int      save_type;
-
-        if (GSM_XSMP_CLIENT (client)->priv->conn == NULL) {
-                g_set_error (error,
-                             GSM_CLIENT_ERROR,
-                             GSM_CLIENT_ERROR_NOT_REGISTERED,
-                             "Client is not registered");
-                return FALSE;
-        }
-
-        allow_interact = !(flags & GSM_CLIENT_END_SESSION_FLAG_FORCEFUL);
-
-        /* we don't want to save the session state, but we just want to know if
-         * there's user data the client has to save and we want to give the
-         * client a chance to tell the user about it. This is consistent with
-         * the manager not setting GSM_CLIENT_END_SESSION_FLAG_SAVE for this
-         * phase. */
-        save_type = SmSaveGlobal;
-
-        do_save_yourself (GSM_XSMP_CLIENT (client), save_type, allow_interact);
-        return TRUE;
-}
-
-static gboolean
-xsmp_end_session (GsmClient                *client,
-                  GsmClientEndSessionFlag   flags,
-                  GError                  **error)
-{
-        gboolean phase2;
-
-        if (GSM_XSMP_CLIENT (client)->priv->conn == NULL) {
-                g_set_error (error,
-                             GSM_CLIENT_ERROR,
-                             GSM_CLIENT_ERROR_NOT_REGISTERED,
-                             "Client is not registered");
-                return FALSE;
-        }
-
-        phase2 = (flags & GSM_CLIENT_END_SESSION_FLAG_LAST);
-
-        if (phase2) {
-                xsmp_save_yourself_phase2 (client);
-        } else {
-                gboolean allow_interact;
-                int      save_type;
-
-                /* we gave a chance to interact to the app during
-                 * xsmp_query_end_session(), now it's too late to interact */
-                allow_interact = FALSE;
-
-                if (flags & GSM_CLIENT_END_SESSION_FLAG_SAVE) {
-                        save_type = SmSaveBoth;
-                } else {
-                        save_type = SmSaveGlobal;
-                }
-
-                do_save_yourself (GSM_XSMP_CLIENT (client),
-                                  save_type, allow_interact);
-        }
-
-        return TRUE;
-}
-
-static char *
-xsmp_get_app_name (GsmClient *client)
-{
-        SmProp *prop;
-        char   *name = NULL;
-
-        prop = find_property (GSM_XSMP_CLIENT (client), SmProgram, NULL);
-        if (prop) {
-                name = prop_to_command (prop);
-        }
-
-        return name;
-}
-
-static void
-gsm_client_set_ice_connection (GsmXSMPClient *client,
-                               gpointer       conn)
-{
-        client->priv->ice_connection = conn;
-}
-
-static void
-gsm_xsmp_client_set_property (GObject       *object,
-                              guint          prop_id,
-                              const GValue  *value,
-                              GParamSpec    *pspec)
-{
-        GsmXSMPClient *self;
-
-        self = GSM_XSMP_CLIENT (object);
-
-        switch (prop_id) {
-        case PROP_ICE_CONNECTION:
-                gsm_client_set_ice_connection (self, g_value_get_pointer (value));
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_xsmp_client_get_property (GObject    *object,
-                              guint       prop_id,
-                              GValue     *value,
-                              GParamSpec *pspec)
-{
-        GsmXSMPClient *self;
-
-        self = GSM_XSMP_CLIENT (object);
-
-        switch (prop_id) {
-        case PROP_ICE_CONNECTION:
-                g_value_set_pointer (value, self->priv->ice_connection);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_xsmp_client_disconnect (GsmXSMPClient *client)
-{
-        if (client->priv->watch_id > 0) {
-                g_source_remove (client->priv->watch_id);
-        }
-
-        if (client->priv->conn != NULL) {
-                SmsCleanUp (client->priv->conn);
-        }
-
-        if (client->priv->ice_connection != NULL) {
-                IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);
-                IceCloseConnection (client->priv->ice_connection);
-        }
-}
-
-static void
-gsm_xsmp_client_finalize (GObject *object)
-{
-        GsmXSMPClient *client = (GsmXSMPClient *) object;
-
-        g_debug ("GsmXSMPClient: xsmp_finalize (%s)", client->priv->description);
-        gsm_xsmp_client_disconnect (client);
-
-        g_free (client->priv->description);
-        g_ptr_array_foreach (client->priv->props, (GFunc)SmFreeProperty, NULL);
-        g_ptr_array_free (client->priv->props, TRUE);
-
-        G_OBJECT_CLASS (gsm_xsmp_client_parent_class)->finalize (object);
-}
-
-static gboolean
-_boolean_handled_accumulator (GSignalInvocationHint *ihint,
-                              GValue                *return_accu,
-                              const GValue          *handler_return,
-                              gpointer               dummy)
-{
-        gboolean    continue_emission;
-        gboolean    signal_handled;
-
-        signal_handled = g_value_get_boolean (handler_return);
-        g_value_set_boolean (return_accu, signal_handled);
-        continue_emission = !signal_handled;
-
-        return continue_emission;
-}
-
-static GsmClientRestartStyle
-xsmp_get_restart_style_hint (GsmClient *client)
-{
-        SmProp               *prop;
-        GsmClientRestartStyle hint;
-
-        g_debug ("GsmXSMPClient: getting restart style");
-        hint = GSM_CLIENT_RESTART_IF_RUNNING;
-
-        prop = find_property (GSM_XSMP_CLIENT (client), SmRestartStyleHint, NULL);
-
-        if (!prop || strcmp (prop->type, SmCARD8) != 0) {
-                return GSM_CLIENT_RESTART_IF_RUNNING;
-        }
-
-        switch (((unsigned char *)prop->vals[0].value)[0]) {
-        case SmRestartIfRunning:
-                hint = GSM_CLIENT_RESTART_IF_RUNNING;
-                break;
-        case SmRestartAnyway:
-                hint = GSM_CLIENT_RESTART_ANYWAY;
-                break;
-        case SmRestartImmediately:
-                hint = GSM_CLIENT_RESTART_IMMEDIATELY;
-                break;
-        case SmRestartNever:
-                hint = GSM_CLIENT_RESTART_NEVER;
-                break;
-        default:
-                break;
-        }
-
-        return hint;
-}
-
-static gboolean
-_parse_value_as_uint (const char *value,
-                      guint      *uintval)
-{
-        char  *end_of_valid_uint;
-        gulong ulong_value;
-        guint  uint_value;
-
-        errno = 0;
-        ulong_value = strtoul (value, &end_of_valid_uint, 10);
-
-        if (*value == '\0' || *end_of_valid_uint != '\0') {
-                return FALSE;
-        }
-
-        uint_value = ulong_value;
-        if (uint_value != ulong_value || errno == ERANGE) {
-                return FALSE;
-        }
-
-        *uintval = uint_value;
-
-        return TRUE;
-}
-
-static guint
-xsmp_get_unix_process_id (GsmClient *client)
-{
-        SmProp  *prop;
-        guint    pid;
-        gboolean res;
-
-        g_debug ("GsmXSMPClient: getting pid");
-
-        prop = find_property (GSM_XSMP_CLIENT (client), SmProcessID, NULL);
-
-        if (!prop || strcmp (prop->type, SmARRAY8) != 0) {
-                return 0;
-        }
-
-        pid = 0;
-        res = _parse_value_as_uint ((char *)prop->vals[0].value, &pid);
-        if (! res) {
-                pid = 0;
-        }
-
-        return pid;
-}
-
-static void
-gsm_xsmp_client_class_init (GsmXSMPClientClass *klass)
-{
-        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
-        GsmClientClass *client_class = GSM_CLIENT_CLASS (klass);
-
-        object_class->finalize             = gsm_xsmp_client_finalize;
-        object_class->constructor          = gsm_xsmp_client_constructor;
-        object_class->get_property         = gsm_xsmp_client_get_property;
-        object_class->set_property         = gsm_xsmp_client_set_property;
-
-        client_class->impl_save                   = xsmp_save;
-        client_class->impl_stop                   = xsmp_stop;
-        client_class->impl_query_end_session      = xsmp_query_end_session;
-        client_class->impl_end_session            = xsmp_end_session;
-        client_class->impl_cancel_end_session     = xsmp_cancel_end_session;
-        client_class->impl_get_app_name           = xsmp_get_app_name;
-        client_class->impl_get_restart_style_hint = xsmp_get_restart_style_hint;
-        client_class->impl_get_unix_process_id    = xsmp_get_unix_process_id;
-
-        signals[REGISTER_REQUEST] =
-                g_signal_new ("register-request",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmXSMPClientClass, register_request),
-                              _boolean_handled_accumulator,
-                              NULL,
-                              NULL,
-                              G_TYPE_BOOLEAN,
-                              1, G_TYPE_POINTER);
-        signals[REGISTER_CONFIRMED] =
-                g_signal_new ("register-confirmed",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmXSMPClientClass, register_confirmed),
-                              NULL,
-                              NULL,
-                              NULL,
-                              G_TYPE_NONE,
-                              1, G_TYPE_POINTER);
-        signals[LOGOUT_REQUEST] =
-                g_signal_new ("logout-request",
-                              G_OBJECT_CLASS_TYPE (object_class),
-                              G_SIGNAL_RUN_LAST,
-                              G_STRUCT_OFFSET (GsmXSMPClientClass, logout_request),
-                              NULL,
-                              NULL,
-                              NULL,
-                              G_TYPE_NONE,
-                              1, G_TYPE_BOOLEAN);
-
-        g_object_class_install_property (object_class,
-                                         PROP_ICE_CONNECTION,
-                                         g_param_spec_pointer ("ice-connection",
-                                                               "ice-connection",
-                                                               "ice-connection",
-                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
-
-        g_type_class_add_private (klass, sizeof (GsmXSMPClientPrivate));
-}
-
-GsmClient *
-gsm_xsmp_client_new (IceConn ice_conn)
-{
-        GsmXSMPClient *xsmp;
-
-        xsmp = g_object_new (GSM_TYPE_XSMP_CLIENT,
-                             "ice-connection", ice_conn,
-                             NULL);
-
-        return GSM_CLIENT (xsmp);
-}
-
-static Status
-register_client_callback (SmsConn    conn,
-                          SmPointer  manager_data,
-                          char      *previous_id)
-{
-        GsmXSMPClient *client = manager_data;
-        gboolean       handled;
-        char          *id;
-
-        g_debug ("GsmXSMPClient: Client '%s' received RegisterClient(%s)",
-                 client->priv->description,
-                 previous_id ? previous_id : "NULL");
-
-
-        /* There are three cases:
-         * 1. id is NULL - we'll use a new one
-         * 2. id is known - we'll use known one
-         * 3. id is unknown - this is an error
-         */
-        id = g_strdup (previous_id);
-
-        handled = FALSE;
-        g_signal_emit (client, signals[REGISTER_REQUEST], 0, &id, &handled);
-        if (! handled) {
-                g_debug ("GsmXSMPClient:  RegisterClient not handled!");
-                g_free (id);
-                free (previous_id);
-                g_assert_not_reached ();
-                return FALSE;
-        }
-
-        if (IS_STRING_EMPTY (id)) {
-                g_debug ("GsmXSMPClient:   rejected: invalid previous_id");
-                free (previous_id);
-                return FALSE;
-        }
-
-        g_object_set (client, "startup-id", id, NULL);
-
-        set_description (client);
-
-        g_debug ("GsmXSMPClient: Sending RegisterClientReply to '%s'", client->priv->description);
-
-        SmsRegisterClientReply (conn, id);
-
-        if (IS_STRING_EMPTY (previous_id)) {
-                /* Send the initial SaveYourself. */
-                g_debug ("GsmXSMPClient: Sending initial SaveYourself");
-                SmsSaveYourself (conn, SmSaveLocal, False, SmInteractStyleNone, False);
-                client->priv->current_save_yourself = SmSaveLocal;
-        }
-
-        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_REGISTERED);
-
-        g_signal_emit (client, signals[REGISTER_CONFIRMED], 0, id);
-
-        g_free (id);
-        free (previous_id);
-
-        return TRUE;
-}
-
-
-static void
-save_yourself_request_callback (SmsConn   conn,
-                                SmPointer manager_data,
-                                int       save_type,
-                                Bool      shutdown,
-                                int       interact_style,
-                                Bool      fast,
-                                Bool      global)
-{
-        GsmXSMPClient *client = manager_data;
-
-        g_debug ("GsmXSMPClient: Client '%s' received SaveYourselfRequest(%s, %s, %s, %s, %s)",
-                 client->priv->description,
-                 save_type == SmSaveLocal ? "SmSaveLocal" :
-                 save_type == SmSaveGlobal ? "SmSaveGlobal" : "SmSaveBoth",
-                 shutdown ? "Shutdown" : "!Shutdown",
-                 interact_style == SmInteractStyleAny ? "SmInteractStyleAny" :
-                 interact_style == SmInteractStyleErrors ? "SmInteractStyleErrors" :
-                 "SmInteractStyleNone", fast ? "Fast" : "!Fast",
-                 global ? "Global" : "!Global");
-
-        /* Examining the g_debug above, you can see that there are a total
-         * of 72 different combinations of options that this could have been
-         * called with. However, most of them are stupid.
-         *
-         * If @shutdown and @global are both TRUE, that means the caller is
-         * requesting that a logout message be sent to all clients, so we do
-         * that. We use @fast to decide whether or not to show a
-         * confirmation dialog. (This isn't really what @fast is for, but
-         * the old gnome-session and ksmserver both interpret it that way,
-         * so we do too.) We ignore @save_type because we pick the correct
-         * save_type ourselves later based on user prefs, dialog choices,
-         * etc, and we ignore @interact_style, because clients have not used
-         * it correctly consistently enough to make it worth honoring.
-         *
-         * If @shutdown is TRUE and @global is FALSE, the caller is
-         * confused, so we ignore the request.
-         *
-         * If @shutdown is FALSE and @save_type is SmSaveGlobal or
-         * SmSaveBoth, then the client wants us to ask some or all open
-         * applications to save open files to disk, but NOT quit. This is
-         * silly and so we ignore the request.
-         *
-         * If @shutdown is FALSE and @save_type is SmSaveLocal, then the
-         * client wants us to ask some or all open applications to update
-         * their current saved state, but not log out. At the moment, the
-         * code only supports this for the !global case (ie, a client
-         * requesting that it be allowed to update *its own* saved state,
-         * but not having everyone else update their saved state).
-         */
-
-        if (shutdown && global) {
-                g_debug ("GsmXSMPClient:   initiating shutdown");
-                g_signal_emit (client, signals[LOGOUT_REQUEST], 0, !fast);
-        } else if (!shutdown && !global) {
-                g_debug ("GsmXSMPClient:   initiating checkpoint");
-                do_save_yourself (client, SmSaveLocal, TRUE);
-        } else {
-                g_debug ("GsmXSMPClient:   ignoring");
-        }
-}
-
-static void
-save_yourself_phase2_request_callback (SmsConn   conn,
-                                       SmPointer manager_data)
-{
-        GsmXSMPClient *client = manager_data;
-
-        g_debug ("GsmXSMPClient: Client '%s' received SaveYourselfPhase2Request",
-                 client->priv->description);
-
-        client->priv->current_save_yourself = -1;
-
-        /* this is a valid response to SaveYourself and therefore
-           may be a response to a QES or ES */
-        gsm_client_end_session_response (GSM_CLIENT (client),
-                                         TRUE, TRUE, FALSE,
-                                         NULL);
-}
-
-static void
-interact_request_callback (SmsConn   conn,
-                           SmPointer manager_data,
-                           int       dialog_type)
-{
-        GsmXSMPClient *client = manager_data;
-#if 0
-        gboolean       res;
-        GError        *error;
-#endif
-
-        g_debug ("GsmXSMPClient: Client '%s' received InteractRequest(%s)",
-                 client->priv->description,
-                 dialog_type == SmDialogNormal ? "Dialog" : "Errors");
-
-        gsm_client_end_session_response (GSM_CLIENT (client),
-                                         FALSE, FALSE, FALSE,
-                                         _("This program is blocking logout."));
-
-#if 0
-        /* Can't just call back with Interact because session client
-           grabs the keyboard!  So, we try to get it to release
-           grabs by telling it we've cancelled the shutdown.
-           This grabbing is clearly bullshit and is not supported by
-           the client spec or protocol spec.
-        */
-        res = xsmp_cancel_end_session (GSM_CLIENT (client), &error);
-        if (! res) {
-                g_warning ("Unable to cancel end session: %s", error->message);
-                g_error_free (error);
-        }
-#endif
-        xsmp_interact (GSM_CLIENT (client));
-}
-
-static void
-interact_done_callback (SmsConn   conn,
-                        SmPointer manager_data,
-                        Bool      cancel_shutdown)
-{
-        GsmXSMPClient *client = manager_data;
-
-        g_debug ("GsmXSMPClient: Client '%s' received InteractDone(cancel_shutdown = %s)",
-                 client->priv->description,
-                 cancel_shutdown ? "True" : "False");
-
-        gsm_client_end_session_response (GSM_CLIENT (client),
-                                         TRUE, FALSE, cancel_shutdown,
-                                         NULL);
-}
-
-static void
-save_yourself_done_callback (SmsConn   conn,
-                             SmPointer manager_data,
-                             Bool      success)
-{
-        GsmXSMPClient *client = manager_data;
-
-        g_debug ("GsmXSMPClient: Client '%s' received SaveYourselfDone(success = %s)",
-                 client->priv->description,
-                 success ? "True" : "False");
-
-	if (client->priv->current_save_yourself != -1) {
-		SmsSaveComplete (client->priv->conn);
-		client->priv->current_save_yourself = -1;
-	}
-
-        /* If success is false then the application couldn't save data. Nothing
-         * the session manager can do about, though. FIXME: we could display a
-         * dialog about this, I guess. */
-        gsm_client_end_session_response (GSM_CLIENT (client),
-                                         TRUE, FALSE, FALSE,
-                                         NULL);
-
-        if (client->priv->next_save_yourself) {
-                int      save_type = client->priv->next_save_yourself;
-                gboolean allow_interact = client->priv->next_save_yourself_allow_interact;
-
-                client->priv->next_save_yourself = -1;
-                client->priv->next_save_yourself_allow_interact = -1;
-                do_save_yourself (client, save_type, allow_interact);
-        }
-}
-
-static void
-close_connection_callback (SmsConn     conn,
-                           SmPointer   manager_data,
-                           int         count,
-                           char      **reason_msgs)
-{
-        GsmXSMPClient *client = manager_data;
-        int            i;
-
-        g_debug ("GsmXSMPClient: Client '%s' received CloseConnection", client->priv->description);
-        for (i = 0; i < count; i++) {
-                g_debug ("GsmXSMPClient:  close reason: '%s'", reason_msgs[i]);
-        }
-        SmFreeReasons (count, reason_msgs);
-
-        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FINISHED);
-        gsm_client_disconnected (GSM_CLIENT (client));
-}
-
-void
-gsm_xsmp_client_connect (GsmXSMPClient *client,
-                         SmsConn        conn,
-                         unsigned long *mask_ret,
-                         SmsCallbacks  *callbacks_ret)
-{
-        client->priv->conn = conn;
-
-        g_debug ("GsmXSMPClient: Initializing client %s", client->priv->description);
-
-        *mask_ret = 0;
-
-        *mask_ret |= SmsRegisterClientProcMask;
-        callbacks_ret->register_client.callback = register_client_callback;
-        callbacks_ret->register_client.manager_data  = client;
-
-        *mask_ret |= SmsInteractRequestProcMask;
-        callbacks_ret->interact_request.callback = interact_request_callback;
-        callbacks_ret->interact_request.manager_data = client;
-
-        *mask_ret |= SmsInteractDoneProcMask;
-        callbacks_ret->interact_done.callback = interact_done_callback;
-        callbacks_ret->interact_done.manager_data = client;
-
-        *mask_ret |= SmsSaveYourselfRequestProcMask;
-        callbacks_ret->save_yourself_request.callback = save_yourself_request_callback;
-        callbacks_ret->save_yourself_request.manager_data = client;
-
-        *mask_ret |= SmsSaveYourselfP2RequestProcMask;
-        callbacks_ret->save_yourself_phase2_request.callback = save_yourself_phase2_request_callback;
-        callbacks_ret->save_yourself_phase2_request.manager_data = client;
-
-        *mask_ret |= SmsSaveYourselfDoneProcMask;
-        callbacks_ret->save_yourself_done.callback = save_yourself_done_callback;
-        callbacks_ret->save_yourself_done.manager_data = client;
-
-        *mask_ret |= SmsCloseConnectionProcMask;
-        callbacks_ret->close_connection.callback = close_connection_callback;
-        callbacks_ret->close_connection.manager_data  = client;
-
-        *mask_ret |= SmsSetPropertiesProcMask;
-        callbacks_ret->set_properties.callback = set_properties_callback;
-        callbacks_ret->set_properties.manager_data = client;
-
-        *mask_ret |= SmsDeletePropertiesProcMask;
-        callbacks_ret->delete_properties.callback = delete_properties_callback;
-        callbacks_ret->delete_properties.manager_data = client;
-
-        *mask_ret |= SmsGetPropertiesProcMask;
-        callbacks_ret->get_properties.callback = get_properties_callback;
-        callbacks_ret->get_properties.manager_data = client;
-}
-
-void
-gsm_xsmp_client_save_state (GsmXSMPClient *client)
-{
-        g_return_if_fail (GSM_IS_XSMP_CLIENT (client));
-}
diff --git a/gnome-session/gsm-xsmp-client.h b/gnome-session/gsm-xsmp-client.h
deleted file mode 100644
index f98967d..0000000
--- a/gnome-session/gsm-xsmp-client.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2007 Novell, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#ifndef __GSM_XSMP_CLIENT_H__
-#define __GSM_XSMP_CLIENT_H__
-
-#include "gsm-client.h"
-
-#include <X11/SM/SMlib.h>
-
-G_BEGIN_DECLS
-
-#define GSM_TYPE_XSMP_CLIENT            (gsm_xsmp_client_get_type ())
-#define GSM_XSMP_CLIENT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSM_TYPE_XSMP_CLIENT, GsmXSMPClient))
-#define GSM_XSMP_CLIENT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GSM_TYPE_XSMP_CLIENT, GsmXSMPClientClass))
-#define GSM_IS_XSMP_CLIENT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSM_TYPE_XSMP_CLIENT))
-#define GSM_IS_XSMP_CLIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GSM_TYPE_XSMP_CLIENT))
-#define GSM_XSMP_CLIENT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GSM_TYPE_XSMP_CLIENT, GsmXSMPClientClass))
-
-typedef struct _GsmXSMPClient        GsmXSMPClient;
-typedef struct _GsmXSMPClientClass   GsmXSMPClientClass;
-
-typedef struct GsmXSMPClientPrivate  GsmXSMPClientPrivate;
-
-struct _GsmXSMPClient
-{
-        GsmClient             parent;
-        GsmXSMPClientPrivate *priv;
-};
-
-struct _GsmXSMPClientClass
-{
-        GsmClientClass parent_class;
-
-        /* signals */
-        gboolean (*register_request)     (GsmXSMPClient  *client,
-                                          char          **client_id);
-        void     (*register_confirmed)   (GsmXSMPClient  *client,
-                                          const char     *client_id);
-        gboolean (*logout_request)       (GsmXSMPClient  *client,
-                                          gboolean        prompt);
-
-
-        void     (*saved_state)          (GsmXSMPClient  *client);
-
-        void     (*request_phase2)       (GsmXSMPClient  *client);
-
-        void     (*request_interaction)  (GsmXSMPClient  *client);
-        void     (*interaction_done)     (GsmXSMPClient  *client,
-                                          gboolean        cancel_shutdown);
-
-        void     (*save_yourself_done)   (GsmXSMPClient  *client);
-
-};
-
-GType       gsm_xsmp_client_get_type             (void) G_GNUC_CONST;
-
-GsmClient  *gsm_xsmp_client_new                  (IceConn         ice_conn);
-
-void        gsm_xsmp_client_connect              (GsmXSMPClient  *client,
-                                                  SmsConn         conn,
-                                                  unsigned long  *mask_ret,
-                                                  SmsCallbacks   *callbacks_ret);
-
-void        gsm_xsmp_client_save_state           (GsmXSMPClient  *client);
-void        gsm_xsmp_client_save_yourself        (GsmXSMPClient  *client,
-                                                  gboolean        save_state);
-void        gsm_xsmp_client_save_yourself_phase2 (GsmXSMPClient  *client);
-void        gsm_xsmp_client_interact             (GsmXSMPClient  *client);
-void        gsm_xsmp_client_shutdown_cancelled   (GsmXSMPClient  *client);
-
-G_END_DECLS
-
-#endif /* __GSM_XSMP_CLIENT_H__ */
diff --git a/gnome-session/gsm-xsmp-server.c b/gnome-session/gsm-xsmp-server.c
deleted file mode 100644
index e7758f8..0000000
--- a/gnome-session/gsm-xsmp-server.c
+++ /dev/null
@@ -1,755 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2007 Novell, Inc.
- * Copyright (C) 2008 Red Hat, Inc.
- * Copyright (C) 2008 William Jon McCann <jmccann@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- */
-
-#include "config.h"
-
-#include <errno.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <string.h>
-
-#include <glib.h>
-#include <glib/gi18n.h>
-#include <glib-object.h>
-
-#include <X11/ICE/ICElib.h>
-#include <X11/ICE/ICEutil.h>
-#include <X11/ICE/ICEconn.h>
-#include <X11/SM/SMlib.h>
-
-#ifdef HAVE_X11_XTRANS_XTRANS_H
-/* Get the proto for _IceTransNoListen */
-#define ICE_t
-#define TRANS_SERVER
-#include <X11/Xtrans/Xtrans.h>
-#undef  ICE_t
-#undef TRANS_SERVER
-#endif /* HAVE_X11_XTRANS_XTRANS_H */
-
-#include "gsm-xsmp-server.h"
-#include "gsm-xsmp-client.h"
-#include "gsm-util.h"
-
-/* ICEauthority stuff */
-/* Various magic numbers stolen from iceauth.c */
-#define GSM_ICE_AUTH_RETRIES      10
-#define GSM_ICE_AUTH_INTERVAL     2   /* 2 seconds */
-#define GSM_ICE_AUTH_LOCK_TIMEOUT 600 /* 10 minutes */
-
-#define GSM_ICE_MAGIC_COOKIE_AUTH_NAME "MIT-MAGIC-COOKIE-1"
-#define GSM_ICE_MAGIC_COOKIE_LEN       16
-
-#define GSM_XSMP_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSM_TYPE_XSMP_SERVER, GsmXsmpServerPrivate))
-
-struct GsmXsmpServerPrivate
-{
-        GsmStore       *client_store;
-
-        IceListenObj   *xsmp_sockets;
-        int             num_xsmp_sockets;
-        int             num_local_xsmp_sockets;
-        gboolean        stopping;
-};
-
-enum {
-        PROP_0,
-        PROP_CLIENT_STORE
-};
-
-static void     gsm_xsmp_server_class_init  (GsmXsmpServerClass *klass);
-static void     gsm_xsmp_server_init        (GsmXsmpServer      *xsmp_server);
-static void     gsm_xsmp_server_finalize    (GObject         *object);
-
-static gpointer xsmp_server_object = NULL;
-
-G_DEFINE_TYPE (GsmXsmpServer, gsm_xsmp_server, G_TYPE_OBJECT)
-
-typedef struct {
-        GsmXsmpServer *server;
-        IceListenObj   listener;
-} GsmIceConnectionData;
-
-typedef struct {
-        guint watch_id;
-        guint protocol_timeout;
-} GsmIceConnectionWatch;
-
-static void
-disconnect_ice_connection (IceConn ice_conn)
-{
-        IceSetShutdownNegotiation (ice_conn, FALSE);
-        IceCloseConnection (ice_conn);
-}
-
-static void
-free_ice_connection_watch (GsmIceConnectionWatch *data)
-{
-        if (data->watch_id) {
-                g_source_remove (data->watch_id);
-                data->watch_id = 0;
-        }
-
-        if (data->protocol_timeout) {
-                g_source_remove (data->protocol_timeout);
-                data->protocol_timeout = 0;
-        }
-
-        g_free (data);
-}
-
-static gboolean
-ice_protocol_timeout (IceConn ice_conn)
-{
-        GsmIceConnectionWatch *data;
-
-        g_debug ("GsmXsmpServer: ice_protocol_timeout for IceConn %p with status %d",
-                 ice_conn, IceConnectionStatus (ice_conn));
-
-        data = ice_conn->context;
-
-        free_ice_connection_watch (data);
-        disconnect_ice_connection (ice_conn);
-
-        return FALSE;
-}
-
-static gboolean
-auth_iochannel_watch (GIOChannel   *source,
-                      GIOCondition  condition,
-                      IceConn       ice_conn)
-{
-
-        GsmIceConnectionWatch *data;
-        gboolean               keep_going;
-
-        data = ice_conn->context;
-
-        switch (IceProcessMessages (ice_conn, NULL, NULL)) {
-        case IceProcessMessagesSuccess:
-                keep_going = TRUE;
-                break;
-        case IceProcessMessagesIOError:
-                g_debug ("GsmXsmpServer: IceProcessMessages returned IceProcessMessagesIOError");
-                free_ice_connection_watch (data);
-                disconnect_ice_connection (ice_conn);
-                keep_going = FALSE;
-                break;
-        case IceProcessMessagesConnectionClosed:
-                g_debug ("GsmXsmpServer: IceProcessMessages returned IceProcessMessagesConnectionClosed");
-                free_ice_connection_watch (data);
-                keep_going = FALSE;
-                break;
-        default:
-                g_assert_not_reached ();
-        }
-
-        return keep_going;
-}
-
-/* IceAcceptConnection returns a new ICE connection that is in a "pending" state,
- * this is because authentification may be necessary.
- * So we've to authenticate it, before accept_xsmp_connection() is called.
- * Then each GsmXSMPClient will have its own IceConn watcher
- */
-static void
-auth_ice_connection (IceConn ice_conn)
-{
-        GIOChannel            *channel;
-        GsmIceConnectionWatch *data;
-        int                    fd;
-
-        g_debug ("GsmXsmpServer: auth_ice_connection()");
-
-        fd = IceConnectionNumber (ice_conn);
-        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);
-        channel = g_io_channel_unix_new (fd);
-
-        data = g_new0 (GsmIceConnectionWatch, 1);
-        ice_conn->context = data;
-
-        data->protocol_timeout = g_timeout_add_seconds (5,
-                                                        (GSourceFunc)ice_protocol_timeout,
-                                                        ice_conn);
-        data->watch_id = g_io_add_watch (channel,
-                                         G_IO_IN | G_IO_ERR,
-                                         (GIOFunc)auth_iochannel_watch,
-                                         ice_conn);
-        g_io_channel_unref (channel);
-}
-
-/* This is called (by glib via xsmp->ice_connection_watch) when a
- * connection is first received on the ICE listening socket.
- */
-static gboolean
-accept_ice_connection (GIOChannel           *source,
-                       GIOCondition          condition,
-                       GsmIceConnectionData *data)
-{
-        IceConn         ice_conn;
-        IceAcceptStatus status;
-
-        g_debug ("GsmXsmpServer: accept_ice_connection()");
-
-        ice_conn = IceAcceptConnection (data->listener, &status);
-        if (status != IceAcceptSuccess) {
-                g_debug ("GsmXsmpServer: IceAcceptConnection returned %d", status);
-                return TRUE;
-        }
-
-        auth_ice_connection (ice_conn);
-
-        return TRUE;
-}
-
-void
-gsm_xsmp_server_start (GsmXsmpServer *server)
-{
-        GIOChannel *channel;
-        int         i;
-
-        for (i = 0; i < server->priv->num_local_xsmp_sockets; i++) {
-                GsmIceConnectionData *data;
-
-                data = g_new0 (GsmIceConnectionData, 1);
-                data->server = server;
-                data->listener = server->priv->xsmp_sockets[i];
-
-                channel = g_io_channel_unix_new (IceGetListenConnectionNumber (server->priv->xsmp_sockets[i]));
-                g_io_add_watch_full (channel,
-                                     G_PRIORITY_DEFAULT,
-                                     G_IO_IN | G_IO_HUP | G_IO_ERR,
-                                     (GIOFunc)accept_ice_connection,
-                                     data,
-                                     (GDestroyNotify)g_free);
-                g_io_channel_unref (channel);
-        }
-}
-
-void
-gsm_xsmp_server_stop_accepting_new_clients (GsmXsmpServer *server)
-{
-        g_return_if_fail (GSM_IS_XSMP_SERVER (server));
-        g_debug ("gsm_xsmp_server_stop_accepting_new_clients");
-        server->priv->stopping = TRUE;
-}
-
-void
-gsm_xsmp_server_start_accepting_new_clients (GsmXsmpServer *server)
-{
-        g_return_if_fail (GSM_IS_XSMP_SERVER (server));
-        g_debug ("gsm_xsmp_server_start");
-        server->priv->stopping = FALSE;
-}
-
-static void
-gsm_xsmp_server_set_client_store (GsmXsmpServer *xsmp_server,
-                                  GsmStore      *store)
-{
-        g_return_if_fail (GSM_IS_XSMP_SERVER (xsmp_server));
-
-        if (store != NULL) {
-                g_object_ref (store);
-        }
-
-        if (xsmp_server->priv->client_store != NULL) {
-                g_object_unref (xsmp_server->priv->client_store);
-        }
-
-        xsmp_server->priv->client_store = store;
-}
-
-static void
-gsm_xsmp_server_set_property (GObject      *object,
-                              guint         prop_id,
-                              const GValue *value,
-                              GParamSpec   *pspec)
-{
-        GsmXsmpServer *self;
-
-        self = GSM_XSMP_SERVER (object);
-
-        switch (prop_id) {
-        case PROP_CLIENT_STORE:
-                gsm_xsmp_server_set_client_store (self, g_value_get_object (value));
-                break;
-         default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_xsmp_server_get_property (GObject    *object,
-                              guint       prop_id,
-                              GValue     *value,
-                              GParamSpec *pspec)
-{
-        GsmXsmpServer *self;
-
-        self = GSM_XSMP_SERVER (object);
-
-        switch (prop_id) {
-        case PROP_CLIENT_STORE:
-                g_value_set_object (value, self->priv->client_store);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-/* This is called (by libSM) when XSMP is initiated on an ICE
- * connection that was already accepted by accept_ice_connection.
- */
-static Status
-accept_xsmp_connection (SmsConn        sms_conn,
-                        GsmXsmpServer *server,
-                        unsigned long *mask_ret,
-                        SmsCallbacks  *callbacks_ret,
-                        char         **failure_reason_ret)
-{
-        IceConn                ice_conn;
-        GsmClient             *client;
-        GsmIceConnectionWatch *data;
-
-        if (server->priv->stopping) {
-                g_debug ("GsmXsmpServer: In shutdown, rejecting new client");
-
-                *failure_reason_ret = strdup (_("Refusing new client connection because the session is currently being shut down\n"));
-                return FALSE;
-        }
-
-        ice_conn = SmsGetIceConnection (sms_conn);
-        data = ice_conn->context;
-
-        /* Each GsmXSMPClient has its own IceConn watcher */
-        free_ice_connection_watch (data);
-
-        client = gsm_xsmp_client_new (ice_conn);
-
-        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
-        /* the store will own the ref */
-        g_object_unref (client);
-
-        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);
-
-        return TRUE;
-}
-
-static void
-ice_error_handler (IceConn       conn,
-                   Bool          swap,
-                   int           offending_minor_opcode,
-                   unsigned long offending_sequence,
-                   int           error_class,
-                   int           severity,
-                   IcePointer    values)
-{
-        g_debug ("GsmXsmpServer: ice_error_handler (%p, %s, %d, %lx, %d, %d)",
-                 conn, swap ? "TRUE" : "FALSE", offending_minor_opcode,
-                 offending_sequence, error_class, severity);
-
-        if (severity == IceCanContinue) {
-                return;
-        }
-
-        /* FIXME: the ICElib docs are completely vague about what we're
-         * supposed to do in this case. Need to verify that calling
-         * IceCloseConnection() here is guaranteed to cause neither
-         * free-memory-reads nor leaks.
-         */
-        IceCloseConnection (conn);
-}
-
-static void
-ice_io_error_handler (IceConn conn)
-{
-        g_debug ("GsmXsmpServer: ice_io_error_handler (%p)", conn);
-
-        /* We don't need to do anything here; the next call to
-         * IceProcessMessages() for this connection will receive
-         * IceProcessMessagesIOError and we can handle the error there.
-         */
-}
-
-static void
-sms_error_handler (SmsConn       conn,
-                   Bool          swap,
-                   int           offending_minor_opcode,
-                   unsigned long offending_sequence_num,
-                   int           error_class,
-                   int           severity,
-                   IcePointer    values)
-{
-        g_debug ("GsmXsmpServer: sms_error_handler (%p, %s, %d, %lx, %d, %d)",
-                 conn, swap ? "TRUE" : "FALSE", offending_minor_opcode,
-                 offending_sequence_num, error_class, severity);
-
-        /* We don't need to do anything here; if the connection needs to be
-         * closed, libSM will do that itself.
-         */
-}
-
-static IceAuthFileEntry *
-auth_entry_new (const char *protocol,
-                const char *network_id)
-{
-        IceAuthFileEntry *file_entry;
-        IceAuthDataEntry  data_entry;
-
-        file_entry = malloc (sizeof (IceAuthFileEntry));
-
-        file_entry->protocol_name = strdup (protocol);
-        file_entry->protocol_data = NULL;
-        file_entry->protocol_data_length = 0;
-        file_entry->network_id = strdup (network_id);
-        file_entry->auth_name = strdup (GSM_ICE_MAGIC_COOKIE_AUTH_NAME);
-        file_entry->auth_data = IceGenerateMagicCookie (GSM_ICE_MAGIC_COOKIE_LEN);
-        file_entry->auth_data_length = GSM_ICE_MAGIC_COOKIE_LEN;
-
-        /* Also create an in-memory copy, which is what the server will
-         * actually use for checking client auth.
-         */
-        data_entry.protocol_name = file_entry->protocol_name;
-        data_entry.network_id = file_entry->network_id;
-        data_entry.auth_name = file_entry->auth_name;
-        data_entry.auth_data = file_entry->auth_data;
-        data_entry.auth_data_length = file_entry->auth_data_length;
-        IceSetPaAuthData (1, &data_entry);
-
-        return file_entry;
-}
-
-static gboolean
-update_iceauthority (GsmXsmpServer *server,
-                     gboolean       adding)
-{
-        char             *filename;
-        char            **our_network_ids;
-        FILE             *fp;
-        IceAuthFileEntry *auth_entry;
-        GSList           *entries;
-        GSList           *e;
-        int               i;
-        int               ret;
-        gboolean          ok = FALSE;
-
-        filename = IceAuthFileName ();
-        do {
-                ret = IceLockAuthFile (filename,
-                                       GSM_ICE_AUTH_RETRIES,
-                                       GSM_ICE_AUTH_INTERVAL,
-                                       GSM_ICE_AUTH_LOCK_TIMEOUT);
-
-        } while (ret != IceAuthLockSuccess && errno == EINTR);
-
-        if (ret != IceAuthLockSuccess) {
-                g_warning ("IceLockAuthFile failed: %m");
-                return FALSE;
-        }
-
-        our_network_ids = g_malloc (server->priv->num_local_xsmp_sockets * sizeof (char *));
-        for (i = 0; i < server->priv->num_local_xsmp_sockets; i++) {
-                our_network_ids[i] = IceGetListenConnectionString (server->priv->xsmp_sockets[i]);
-        }
-
-        entries = NULL;
-
-        fp = fopen (filename, "r+");
-        if (fp != NULL) {
-                while ((auth_entry = IceReadAuthFileEntry (fp)) != NULL) {
-                        /* Skip/delete entries with no network ID (invalid), or with
-                         * our network ID; if we're starting up, an entry with our
-                         * ID must be a stale entry left behind by an old process,
-                         * and if we're shutting down, it won't be valid in the
-                         * future, so either way we want to remove it from the list.
-                         */
-                        if (!auth_entry->network_id) {
-                                IceFreeAuthFileEntry (auth_entry);
-                                continue;
-                        }
-
-                        for (i = 0; i < server->priv->num_local_xsmp_sockets; i++) {
-                                if (!strcmp (auth_entry->network_id, our_network_ids[i])) {
-                                        IceFreeAuthFileEntry (auth_entry);
-                                        break;
-                                }
-                        }
-                        if (i != server->priv->num_local_xsmp_sockets) {
-                                continue;
-                        }
-
-                        entries = g_slist_prepend (entries, auth_entry);
-                }
-
-                rewind (fp);
-        } else {
-                int fd;
-
-                if (errno != ENOENT) {
-                        g_warning ("Unable to read ICE authority file %s: %m", filename);
-                        goto cleanup;
-                }
-
-                fd = open (filename, O_CREAT | O_WRONLY, 0600);
-                fp = fdopen (fd, "w");
-                if (!fp) {
-                        g_warning ("Unable to write to ICE authority file: %s", filename);
-                        if (fd != -1) {
-                                close (fd);
-                        }
-                        goto cleanup;
-                }
-        }
-
-        if (adding) {
-                for (i = 0; i < server->priv->num_local_xsmp_sockets; i++) {
-                        entries = g_slist_append (entries,
-                                                  auth_entry_new ("ICE", our_network_ids[i]));
-                        entries = g_slist_prepend (entries,
-                                                   auth_entry_new ("XSMP", our_network_ids[i]));
-                }
-        }
-
-        for (e = entries; e; e = e->next) {
-                IceAuthFileEntry *auth_entry = e->data;
-                IceWriteAuthFileEntry (fp, auth_entry);
-                IceFreeAuthFileEntry (auth_entry);
-        }
-        g_slist_free (entries);
-
-        fclose (fp);
-        ok = TRUE;
-
- cleanup:
-        IceUnlockAuthFile (filename);
-        for (i = 0; i < server->priv->num_local_xsmp_sockets; i++) {
-                free (our_network_ids[i]);
-        }
-        g_free (our_network_ids);
-
-        return ok;
-}
-
-
-static void
-setup_listener (GsmXsmpServer *server)
-{
-        char   error[256];
-        mode_t saved_umask;
-        char  *network_id_list;
-        int    i;
-        int    res;
-
-        /* Set up sane error handlers */
-        IceSetErrorHandler (ice_error_handler);
-        IceSetIOErrorHandler (ice_io_error_handler);
-        SmsSetErrorHandler (sms_error_handler);
-
-        /* Initialize libSM; we pass NULL for hostBasedAuthProc to disable
-         * host-based authentication.
-         */
-        res = SmsInitialize (PACKAGE,
-                             VERSION,
-                             (SmsNewClientProc)accept_xsmp_connection,
-                             server,
-                             NULL,
-                             sizeof (error),
-                             error);
-        if (! res) {
-                gsm_util_init_error (TRUE, "Could not initialize libSM: %s", error);
-        }
-
-#ifdef HAVE_X11_XTRANS_XTRANS_H
-        /* By default, IceListenForConnections will open one socket for each
-         * transport type known to X. We don't want connections from remote
-         * hosts, so for security reasons it would be best if ICE didn't
-         * even open any non-local sockets. So we use an internal ICElib
-         * method to disable them here. Unfortunately, there is no way to
-         * ask X what transport types it knows about, so we're forced to
-         * guess.
-         */
-        _IceTransNoListen ("tcp");
-#endif
-
-        /* Create the XSMP socket. Older versions of IceListenForConnections
-         * have a bug which causes the umask to be set to 0 on certain types
-         * of failures. Probably not an issue on any modern systems, but
-         * we'll play it safe.
-         */
-        saved_umask = umask (0);
-        umask (saved_umask);
-        res = IceListenForConnections (&server->priv->num_xsmp_sockets,
-                                       &server->priv->xsmp_sockets,
-                                       sizeof (error),
-                                       error);
-        if (! res) {
-                gsm_util_init_error (TRUE, _("Could not create ICE listening socket: %s"), error);
-        }
-
-        umask (saved_umask);
-
-        /* Find the local sockets in the returned socket list and move them
-         * to the start of the list.
-         */
-        for (i = server->priv->num_local_xsmp_sockets = 0; i < server->priv->num_xsmp_sockets; i++) {
-                char *id = IceGetListenConnectionString (server->priv->xsmp_sockets[i]);
-
-                if (!strncmp (id, "local/", sizeof ("local/") - 1) ||
-                    !strncmp (id, "unix/", sizeof ("unix/") - 1)) {
-                        if (i > server->priv->num_local_xsmp_sockets) {
-                                IceListenObj tmp;
-                                tmp = server->priv->xsmp_sockets[i];
-                                server->priv->xsmp_sockets[i] = server->priv->xsmp_sockets[server->priv->num_local_xsmp_sockets];
-                                server->priv->xsmp_sockets[server->priv->num_local_xsmp_sockets] = tmp;
-                        }
-                        server->priv->num_local_xsmp_sockets++;
-                }
-                free (id);
-        }
-
-        if (server->priv->num_local_xsmp_sockets == 0) {
-                gsm_util_init_error (TRUE, "IceListenForConnections did not return a local listener!");
-        }
-
-#ifdef HAVE_X11_XTRANS_XTRANS_H
-        if (server->priv->num_local_xsmp_sockets != server->priv->num_xsmp_sockets) {
-                /* Xtrans was apparently compiled with support for some
-                 * non-local transport besides TCP (which we disabled above); we
-                 * won't create IO watches on those extra sockets, so
-                 * connections to them will never be noticed, but they're still
-                 * there, which is inelegant.
-                 *
-                 * If the g_warning below is triggering for you and you want to
-                 * stop it, the fix is to add additional _IceTransNoListen()
-                 * calls above.
-                 */
-                network_id_list = IceComposeNetworkIdList (server->priv->num_xsmp_sockets - server->priv->num_local_xsmp_sockets,
-                                                           server->priv->xsmp_sockets + server->priv->num_local_xsmp_sockets);
-                g_warning ("IceListenForConnections returned %d non-local listeners: %s",
-                           server->priv->num_xsmp_sockets - server->priv->num_local_xsmp_sockets,
-                           network_id_list);
-                free (network_id_list);
-        }
-#endif
-
-        /* Update .ICEauthority with new auth entries for our socket */
-        if (!update_iceauthority (server, TRUE)) {
-                /* FIXME: is this really fatal? Hm... */
-                gsm_util_init_error (TRUE,
-                                     "Could not update ICEauthority file %s",
-                                     IceAuthFileName ());
-        }
-
-        network_id_list = IceComposeNetworkIdList (server->priv->num_local_xsmp_sockets,
-                                                   server->priv->xsmp_sockets);
-
-        gsm_util_setenv ("SESSION_MANAGER", network_id_list);
-        g_debug ("GsmXsmpServer: SESSION_MANAGER=%s\n", network_id_list);
-        free (network_id_list);
-}
-
-static GObject *
-gsm_xsmp_server_constructor (GType                  type,
-                             guint                  n_construct_properties,
-                             GObjectConstructParam *construct_properties)
-{
-        GsmXsmpServer *xsmp_server;
-
-        xsmp_server = GSM_XSMP_SERVER (G_OBJECT_CLASS (gsm_xsmp_server_parent_class)->constructor (type,
-                                                                                       n_construct_properties,
-                                                                                       construct_properties));
-        setup_listener (xsmp_server);
-
-        return G_OBJECT (xsmp_server);
-}
-
-static void
-gsm_xsmp_server_class_init (GsmXsmpServerClass *klass)
-{
-        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
-
-        object_class->get_property = gsm_xsmp_server_get_property;
-        object_class->set_property = gsm_xsmp_server_set_property;
-        object_class->constructor = gsm_xsmp_server_constructor;
-        object_class->finalize = gsm_xsmp_server_finalize;
-
-        g_object_class_install_property (object_class,
-                                         PROP_CLIENT_STORE,
-                                         g_param_spec_object ("client-store",
-                                                              NULL,
-                                                              NULL,
-                                                              GSM_TYPE_STORE,
-                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-
-        g_type_class_add_private (klass, sizeof (GsmXsmpServerPrivate));
-}
-
-static void
-gsm_xsmp_server_init (GsmXsmpServer *xsmp_server)
-{
-        xsmp_server->priv = GSM_XSMP_SERVER_GET_PRIVATE (xsmp_server);
-
-}
-
-static void
-gsm_xsmp_server_finalize (GObject *object)
-{
-        GsmXsmpServer *xsmp_server;
-
-        g_return_if_fail (object != NULL);
-        g_return_if_fail (GSM_IS_XSMP_SERVER (object));
-
-        xsmp_server = GSM_XSMP_SERVER (object);
-
-        g_return_if_fail (xsmp_server->priv != NULL);
-
-        IceFreeListenObjs (xsmp_server->priv->num_xsmp_sockets, 
-                           xsmp_server->priv->xsmp_sockets);
-
-        if (xsmp_server->priv->client_store != NULL) {
-                g_object_unref (xsmp_server->priv->client_store);
-        }
-
-        G_OBJECT_CLASS (gsm_xsmp_server_parent_class)->finalize (object);
-}
-
-GsmXsmpServer *
-gsm_xsmp_server_new (GsmStore *client_store)
-{
-        if (xsmp_server_object != NULL) {
-                g_object_ref (xsmp_server_object);
-        } else {
-                xsmp_server_object = g_object_new (GSM_TYPE_XSMP_SERVER,
-                                                   "client-store", client_store,
-                                                   NULL);
-
-                g_object_add_weak_pointer (xsmp_server_object,
-                                           (gpointer *) &xsmp_server_object);
-        }
-
-        return GSM_XSMP_SERVER (xsmp_server_object);
-}
diff --git a/gnome-session/gsm-xsmp-server.h b/gnome-session/gsm-xsmp-server.h
deleted file mode 100644
index dc648ca..0000000
--- a/gnome-session/gsm-xsmp-server.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2008 William Jon McCann <jmccann@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- */
-
-
-#ifndef __GSM_XSMP_SERVER_H
-#define __GSM_XSMP_SERVER_H
-
-#include <glib-object.h>
-
-#include "gsm-store.h"
-
-G_BEGIN_DECLS
-
-#define GSM_TYPE_XSMP_SERVER         (gsm_xsmp_server_get_type ())
-#define GSM_XSMP_SERVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), GSM_TYPE_XSMP_SERVER, GsmXsmpServer))
-#define GSM_XSMP_SERVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GSM_TYPE_XSMP_SERVER, GsmXsmpServerClass))
-#define GSM_IS_XSMP_SERVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), GSM_TYPE_XSMP_SERVER))
-#define GSM_IS_XSMP_SERVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), GSM_TYPE_XSMP_SERVER))
-#define GSM_XSMP_SERVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GSM_TYPE_XSMP_SERVER, GsmXsmpServerClass))
-
-typedef struct GsmXsmpServerPrivate GsmXsmpServerPrivate;
-
-typedef struct
-{
-        GObject            parent;
-        GsmXsmpServerPrivate *priv;
-} GsmXsmpServer;
-
-typedef struct
-{
-        GObjectClass   parent_class;
-} GsmXsmpServerClass;
-
-GType               gsm_xsmp_server_get_type                       (void);
-
-GsmXsmpServer *     gsm_xsmp_server_new                            (GsmStore      *client_store);
-void                gsm_xsmp_server_start                          (GsmXsmpServer *server);
-void                gsm_xsmp_server_stop_accepting_new_clients     (GsmXsmpServer *server);
-void                gsm_xsmp_server_start_accepting_new_clients    (GsmXsmpServer *server);
-
-G_END_DECLS
-
-#endif /* __GSM_XSMP_SERVER_H */
diff --git a/gnome-session/main.c b/gnome-session/main.c
deleted file mode 100644
index cb84f78..0000000
--- a/gnome-session/main.c
+++ /dev/null
@@ -1,449 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2006 Novell, Inc.
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#include <config.h>
-
-#include <libintl.h>
-#include <signal.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-
-#include <glib/gi18n.h>
-#include <glib.h>
-
-#include <glib-unix.h>
-
-#include <dbus/dbus.h>
-#include <dbus/dbus-glib.h>
-#include <dbus/dbus-glib-bindings.h>
-#include <dbus/dbus-glib-lowlevel.h>
-
-#include "gdm-log.h"
-
-#include "gsm-util.h"
-#include "gsm-manager.h"
-#include "gsm-session-fill.h"
-#include "gsm-store.h"
-#include "gsm-system.h"
-#include "gsm-fail-whale.h"
-
-#ifdef HAVE_SYSTEMD
-#include <systemd/sd-journal.h>
-#endif
-
-#define GSM_DBUS_NAME "org.gnome.SessionManager"
-
-static gboolean failsafe = FALSE;
-static gboolean show_version = FALSE;
-static gboolean debug = FALSE;
-static gboolean please_fail = FALSE;
-
-static DBusGProxy *bus_proxy = NULL;
-
-static GMainLoop *loop;
-
-static void shutdown_cb (gpointer data);
-
-void
-gsm_quit (void)
-{
-        g_main_loop_quit (loop);
-}
-
-static void
-gsm_main (void)
-{
-        if (loop == NULL)
-                loop = g_main_loop_new (NULL, TRUE);
-
-        g_main_loop_run (loop);
-}
-
-static void
-on_bus_name_lost (DBusGProxy *bus_proxy,
-                  const char *name,
-                  gpointer    data)
-{
-        g_warning ("Lost name on bus: %s, exiting", name);
-        exit (1);
-}
-
-static gboolean
-acquire_name_on_proxy (DBusGProxy *bus_proxy,
-                       const char *name)
-{
-        GError     *error;
-        guint       result;
-        gboolean    res;
-        gboolean    ret;
-
-        ret = FALSE;
-
-        if (bus_proxy == NULL) {
-                goto out;
-        }
-
-        error = NULL;
-        res = dbus_g_proxy_call (bus_proxy,
-                                 "RequestName",
-                                 &error,
-                                 G_TYPE_STRING, name,
-                                 G_TYPE_UINT, 0,
-                                 G_TYPE_INVALID,
-                                 G_TYPE_UINT, &result,
-                                 G_TYPE_INVALID);
-        if (! res) {
-                if (error != NULL) {
-                        g_warning ("Failed to acquire %s: %s", name, error->message);
-                        g_error_free (error);
-                } else {
-                        g_warning ("Failed to acquire %s", name);
-                }
-                goto out;
-        }
-
-        if (result != DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER) {
-                if (error != NULL) {
-                        g_warning ("Failed to acquire %s: %s", name, error->message);
-                        g_error_free (error);
-                } else {
-                        g_warning ("Failed to acquire %s", name);
-                }
-                goto out;
-        }
-
-        /* register for name lost */
-        dbus_g_proxy_add_signal (bus_proxy,
-                                 "NameLost",
-                                 G_TYPE_STRING,
-                                 G_TYPE_INVALID);
-        dbus_g_proxy_connect_signal (bus_proxy,
-                                     "NameLost",
-                                     G_CALLBACK (on_bus_name_lost),
-                                     NULL,
-                                     NULL);
-
-
-        ret = TRUE;
-
- out:
-        return ret;
-}
-
-static gboolean
-acquire_name (void)
-{
-        GError          *error;
-        DBusGConnection *connection;
-
-        error = NULL;
-        connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
-        if (connection == NULL) {
-                gsm_util_init_error (TRUE,
-                                     "Could not connect to session bus: %s",
-                                     error->message);
-                return FALSE;
-        }
-
-        bus_proxy = dbus_g_proxy_new_for_name_owner (connection,
-                                                     DBUS_SERVICE_DBUS,
-                                                     DBUS_PATH_DBUS,
-                                                     DBUS_INTERFACE_DBUS,
-                                                     &error);
-        if (error != NULL) {
-                gsm_util_init_error (TRUE,
-                                     "Could not connect to session bus: %s",
-                                     error->message);
-                return FALSE;
-        }
-
-        if (! acquire_name_on_proxy (bus_proxy, GSM_DBUS_NAME) ) {
-                gsm_util_init_error (TRUE,
-                                     "%s",
-                                     "Could not acquire name on session bus");
-                return FALSE;
-        }
-
-        return TRUE;
-}
-
-static gboolean
-term_or_int_signal_cb (gpointer data)
-{
-        GsmManager *manager = (GsmManager *)data;
-
-        /* let the fatal signals interrupt us */
-        g_debug ("Caught SIGINT/SIGTERM, shutting down normally.");
-
-        gsm_manager_logout (manager, GSM_MANAGER_LOGOUT_MODE_FORCE, NULL);
-
-        return FALSE;
-}
-
-static gboolean
-sigusr2_cb (gpointer data)
-{
-        g_debug ("-------- MARK --------");
-        return TRUE;
-}
-
-static gboolean
-sigusr1_cb (gpointer data)
-{
-        gdm_log_toggle_debug ();
-        return TRUE;
-}
-
-static void
-shutdown_cb (gpointer data)
-{
-        GsmManager *manager = (GsmManager *)data;
-        g_debug ("Calling shutdown callback function");
-
-        /*
-         * When the signal handler gets a shutdown signal, it calls
-         * this function to inform GsmManager to not restart
-         * applications in the off chance a handler is already queued
-         * to dispatch following the below call to gtk_main_quit.
-         */
-        gsm_manager_set_phase (manager, GSM_MANAGER_PHASE_EXIT);
-
-        gsm_quit ();
-}
-
-static gboolean
-require_dbus_session (int      argc,
-                      char   **argv,
-                      GError **error)
-{
-        char **new_argv;
-        int    i;
-
-        if (g_getenv ("DBUS_SESSION_BUS_ADDRESS"))
-                return TRUE;
-
-        /* Just a sanity check to prevent infinite recursion if
-         * dbus-launch fails to set DBUS_SESSION_BUS_ADDRESS 
-         */
-        g_return_val_if_fail (!g_str_has_prefix (argv[0], "dbus-launch"),
-                              TRUE);
-
-        /* +2 for our new arguments, +1 for NULL */
-        new_argv = g_malloc (argc + 3 * sizeof (*argv));
-
-        new_argv[0] = "dbus-launch";
-        new_argv[1] = "--exit-with-session";
-        for (i = 0; i < argc; i++) {
-                new_argv[i + 2] = argv[i];
-	}
-        new_argv[i + 2] = NULL;
-        
-        if (!execvp ("dbus-launch", new_argv)) {
-                g_set_error (error, 
-                             G_SPAWN_ERROR,
-                             G_SPAWN_ERROR_FAILED,
-                             "No session bus and could not exec dbus-launch: %s",
-                             g_strerror (errno));
-                return FALSE;
-        }
-
-        /* Should not be reached */
-        return TRUE;
-}
-
-static gboolean
-check_gl (GError **error)
-{
-        int status;
-        char *argv[] = { LIBEXECDIR "/gnome-session-check-accelerated", NULL };
-
-        if (getenv ("DISPLAY") == NULL) {
-                /* Not connected to X11, someone else will take care of checking GL */
-                return TRUE;
-        }
-
-        if (!g_spawn_sync (NULL, (char **) argv, NULL, 0, NULL, NULL, NULL, NULL,
-                           &status, error)) {
-                return FALSE;
-        }
-
-        return g_spawn_check_exit_status (status, error);
-}
-
-int
-main (int argc, char **argv)
-{
-        GError           *error = NULL;
-        GsmManager       *manager;
-        GsmStore         *client_store;
-        static char     **override_autostart_dirs = NULL;
-        static char      *opt_session_name = NULL;
-        const char       *session_name;
-        gboolean          gl_failed = FALSE;
-        GOptionContext   *options;
-        static GOptionEntry entries[] = {
-                { "autostart", 'a', 0, G_OPTION_ARG_STRING_ARRAY, &override_autostart_dirs, N_("Override standard autostart directories"), N_("AUTOSTART_DIR") },
-                { "session", 0, 0, G_OPTION_ARG_STRING, &opt_session_name, N_("Session to use"), N_("SESSION_NAME") },
-                { "debug", 0, 0, G_OPTION_ARG_NONE, &debug, N_("Enable debugging code"), NULL },
-                { "failsafe", 'f', 0, G_OPTION_ARG_NONE, &failsafe, N_("Do not load user-specified applications"), NULL },
-                { "version", 0, 0, G_OPTION_ARG_NONE, &show_version, N_("Version of this application"), NULL },
-                /* Translators: the 'fail whale' is the black dialog we show when something goes seriously wrong */
-                { "whale", 0, 0, G_OPTION_ARG_NONE, &please_fail, N_("Show the fail whale dialog for testing"), NULL },
-                { NULL, 0, 0, 0, NULL, NULL, NULL }
-        };
-
-        /* Make sure that we have a session bus */
-        if (!require_dbus_session (argc, argv, &error)) {
-                gsm_util_init_error (TRUE, "%s", error->message);
-        }
-
-        /* Check GL, if it doesn't work out then force software fallback */
-        if (!check_gl (&error)) {
-                gl_failed = TRUE;
-
-                g_debug ("hardware acceleration check failed: %s",
-                         error? error->message : "");
-                g_clear_error (&error);
-                if (g_getenv ("LIBGL_ALWAYS_SOFTWARE") == NULL) {
-                        g_setenv ("LIBGL_ALWAYS_SOFTWARE", "1", TRUE);
-                        if (!check_gl (&error)) {
-                                g_warning ("software acceleration check failed: %s",
-                                           error? error->message : "");
-                                g_clear_error (&error);
-                        } else {
-                                gl_failed = FALSE;
-                        }
-                }
-        }
-
-        bindtextdomain (GETTEXT_PACKAGE, LOCALE_DIR);
-        bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
-        textdomain (GETTEXT_PACKAGE);
-
-        error = NULL;
-        options = g_option_context_new (_(" - the GNOME session manager"));
-        g_option_context_add_main_entries (options, entries, GETTEXT_PACKAGE);
-        g_option_context_parse (options, &argc, &argv, &error);
-        if (error != NULL) {
-                g_warning ("%s", error->message);
-                exit (1);
-        }
-
-        g_option_context_free (options);
-
-        if (show_version) {
-                g_print ("%s %s\n", argv [0], VERSION);
-                exit (0);
-        }
-
-        /* Rebind stdout/stderr to the journal explicitly, so that
-         * journald picks ups the nicer "gnome-session" as the program
-         * name instead of whatever shell script GDM happened to use.
-         */
-#ifdef HAVE_SYSTEMD
-        if (!debug) {
-                int journalfd;
-
-                journalfd = sd_journal_stream_fd (PACKAGE, LOG_INFO, 0);
-                if (journalfd >= 0) {
-                        dup2(journalfd, 1);
-                        dup2(journalfd, 2);
-                }
-        }
-#endif
-
-        if (gl_failed) {
-                gsm_fail_whale_dialog_we_failed (FALSE, TRUE, NULL);
-                gsm_main ();
-                exit (1);
-        }
-
-        if (please_fail) {
-                gsm_fail_whale_dialog_we_failed (TRUE, TRUE, NULL);
-                gsm_main ();
-                exit (1);
-        }
-
-        gdm_log_init ();
-        gdm_log_set_debug (debug);
-
-        /* Some third-party programs rely on GNOME_DESKTOP_SESSION_ID to
-         * detect if GNOME is running. We keep this for compatibility reasons.
-         */
-        gsm_util_setenv ("GNOME_DESKTOP_SESSION_ID", "this-is-deprecated");
-
-        /* We want to use the GNOME menus which has the designed categories.
-         */
-        gsm_util_setenv ("XDG_MENU_PREFIX", "gnome-");
-
-        client_store = gsm_store_new ();
-
-        /* Talk to logind before acquiring a name, since it does synchronous
-         * calls at initialization time that invoke a main loop and if we
-         * already owned a name, then we would service too early during
-         * that main loop.
-         */
-        g_object_unref (gsm_get_system ());
-
-        if (!acquire_name ()) {
-                gsm_fail_whale_dialog_we_failed (TRUE, TRUE, NULL);
-                gsm_main ();
-                exit (1);
-        }
-
-        manager = gsm_manager_new (client_store, failsafe);
-
-        g_signal_connect_object (bus_proxy,
-                                 "destroy",
-                                 G_CALLBACK (shutdown_cb),
-                                 manager,
-                                 G_CONNECT_SWAPPED);
-
-        g_unix_signal_add (SIGTERM, term_or_int_signal_cb, manager);
-        g_unix_signal_add (SIGINT, term_or_int_signal_cb, manager);
-        g_unix_signal_add (SIGUSR1, sigusr1_cb, manager);
-        g_unix_signal_add (SIGUSR2, sigusr2_cb, manager);
-
-        if (IS_STRING_EMPTY (opt_session_name))
-                session_name = _gsm_manager_get_default_session (manager);
-        else
-                session_name = opt_session_name;
-
-        gsm_util_set_autostart_dirs (override_autostart_dirs);
-
-        if (!gsm_session_fill (manager, session_name)) {
-                gsm_fail_whale_dialog_we_failed (FALSE, TRUE, NULL);
-        }
-
-        gsm_manager_start (manager);
-
-        gsm_main ();
-
-        g_clear_object (&manager);
-        g_clear_object (&client_store);
-        g_clear_object (&bus_proxy);
-
-        gdm_log_shutdown ();
-
-        return 0;
-}
diff --git a/gnome-session/org.gnome.SessionManager.App.xml b/gnome-session/org.gnome.SessionManager.App.xml
deleted file mode 100644
index 9f6e1b3..0000000
--- a/gnome-session/org.gnome.SessionManager.App.xml
+++ /dev/null
@@ -1,43 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" ?>
-<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
-<node xmlns:doc="http://www.freedesktop.org/dbus/1.0/doc.dtd">
-  <interface name="org.gnome.SessionManager.App">
-    <method name="GetAppId">
-      <arg type="s" name="app_id" direction="out">
-        <doc:doc>
-          <doc:summary>The identifier for the application</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Return the application ID.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-    <method name="GetStartupId">
-      <arg type="s" name="startup_id" direction="out">
-        <doc:doc>
-          <doc:summary>The startup identifier</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Return the startup ID associated with this application.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-    <method name="GetPhase">
-      <arg type="u" name="phase" direction="out">
-        <doc:doc>
-          <doc:summary>The application startup phase</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Return the startup phase of this application.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-  </interface>
-</node>
diff --git a/gnome-session/org.gnome.SessionManager.Client.xml b/gnome-session/org.gnome.SessionManager.Client.xml
deleted file mode 100644
index a0f5a31..0000000
--- a/gnome-session/org.gnome.SessionManager.Client.xml
+++ /dev/null
@@ -1,73 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" ?>
-<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
-<node xmlns:doc="http://www.freedesktop.org/dbus/1.0/doc.dtd">
-  <interface name="org.gnome.SessionManager.Client">
-    <method name="GetAppId">
-      <arg type="s" name="app_id" direction="out">
-        <doc:doc>
-          <doc:summary>The identifier for the associated application</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Return the application ID associated with this client.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-    <method name="GetStartupId">
-      <arg type="s" name="startup_id" direction="out">
-        <doc:doc>
-          <doc:summary>The startup identifier</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Return the startup ID associated with this client.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-    <method name="GetRestartStyleHint">
-      <arg type="u" name="hint" direction="out">
-        <doc:doc>
-          <doc:summary>The restart style hint</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Return the restart style hint for this client.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-    <method name="GetUnixProcessId">
-      <arg type="u" name="pid" direction="out">
-        <doc:doc>
-          <doc:summary>The Unix process identifier</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Return the Unix process identifier for this client.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-    <method name="GetStatus">
-      <arg type="u" name="status" direction="out">
-        <doc:doc>
-          <doc:summary>The client status</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Return the status of this client.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-    <method name="Stop">
-      <doc:doc>
-        <doc:description>
-          <doc:para>Inititate a request to terminate this application via XSMP.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-  </interface>
-</node>
diff --git a/gnome-session/org.gnome.SessionManager.ClientPrivate.xml b/gnome-session/org.gnome.SessionManager.ClientPrivate.xml
deleted file mode 100644
index a167065..0000000
--- a/gnome-session/org.gnome.SessionManager.ClientPrivate.xml
+++ /dev/null
@@ -1,123 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" ?>
-<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
-<node xmlns:doc="http://www.freedesktop.org/dbus/1.0/doc.dtd">
-  <interface name="org.gnome.SessionManager.ClientPrivate">
-    <method name="EndSessionResponse">
-      <arg name="is_ok" type="b" direction="in">
-        <doc:doc>
-          <doc:summary>Whether or not it is OK to preceed</doc:summary>
-        </doc:doc>
-      </arg>
-      <arg name="reason" type="s" direction="in">
-        <doc:doc>
-          <doc:summary>The reason string</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>This method should be used by the client in response to
-            the <doc:ref type="signal" to="org.gnome.SessionManager.ClientPrivate::QueryEndSession">QueryEndSession</doc:ref>
-            and <doc:ref type="signal" to="org.gnome.SessionManager.ClientPrivate::EndSession">EndSession</doc:ref> signals.
-          </doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-    <signal name="Stop">
-      <doc:doc>
-        <doc:summary>Stop client</doc:summary>
-        <doc:description>
-          <doc:para>
-            The client should stop and remove itself from the session in
-            response to this signal.
-          </doc:para>
-        </doc:description>
-      </doc:doc>
-    </signal>
-
-    <signal name="QueryEndSession">
-      <arg name="flags" type="u">
-        <doc:doc>
-          <doc:summary>Flags</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>This signal is used to inform the client that the
-            session is about to end.  The client must respond by
-            calling
-            <doc:ref type="method" to="org.gnome.SessionManager.ClientPrivate.EndSessionResponse">EndSessionResponse</doc:ref>
-            within one second of the signal emission.
-          </doc:para>
-          <doc:para>
-            The flags may include:
-            <doc:list>
-              <doc:item>
-                <doc:term>1</doc:term>
-                <doc:definition>Logout is forced.
-                  <doc:ref type="method" to="org.gnome.SessionManager.ClientPrivate.EndSessionResponse">EndSessionResponse</doc:ref>
-                reason and any inhibit from client will be
-                ignored.</doc:definition>
-              </doc:item>
-            </doc:list>
-          </doc:para>
-          <doc:para>
-            If the client responds with an EndSessionResponse is-ok
-            argument equal to FALSE and a reason then this reason may
-            be displayed to the user.
-          </doc:para>
-          <doc:para>
-            The client must not attempt to perform any actions or
-            interact with the user in response to this signal.  Any
-            actions required for a clean shutdown should take place in
-            response to the
-            <doc:ref type="signal" to="org.gnome.SessionManager.ClientPrivate::EndSession">EndSession</doc:ref> signal.
-          </doc:para>
-          <doc:para>
-            The client should limit operations until either a
-            <doc:ref type="signal" to="org.gnome.SessionManager.ClientPrivate::EndSession">EndSession</doc:ref>
-            <doc:ref type="signal" to="org.gnome.SessionManager.ClientPrivate::CancelEndSession">CancelEndSession</doc:ref>
-            signal is received.
-          </doc:para>
-        </doc:description>
-      </doc:doc>
-    </signal>
-
-    <signal name="EndSession">
-      <arg name="flags" type="u">
-        <doc:doc>
-          <doc:summary>Flags</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>This signal is used to inform the client that the
-            session is about to end.  The client must respond by
-            calling
-            <doc:ref type="method" to="org.gnome.SessionManager.ClientPrivate.EndSessionResponse">EndSessionResponse</doc:ref>
-            within ten seconds of the signal emission.
-          </doc:para>
-          <doc:para>
-            The client must not attempt to interact with the user in
-            response to this signal.  The application will be given a
-            maxium of ten seconds to perform any actions required for
-            a clean shutdown.
-          </doc:para>
-        </doc:description>
-      </doc:doc>
-    </signal>
-
-    <signal name="CancelEndSession">
-      <doc:doc>
-        <doc:description>
-          <doc:para>
-            This signal indicates to the client that a previous emission of
-            <doc:ref type="signal" to="org.gnome.SessionManager.ClientPrivate::QueryEndSession">QueryEndSession</doc:ref>
-            has been cancelled.  The client should resume normal operations.
-          </doc:para>
-        </doc:description>
-      </doc:doc>
-    </signal>
-
-  </interface>
-</node>
diff --git a/gnome-session/org.gnome.SessionManager.Inhibitor.xml b/gnome-session/org.gnome.SessionManager.Inhibitor.xml
deleted file mode 100644
index 342d2a8..0000000
--- a/gnome-session/org.gnome.SessionManager.Inhibitor.xml
+++ /dev/null
@@ -1,66 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" ?>
-<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
-<node xmlns:doc="http://www.freedesktop.org/dbus/1.0/doc.dtd">
-  <interface name="org.gnome.SessionManager.Inhibitor">
-    <method name="GetAppId">
-      <arg type="s" name="app_id" direction="out">
-        <doc:doc>
-          <doc:summary>The identifier for the associated application</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Return the application ID associated with this inhibit.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-    <method name="GetClientId">
-      <arg type="o" name="client_id" direction="out">
-        <doc:doc>
-          <doc:summary>The object path of the associated client</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Return the client object path associated with this inhibit.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-    <method name="GetReason">
-      <arg type="s" name="reason" direction="out">
-        <doc:doc>
-          <doc:summary>The reason for the inhibit</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Return the reason for the inhibit</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-    <method name="GetFlags">
-      <arg type="u" name="flags" direction="out">
-        <doc:doc>
-          <doc:summary>The flags that determine the scope of the inhibit</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Return the flags that determine the scope of the inhibit</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-    <method name="GetToplevelXid">
-      <arg type="u" name="xid" direction="out">
-        <doc:doc>
-          <doc:summary>X11 toplevel window identifier associated with this inhibit.  Zero if not set.</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Return the X11 toplevel window identifier associated with this inhibit.  Zero if not set.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-  </interface>
-</node>
diff --git a/gnome-session/org.gnome.SessionManager.Presence.xml b/gnome-session/org.gnome.SessionManager.Presence.xml
deleted file mode 100644
index 0441970..0000000
--- a/gnome-session/org.gnome.SessionManager.Presence.xml
+++ /dev/null
@@ -1,95 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" ?>
-<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
-<node xmlns:doc="http://www.freedesktop.org/dbus/1.0/doc.dtd">
-  <interface name="org.gnome.SessionManager.Presence">
-
-    <property name="status" type="u" access="readwrite">
-      <doc:doc>
-        <doc:description>
-          <doc:para>
-            The status of the session.
-          </doc:para>
-          <doc:para>
-            The status parameter must be one of the following:
-            <doc:list>
-              <doc:item>
-                <doc:term>0</doc:term>
-                <doc:definition>Available</doc:definition>
-              </doc:item>
-              <doc:item>
-                <doc:term>1</doc:term>
-                <doc:definition>Invisible</doc:definition>
-              </doc:item>
-              <doc:item>
-                <doc:term>2</doc:term>
-                <doc:definition>Busy</doc:definition>
-              </doc:item>
-              <doc:item>
-                <doc:term>3</doc:term>
-                <doc:definition>Idle</doc:definition>
-              </doc:item>
-            </doc:list>
-          </doc:para>
-        </doc:description>
-      </doc:doc>
-    </property>
-    <property name="status-text" type="s" access="readwrite">
-      <doc:doc>
-        <doc:description>
-          <doc:para>The descriptive status for the session.
-          </doc:para>
-        </doc:description>
-      </doc:doc>
-    </property>
-    <method name="SetStatus">
-      <arg type="u" name="status" direction="in">
-        <doc:doc>
-          <doc:summary>The status value</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Set the status value of the session.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-    <method name="SetStatusText">
-      <arg type="s" name="status_text" direction="in">
-        <doc:doc>
-          <doc:summary>The descriptive status for the session.</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Set the descriptive status text for the session.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-    <signal name="StatusChanged">
-      <arg name="status" type="u">
-        <doc:doc>
-          <doc:summary>The new status value</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Indicates that the session status value has changed.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </signal>
-    <signal name="StatusTextChanged">
-      <arg name="status_text" type="s">
-        <doc:doc>
-          <doc:summary>The new status text</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Indicates that the descriptive session status text has changed.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </signal>
-
-  </interface>
-</node>
diff --git a/gnome-session/org.gnome.SessionManager.xml b/gnome-session/org.gnome.SessionManager.xml
deleted file mode 100644
index 8c31694..0000000
--- a/gnome-session/org.gnome.SessionManager.xml
+++ /dev/null
@@ -1,453 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" ?>
-<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
-<node xmlns:doc="http://www.freedesktop.org/dbus/1.0/doc.dtd">
-  <interface name="org.gnome.SessionManager">
-
-    <!-- Initialization phase interfaces -->
-
-    <method name="Setenv">
-      <arg name="variable" type="s" direction="in">
-        <doc:doc>
-          <doc:summary>The variable name</doc:summary>
-        </doc:doc>
-      </arg>
-      <arg name="value" type="s" direction="in">
-        <doc:doc>
-          <doc:summary>The value</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Adds the variable name to the application launch environment with the specified value.  May only be used during the Session Manager initialization phase.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-    <method name="GetLocale">
-      <arg name="category" type="i" direction="in">
-        <doc:doc>
-          <doc:summary>The locale category</doc:summary>
-        </doc:doc>
-      </arg>
-      <arg name="value" type="s" direction="out">
-        <doc:doc>
-          <doc:summary>The value</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Reads the current state of the specific locale category.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-    <method name="InitializationError">
-      <arg name="message" type="s" direction="in">
-        <doc:doc>
-          <doc:summary>The error message</doc:summary>
-        </doc:doc>
-      </arg>
-      <arg name="fatal" type="b" direction="in">
-        <doc:doc>
-          <doc:summary>Whether the error should be treated as fatal</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>May be used by applications launched during the Session Manager initialization phase to indicate there was a problem.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-    <!-- Running phase interfaces -->
-
-    <method name="RegisterClient">
-      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
-      <arg type="s" name="app_id" direction="in">
-        <doc:doc>
-          <doc:summary>The application identifier</doc:summary>
-        </doc:doc>
-      </arg>
-      <arg type="s" name="client_startup_id" direction="in">
-        <doc:doc>
-          <doc:summary>Client startup identifier</doc:summary>
-        </doc:doc>
-      </arg>
-      <arg type="o" name="client_id" direction="out">
-        <doc:doc>
-          <doc:summary>The object path of the newly registered client</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Register the caller as a Session Management client.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-    <method name="UnregisterClient">
-      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
-      <arg type="o" name="client_id" direction="in">
-        <doc:doc>
-          <doc:summary>The object path of the client</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Unregister the specified client from Session Management.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-    <method name="Inhibit">
-      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
-      <arg type="s" name="app_id" direction="in">
-        <doc:doc>
-          <doc:summary>The application identifier</doc:summary>
-        </doc:doc>
-      </arg>
-      <arg type="u" name="toplevel_xid" direction="in">
-        <doc:doc>
-          <doc:summary>The toplevel X window identifier</doc:summary>
-        </doc:doc>
-      </arg>
-      <arg type="s" name="reason" direction="in">
-        <doc:doc>
-          <doc:summary>The reason for the inhibit</doc:summary>
-        </doc:doc>
-      </arg>
-      <arg type="u" name="flags" direction="in">
-        <doc:doc>
-          <doc:summary>Flags that specify what should be inhibited</doc:summary>
-        </doc:doc>
-      </arg>
-      <arg type="u" name="inhibit_cookie" direction="out">
-        <doc:doc>
-          <doc:summary>The cookie</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:summary>
-          Proactively indicates that the calling application is performing an action that should not be interrupted and sets a reason to be displayed to the user when an interruption is about to take placea.
-        </doc:summary>
-        <doc:description>
-          <doc:para>Applications should invoke this method when they begin an operation that
-            should not be interrupted, such as creating a CD or DVD.  The types of actions
-            that may be blocked are specified by the flags parameter.  When the application
-            completes the operation it should call <doc:ref type="method" to="org.gnome.SessionManager.Uninhibit">Uninhibit()</doc:ref>
-            or disconnect from the session bus.
-          </doc:para>
-          <doc:para>
-            Applications should not expect that they will always be able to block the
-            action.  In most cases, users will be given the option to force the action
-            to take place.
-          </doc:para>
-          <doc:para>
-            Reasons should be short and to the point.
-          </doc:para>
-          <doc:para>
-            The flags parameter must include at least one of the following:
-            <doc:list>
-              <doc:item>
-                <doc:term>1</doc:term>
-                <doc:definition>Inhibit logging out</doc:definition>
-              </doc:item>
-              <doc:item>
-                <doc:term>2</doc:term>
-                <doc:definition>Inhibit user switching</doc:definition>
-              </doc:item>
-              <doc:item>
-                <doc:term>4</doc:term>
-                <doc:definition>Inhibit suspending the session or computer</doc:definition>
-              </doc:item>
-              <doc:item>
-                <doc:term>8</doc:term>
-                <doc:definition>Inhibit the session being marked as idle</doc:definition>
-              </doc:item>
-              <doc:item>
-                <doc:term>16</doc:term>
-                <doc:definition>Inhibit auto-mounting removable media for the session</doc:definition>
-              </doc:item>
-            </doc:list>
-            Values for flags may be bitwise or'ed together.
-          </doc:para>
-          <doc:para>
-            The returned cookie is used to uniquely identify this request.  It should be used
-            as an argument to <doc:ref type="method" to="org.gnome.SessionManager.Uninhibit">Uninhibit()</doc:ref> in
-            order to remove the request.
-          </doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-    <method name="Uninhibit">
-      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
-      <arg type="u" name="inhibit_cookie" direction="in">
-        <doc:doc>
-          <doc:summary>The cookie</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Cancel a previous call to <doc:ref type="method" to="org.gnome.SessionManager.Inhibit">Inhibit()</doc:ref> identified by the cookie.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-    <method name="IsInhibited">
-      <arg type="u" name="flags" direction="in">
-        <doc:doc>
-          <doc:summary>Flags that spefify what should be inhibited</doc:summary>
-        </doc:doc>
-      </arg>
-      <arg type="b" name="is_inhibited" direction="out">
-        <doc:doc>
-          <doc:summary>Returns TRUE if any of the operations in the bitfield flags are inhibited</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Determine if operation(s) specified by the flags
-            are currently inhibited.  Flags are same as those accepted
-            by the
-            <doc:ref type="method" to="org.gnome.SessionManager.Inhibit">Inhibit()</doc:ref>
-            method.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-    <method name="GetClients">
-      <arg name="clients" direction="out" type="ao">
-        <doc:doc>
-          <doc:summary>an array of client IDs</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>This gets a list of all the <doc:ref type="interface" to="org.gnome.SessionManager.Client">Clients</doc:ref>
-          that are currently known to the session manager.</doc:para>
-          <doc:para>Each Client ID is an D-Bus object path for the object that implements the
-          <doc:ref type="interface" to="org.gnome.SessionManager.Client">Client</doc:ref> interface.</doc:para>
-        </doc:description>
-        <doc:seealso><doc:ref type="interface" to="org.gnome.SessionManager.Client">org.gnome.SessionManager.Client</doc:ref></doc:seealso>
-      </doc:doc>
-    </method>
-
-    <method name="GetInhibitors">
-      <arg name="inhibitors" direction="out" type="ao">
-        <doc:doc>
-          <doc:summary>an array of inhibitor IDs</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>This gets a list of all the <doc:ref type="interface" to="org.gnome.SessionManager.Inhibitor">Inhibitors</doc:ref>
-          that are currently known to the session manager.</doc:para>
-          <doc:para>Each Inhibitor ID is an D-Bus object path for the object that implements the
-          <doc:ref type="interface" to="org.gnome.SessionManager.Inhibitor">Inhibitor</doc:ref> interface.</doc:para>
-        </doc:description>
-        <doc:seealso><doc:ref type="interface" to="org.gnome.SessionManager.Inhibitor">org.gnome.SessionManager.Inhibitor</doc:ref></doc:seealso>
-      </doc:doc>
-    </method>
-
-
-    <method name="IsAutostartConditionHandled">
-      <arg name="condition" direction="in" type="s">
-        <doc:doc>
-          <doc:summary>The autostart condition string</doc:summary>
-        </doc:doc>
-      </arg>
-      <arg name="handled" direction="out" type="b">
-        <doc:doc>
-          <doc:summary>True if condition is handled, false otherwise</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Allows the caller to determine whether the session manager is
-          handling changes to the specified autostart condition.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-    <method name="Shutdown">
-      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Request a shutdown dialog.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-    <method name="Reboot">
-      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Request a reboot dialog.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-    <method name="CanShutdown">
-      <arg name="is_available" direction="out" type="b">
-        <doc:doc>
-          <doc:summary>True if shutdown is available to the user, false otherwise</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Allows the caller to determine whether or not it's okay to show
-          a shutdown option in the UI</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-    <method name="Logout">
-      <arg name="mode" type="u" direction="in">
-        <doc:doc>
-          <doc:summary>The type of logout that is being requested</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Request a logout dialog</doc:para>
-          <doc:para>
-            Allowed values for the mode parameter are:
-            <doc:list>
-              <doc:item>
-                <doc:term>0</doc:term>
-                <doc:definition>Normal.</doc:definition>
-              </doc:item>
-              <doc:item>
-                <doc:term>1</doc:term>
-                <doc:definition>No confirmation inferface should be shown.</doc:definition>
-              </doc:item>
-              <doc:item>
-                <doc:term>2</doc:term>
-                <doc:definition>Forcefully logout.  No confirmation will be shown and any inhibitors will be ignored.</doc:definition>
-              </doc:item>
-            </doc:list>
-            Values for flags may be bitwise or'ed together.
-          </doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-    <method name="IsSessionRunning">
-      <arg name="running" direction="out" type="b">
-        <doc:doc>
-          <doc:summary>True if the session has entered the Running phase, false otherwise</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Allows the caller to determine whether the session manager
-          has entered the Running phase, in case the client missed the
-          SessionRunning signal.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </method>
-
-    <!-- Signals -->
-
-    <signal name="ClientAdded">
-      <arg name="id" type="o">
-        <doc:doc>
-          <doc:summary>The object path for the added client</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Emitted when a client has been added to the session manager.
-          </doc:para>
-        </doc:description>
-      </doc:doc>
-    </signal>
-    <signal name="ClientRemoved">
-      <arg name="id" type="o">
-        <doc:doc>
-          <doc:summary>The object path for the removed client</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Emitted when a client has been removed from the session manager.
-          </doc:para>
-        </doc:description>
-      </doc:doc>
-    </signal>
-
-    <signal name="InhibitorAdded">
-      <arg name="id" type="o">
-        <doc:doc>
-          <doc:summary>The object path for the added inhibitor</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Emitted when an inhibitor has been added to the session manager.
-          </doc:para>
-        </doc:description>
-      </doc:doc>
-    </signal>
-    <signal name="InhibitorRemoved">
-      <arg name="id" type="o">
-        <doc:doc>
-          <doc:summary>The object path for the removed inhibitor</doc:summary>
-        </doc:doc>
-      </arg>
-      <doc:doc>
-        <doc:description>
-          <doc:para>Emitted when an inhibitor has been removed from the session manager.
-          </doc:para>
-        </doc:description>
-      </doc:doc>
-    </signal>
-
-    <signal name="SessionRunning">
-      <doc:doc>
-        <doc:description>
-          <doc:para>Indicates the session has entered the Running phase.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </signal>
-
-    <signal name="SessionOver">
-      <doc:doc>
-        <doc:description>
-          <doc:para>Indicates the session is about to end.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </signal>
-
-    <!-- Properties -->
-
-    <property name="SessionName" type="s" access="read">
-      <doc:doc>
-        <doc:description>
-          <doc:para>The name of the session that has been loaded.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </property>
-
-    <property name="SessionIsActive" type="b" access="read">
-      <doc:doc>
-        <doc:description>
-          <doc:para>If true, the session is currently in the
-          foreground and available for user input.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </property>
-
-    <property name="InhibitedActions" type="u" access="read">
-      <doc:doc>
-        <doc:description>
-          <doc:para>A bitmask of flags to indicate which actions
-          are inhibited. See the Inhibit() function's description
-          for a list of possible values.</doc:para>
-        </doc:description>
-      </doc:doc>
-    </property>
-
-  </interface>
-</node>
diff --git a/gnome-session/test-client-dbus.c b/gnome-session/test-client-dbus.c
deleted file mode 100644
index 18dc99e..0000000
--- a/gnome-session/test-client-dbus.c
+++ /dev/null
@@ -1,264 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- *
- */
-
-#include "config.h"
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-
-#include <glib.h>
-#include <dbus/dbus-glib.h>
-
-#define SM_DBUS_NAME      "org.gnome.SessionManager"
-#define SM_DBUS_PATH      "/org/gnome/SessionManager"
-#define SM_DBUS_INTERFACE "org.gnome.SessionManager"
-
-#define SM_CLIENT_DBUS_INTERFACE "org.gnome.SessionManager.ClientPrivate"
-
-static DBusGConnection *bus_connection = NULL;
-static DBusGProxy      *sm_proxy = NULL;
-static char            *client_id = NULL;
-static DBusGProxy      *client_proxy = NULL;
-static GMainLoop       *main_loop = NULL;
-
-static gboolean
-session_manager_connect (void)
-{
-
-        if (bus_connection == NULL) {
-                GError *error;
-
-                error = NULL;
-                bus_connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
-                if (bus_connection == NULL) {
-                        g_message ("Failed to connect to the session bus: %s",
-                                   error->message);
-                        g_error_free (error);
-                        exit (1);
-                }
-        }
-
-        sm_proxy = dbus_g_proxy_new_for_name (bus_connection,
-                                              SM_DBUS_NAME,
-                                              SM_DBUS_PATH,
-                                              SM_DBUS_INTERFACE);
-        return (sm_proxy != NULL);
-}
-
-static void
-on_client_query_end_session (DBusGProxy     *proxy,
-                             guint           flags,
-                             gpointer        data)
-{
-        GError     *error;
-        gboolean    is_ok;
-        gboolean    res;
-        const char *reason;
-
-        is_ok = FALSE;
-        reason = "Unsaved files";
-
-        g_debug ("Got query end session signal flags=%u", flags);
-
-        error = NULL;
-        res = dbus_g_proxy_call (proxy,
-                                 "EndSessionResponse",
-                                 &error,
-                                 G_TYPE_BOOLEAN, is_ok,
-                                 G_TYPE_STRING, reason,
-                                 G_TYPE_INVALID,
-                                 G_TYPE_INVALID);
-
-        if (! res) {
-                g_warning ("Failed to respond to EndSession: %s", error->message);
-                g_error_free (error);
-        }
-}
-
-static void
-on_client_end_session (DBusGProxy     *proxy,
-                       guint           flags,
-                       gpointer        data)
-{
-        g_debug ("Got end session signal flags=%u", flags);
-}
-
-static void
-on_client_cancel_end_session (DBusGProxy     *proxy,
-                              gpointer        data)
-{
-        g_debug ("Got end session cancelled signal");
-}
-
-static void
-on_client_stop (DBusGProxy     *proxy,
-                gpointer        data)
-{
-        g_debug ("Got client stop signal");
-        g_main_loop_quit (main_loop);
-}
-
-static gboolean
-register_client (void)
-{
-        GError     *error;
-        gboolean    res;
-        const char *startup_id;
-        const char *app_id;
-
-        startup_id = g_getenv ("DESKTOP_AUTOSTART_ID");
-        app_id = "gedit";
-
-        error = NULL;
-        res = dbus_g_proxy_call (sm_proxy,
-                                 "RegisterClient",
-                                 &error,
-                                 G_TYPE_STRING, app_id,
-                                 G_TYPE_STRING, startup_id,
-                                 G_TYPE_INVALID,
-                                 DBUS_TYPE_G_OBJECT_PATH, &client_id,
-                                 G_TYPE_INVALID);
-        if (! res) {
-                g_warning ("Failed to register client: %s", error->message);
-                g_error_free (error);
-                return FALSE;
-        }
-
-        g_debug ("Client registered with session manager: %s", client_id);
-        client_proxy = dbus_g_proxy_new_for_name (bus_connection,
-                                                  SM_DBUS_NAME,
-                                                  client_id,
-                                                  SM_CLIENT_DBUS_INTERFACE);
-        dbus_g_proxy_add_signal (client_proxy,
-                                 "QueryEndSession",
-                                 G_TYPE_UINT,
-                                 G_TYPE_INVALID);
-        dbus_g_proxy_add_signal (client_proxy,
-                                 "EndSession",
-                                 G_TYPE_UINT,
-                                 G_TYPE_INVALID);
-        dbus_g_proxy_add_signal (client_proxy,
-                                 "CancelEndSession",
-                                 G_TYPE_UINT,
-                                 G_TYPE_INVALID);
-        dbus_g_proxy_add_signal (client_proxy,
-                                 "Stop",
-                                 G_TYPE_INVALID);
-        dbus_g_proxy_connect_signal (client_proxy,
-                                     "QueryEndSession",
-                                     G_CALLBACK (on_client_query_end_session),
-                                     NULL,
-                                     NULL);
-        dbus_g_proxy_connect_signal (client_proxy,
-                                     "EndSession",
-                                     G_CALLBACK (on_client_end_session),
-                                     NULL,
-                                     NULL);
-        dbus_g_proxy_connect_signal (client_proxy,
-                                     "CancelEndSession",
-                                     G_CALLBACK (on_client_cancel_end_session),
-                                     NULL,
-                                     NULL);
-        dbus_g_proxy_connect_signal (client_proxy,
-                                     "Stop",
-                                     G_CALLBACK (on_client_stop),
-                                     NULL,
-                                     NULL);
-
-        return TRUE;
-}
-
-static gboolean
-session_manager_disconnect (void)
-{
-        if (sm_proxy != NULL) {
-                g_object_unref (sm_proxy);
-                sm_proxy = NULL;
-        }
-
-        return TRUE;
-}
-
-static gboolean
-unregister_client (void)
-{
-        GError  *error;
-        gboolean res;
-
-        error = NULL;
-        res = dbus_g_proxy_call (sm_proxy,
-                                 "UnregisterClient",
-                                 &error,
-                                 DBUS_TYPE_G_OBJECT_PATH, client_id,
-                                 G_TYPE_INVALID,
-                                 G_TYPE_INVALID);
-        if (! res) {
-                g_warning ("Failed to unregister client: %s", error->message);
-                g_error_free (error);
-                return FALSE;
-        }
-
-        g_free (client_id);
-        client_id = NULL;
-
-        return TRUE;
-}
-
-static gboolean
-quit_test (gpointer data)
-{
-        g_main_loop_quit (main_loop);
-        return FALSE;
-}
-
-int
-main (int   argc,
-      char *argv[])
-{
-        gboolean res;
-
-        g_log_set_always_fatal (G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING);
-
-        res = session_manager_connect ();
-        if (! res) {
-                g_warning ("Unable to connect to session manager");
-                exit (1);
-        }
-
-        res = register_client ();
-        if (! res) {
-                g_warning ("Unable to register client with session manager");
-        }
-
-        main_loop = g_main_loop_new (NULL, FALSE);
-
-        g_timeout_add_seconds (30, quit_test, NULL);
-
-        g_main_loop_run (main_loop);
-        g_main_loop_unref (main_loop);
-
-        unregister_client ();
-        session_manager_disconnect ();
-
-        return 0;
-}
diff --git a/gnome-session/test-inhibit.c b/gnome-session/test-inhibit.c
deleted file mode 100644
index 4b5228b..0000000
--- a/gnome-session/test-inhibit.c
+++ /dev/null
@@ -1,196 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2008 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- *
- */
-
-#include "config.h"
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-
-#include <gtk/gtk.h>
-#include <gdk/gdkx.h>
-#include <dbus/dbus-glib.h>
-
-#define SM_DBUS_NAME      "org.gnome.SessionManager"
-#define SM_DBUS_PATH      "/org/gnome/SessionManager"
-#define SM_DBUS_INTERFACE "org.gnome.SessionManager"
-
-static DBusGConnection *bus_connection = NULL;
-static DBusGProxy      *sm_proxy = NULL;
-static guint            cookie = 0;
-
-static gboolean
-session_manager_connect (void)
-{
-
-        if (bus_connection == NULL) {
-                GError *error;
-
-                error = NULL;
-                bus_connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
-                if (bus_connection == NULL) {
-                        g_message ("Failed to connect to the session bus: %s",
-                                   error->message);
-                        g_error_free (error);
-                        exit (1);
-                }
-        }
-
-        sm_proxy = dbus_g_proxy_new_for_name (bus_connection,
-                                              SM_DBUS_NAME,
-                                              SM_DBUS_PATH,
-                                              SM_DBUS_INTERFACE);
-        return (sm_proxy != NULL);
-}
-
-typedef enum {
-        GSM_INHIBITOR_FLAG_LOGOUT      = 1 << 0,
-        GSM_INHIBITOR_FLAG_SWITCH_USER = 1 << 1,
-        GSM_INHIBITOR_FLAG_SUSPEND     = 1 << 2
-} GsmInhibitFlag;
-
-static gboolean
-do_inhibit_for_window (GdkWindow *window)
-{
-        GError     *error;
-        gboolean    res;
-        const char *app_id;
-        const char *reason;
-        guint       toplevel_xid;
-        guint       flags;
-
-#if 1
-        app_id = "nautilus-cd-burner";
-        reason = "A CD burn is in progress.";
-#else
-        app_id = "nautilus";
-        reason = "A file transfer is in progress.";
-#endif
-        toplevel_xid = gdk_x11_window_get_xid (window);
-        flags = GSM_INHIBITOR_FLAG_LOGOUT
-                | GSM_INHIBITOR_FLAG_SWITCH_USER
-                | GSM_INHIBITOR_FLAG_SUSPEND;
-
-        error = NULL;
-        res = dbus_g_proxy_call (sm_proxy,
-                                 "Inhibit",
-                                 &error,
-                                 G_TYPE_STRING, app_id,
-                                 G_TYPE_UINT, toplevel_xid,
-                                 G_TYPE_STRING, reason,
-                                 G_TYPE_UINT, flags,
-                                 G_TYPE_INVALID,
-                                 G_TYPE_UINT, &cookie,
-                                 G_TYPE_INVALID);
-        if (! res) {
-                g_warning ("Failed to inhibit: %s", error->message);
-                g_error_free (error);
-                return FALSE;
-        }
-
-        g_debug ("Inhibiting session manager: %u", cookie);
-
-        return TRUE;
-}
-static gboolean
-session_manager_disconnect (void)
-{
-        if (sm_proxy != NULL) {
-                g_object_unref (sm_proxy);
-                sm_proxy = NULL;
-        }
-
-        return TRUE;
-}
-
-static gboolean
-do_uninhibit (void)
-{
-        GError  *error;
-        gboolean res;
-
-        error = NULL;
-        res = dbus_g_proxy_call (sm_proxy,
-                                 "Uninhibit",
-                                 &error,
-                                 G_TYPE_UINT, cookie,
-                                 G_TYPE_INVALID,
-                                 G_TYPE_INVALID);
-        if (! res) {
-                g_warning ("Failed to uninhibit: %s", error->message);
-                g_error_free (error);
-                return FALSE;
-        }
-
-        cookie = 0;
-
-        return TRUE;
-}
-
-static void
-on_widget_show (GtkWidget *dialog,
-                gpointer   data)
-{
-        gboolean res;
-
-        res = do_inhibit_for_window (gtk_widget_get_window (dialog));
-        if (! res) {
-                g_warning ("Unable to register client with session manager");
-        }
-}
-
-int
-main (int   argc,
-      char *argv[])
-{
-        gboolean   res;
-        GtkWidget *dialog;
-
-        g_log_set_always_fatal (G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING);
-
-        gtk_init (&argc, &argv);
-
-        res = session_manager_connect ();
-        if (! res) {
-                g_warning ("Unable to connect to session manager");
-                exit (1);
-        }
-
-        g_timeout_add_seconds (30, (GSourceFunc)gtk_main_quit, NULL);
-
-        dialog = gtk_message_dialog_new (NULL,
-                                         0,
-                                         GTK_MESSAGE_INFO,
-                                         GTK_BUTTONS_CANCEL,
-                                         "Inhibiting logout, switch user, and suspend.");
-
-        g_signal_connect (dialog, "response", G_CALLBACK (gtk_main_quit), NULL);
-        g_signal_connect (dialog, "show", G_CALLBACK (on_widget_show), NULL);
-        gtk_widget_show (dialog);
-
-        gtk_main ();
-
-        do_uninhibit ();
-        session_manager_disconnect ();
-
-        return 0;
-}
diff --git a/gnome-session/test-process-helper.c b/gnome-session/test-process-helper.c
deleted file mode 100644
index 7fe9216..0000000
--- a/gnome-session/test-process-helper.c
+++ /dev/null
@@ -1,58 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2010 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- *
- */
-
-#include <config.h>
-
-#include <stdlib.h>
-
-#include "gsm-process-helper.h"
-
-int
-main (int   argc,
-      char *argv[])
-{
-        char *command_line = "xeyes";
-        int   timeout = 500;
-        GError *error = NULL;
-
-        if (argc > 3) {
-                g_printerr ("Too many arguments.\n");
-                g_printerr ("Usage: %s [COMMAND] [TIMEOUT]\n", argv[0]);
-                return 1;
-        }
-
-        if (argc >= 2)
-                command_line = argv[1];
-        if (argc >= 3) {
-                int i = atoi (argv[2]);
-                if (i > 0)
-                        timeout = i;
-        }
-
-        if (!gsm_process_helper (command_line, timeout, &error)) {
-                g_warning ("%s", error->message);
-                g_clear_error (&error);
-        } else {
-                g_print ("Command exited successfully.\n");
-        }
-
-        return 0;
-}
diff --git a/po/POTFILES.in b/po/POTFILES.in
index bba5386..be21892 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -4,24 +4,6 @@ capplet/gsm-app-dialog.c
 capplet/gsm-properties-dialog.c
 capplet/gsp-app.c
 capplet/main.c
-data/gnome-custom-session.desktop.in
-data/gnome.desktop.in
-data/gnome-dummy.session.desktop.in.in
-data/gnome.session.desktop.in.in
 data/gnome-session-properties.desktop.in.in
-data/gnome-wayland.desktop.in
-data/gnome-wayland.session.desktop.in.in
-[type: gettext/glade]data/session-selector.ui
 [type: gettext/glade]data/session-properties.ui
-egg/eggdesktopfile.c
-egg/eggsmclient.c
-gnome-session/gsm-fail-whale-dialog.c
-gnome-session/gsm-manager.c
-gnome-session/gsm-process-helper.c
 gnome-session/gsm-util.c
-gnome-session/gsm-xsmp-client.c
-gnome-session/gsm-xsmp-server.c
-gnome-session/main.c
-tools/gnome-session-inhibit.c
-tools/gnome-session-selector.c
-tools/gnome-session-quit.c
diff --git a/po/POTFILES.skip b/po/POTFILES.skip
index c5d4ac9..0cbc4a7 100644
--- a/po/POTFILES.skip
+++ b/po/POTFILES.skip
@@ -1,9 +1,4 @@
 # List of source files containing translatable strings that should not be
 # translated.
 # Please keep this file sorted alphabetically.
-data/gnome-dummy.session.desktop.in
-data/gnome.session.desktop.in
 data/gnome-session-properties.desktop.in
-data/gnome-session.schemas.in
-data/gnome-wayland.session.desktop.in
-data/gnome-wm.desktop.in
diff --git a/tools/Makefile.am b/tools/Makefile.am
deleted file mode 100644
index 57b82c7..0000000
--- a/tools/Makefile.am
+++ /dev/null
@@ -1,85 +0,0 @@
-bin_PROGRAMS = gnome-session-quit gnome-session-inhibit
-libexec_PROGRAMS = gnome-session-check-accelerated gnome-session-check-accelerated-helper
-
-if BUILD_SESSION_SELECTOR
-bin_PROGRAMS += gnome-session-selector
-dist_bin_SCRIPTS = gnome-session-custom-session
-endif
-
-AM_CPPFLAGS =
-
-AM_CFLAGS = $(WARN_CFLAGS)
-
-gnome_session_quit_SOURCES =			\
-	gnome-session-quit.c
-
-gnome_session_quit_CPPFLAGS =			\
-	$(AM_CPPFLAGS)				\
-	$(GNOME_SESSION_CFLAGS)			\
-	$(DBUS_GLIB_CFLAGS)			\
-	$(GCONF_FLAGS)				\
-	-DLOCALE_DIR=\""$(datadir)/locale"\"	\
-	$(DISABLE_DEPRECATED_CFLAGS)
-
-gnome_session_quit_LDADD =			\
-	$(SM_LIBS)				\
-	$(ICE_LIBS)				\
-	$(GNOME_SESSION_LIBS)			\
-	$(DBUS_GLIB_LIBS)			\
-	$(GCONF_LIBS)
-
-gnome_session_inhibit_SOURCES =			\
-	gnome-session-inhibit.c
-
-gnome_session_inhibit_CPPFLAGS =		\
-	-I$(top_srcdir)/			\
-	$(AM_CPPFLAGS)				\
-	$(GNOME_SESSION_CFLAGS)			\
-	-DLOCALE_DIR=\""$(datadir)/locale"\"	\
-	$(DISABLE_DEPRECATED_CFLAGS)
-
-gnome_session_inhibit_LDADD =			\
-	$(GNOME_SESSION_LIBS)
-
-gnome_session_check_accelerated_helper_SOURCES = 		\
-	gnome-session-check-accelerated-common.h		\
-	gnome-session-check-accelerated-helper.c
-
-gnome_session_check_accelerated_helper_CPPFLAGS =	\
-	-DPKGDATADIR=\""$(pkgdatadir)"\"		\
-	$(GL_TEST_CFLAGS)
-
-gnome_session_check_accelerated_helper_LDADD = 		\
-	$(GL_TEST_LIBS)				\
-	$(X11_LIBS)
-
-gnome_session_check_accelerated_SOURCES =       	\
-	gnome-session-check-accelerated-common.h	\
-	gnome-session-check-accelerated.c
-
-gnome_session_check_accelerated_CPPFLAGS =      \
-	-DLIBEXECDIR=\""$(libexecdir)"\"	\
-	$(AM_CPPFLAGS)			        \
-	$(GTK3_CFLAGS)
-
-gnome_session_check_accelerated_LDADD =         \
-	$(GTK3_LIBS)				\
-	$(X11_LIBS)
-
-if BUILD_SESSION_SELECTOR
-gnome_session_selector_CPPFLAGS =		\
-	$(AM_CPPFLAGS)				\
-	$(GNOME_SESSION_CFLAGS)			\
-	$(DBUS_GLIB_CFLAGS)			\
-	-DGTKBUILDER_DIR=\""$(pkgdatadir)"\"	\
-	-DLOCALE_DIR=\""$(datadir)/locale"\"	\
-	$(DISABLE_DEPRECATED_CFLAGS)
-
-gnome_session_selector_LDADD = 			\
-	$(SESSION_SELECTOR_LIBS)
-
-gnome_session_selector_SOURCES = 		\
-	gnome-session-selector.c
-endif
-
--include $(top_srcdir)/git.mk
diff --git a/tools/Makefile.in b/tools/Makefile.in
deleted file mode 100644
index f52ebac..0000000
--- a/tools/Makefile.in
+++ /dev/null
@@ -1,1011 +0,0 @@
-# Makefile.in generated by automake 1.13.4 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
-
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-@SET_MAKE@
-
-
-VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
-am__make_running_with_option = \
-  case $${target_option-} in \
-      ?) ;; \
-      *) echo "am__make_running_with_option: internal error: invalid" \
-              "target option '$${target_option-}' specified" >&2; \
-         exit 1;; \
-  esac; \
-  has_opt=no; \
-  sane_makeflags=$$MAKEFLAGS; \
-  if $(am__is_gnu_make); then \
-    sane_makeflags=$$MFLAGS; \
-  else \
-    case $$MAKEFLAGS in \
-      *\\[\ \	]*) \
-        bs=\\; \
-        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
-          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
-    esac; \
-  fi; \
-  skip_next=no; \
-  strip_trailopt () \
-  { \
-    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
-  }; \
-  for flg in $$sane_makeflags; do \
-    test $$skip_next = yes && { skip_next=no; continue; }; \
-    case $$flg in \
-      *=*|--*) continue;; \
-        -*I) strip_trailopt 'I'; skip_next=yes;; \
-      -*I?*) strip_trailopt 'I';; \
-        -*O) strip_trailopt 'O'; skip_next=yes;; \
-      -*O?*) strip_trailopt 'O';; \
-        -*l) strip_trailopt 'l'; skip_next=yes;; \
-      -*l?*) strip_trailopt 'l';; \
-      -[dEDm]) skip_next=yes;; \
-      -[JT]) skip_next=yes;; \
-    esac; \
-    case $$flg in \
-      *$$target_option*) has_opt=yes; break;; \
-    esac; \
-  done; \
-  test $$has_opt = yes
-am__make_dryrun = (target_option=n; $(am__make_running_with_option))
-am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
-pkgdatadir = $(datadir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkglibexecdir = $(libexecdir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-bin_PROGRAMS = gnome-session-quit$(EXEEXT) \
-	gnome-session-inhibit$(EXEEXT) $(am__EXEEXT_1)
-libexec_PROGRAMS = gnome-session-check-accelerated$(EXEEXT) \
-	gnome-session-check-accelerated-helper$(EXEEXT)
-@BUILD_SESSION_SELECTOR_TRUE@am__append_1 = gnome-session-selector
-subdir = tools
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
-	$(am__dist_bin_SCRIPTS_DIST) $(top_srcdir)/depcomp
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/intltool.m4 \
-	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
-	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
-	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-CONFIG_CLEAN_VPATH_FILES =
-@BUILD_SESSION_SELECTOR_TRUE@am__EXEEXT_1 =  \
-@BUILD_SESSION_SELECTOR_TRUE@	gnome-session-selector$(EXEEXT)
-am__installdirs = "$(DESTDIR)$(bindir)" "$(DESTDIR)$(libexecdir)" \
-	"$(DESTDIR)$(bindir)"
-PROGRAMS = $(bin_PROGRAMS) $(libexec_PROGRAMS)
-am_gnome_session_check_accelerated_OBJECTS = gnome_session_check_accelerated-gnome-session-check-accelerated.$(OBJEXT)
-gnome_session_check_accelerated_OBJECTS =  \
-	$(am_gnome_session_check_accelerated_OBJECTS)
-am__DEPENDENCIES_1 =
-gnome_session_check_accelerated_DEPENDENCIES = $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1)
-AM_V_lt = $(am__v_lt_@AM_V@)
-am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
-am__v_lt_0 = --silent
-am__v_lt_1 = 
-am_gnome_session_check_accelerated_helper_OBJECTS = gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.$(OBJEXT)
-gnome_session_check_accelerated_helper_OBJECTS =  \
-	$(am_gnome_session_check_accelerated_helper_OBJECTS)
-gnome_session_check_accelerated_helper_DEPENDENCIES =  \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
-am_gnome_session_inhibit_OBJECTS =  \
-	gnome_session_inhibit-gnome-session-inhibit.$(OBJEXT)
-gnome_session_inhibit_OBJECTS = $(am_gnome_session_inhibit_OBJECTS)
-gnome_session_inhibit_DEPENDENCIES = $(am__DEPENDENCIES_1)
-am_gnome_session_quit_OBJECTS =  \
-	gnome_session_quit-gnome-session-quit.$(OBJEXT)
-gnome_session_quit_OBJECTS = $(am_gnome_session_quit_OBJECTS)
-gnome_session_quit_DEPENDENCIES = $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
-am__gnome_session_selector_SOURCES_DIST = gnome-session-selector.c
-@BUILD_SESSION_SELECTOR_TRUE@am_gnome_session_selector_OBJECTS = gnome_session_selector-gnome-session-selector.$(OBJEXT)
-gnome_session_selector_OBJECTS = $(am_gnome_session_selector_OBJECTS)
-@BUILD_SESSION_SELECTOR_TRUE@gnome_session_selector_DEPENDENCIES =  \
-@BUILD_SESSION_SELECTOR_TRUE@	$(am__DEPENDENCIES_1)
-am__dist_bin_SCRIPTS_DIST = gnome-session-custom-session
-am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
-am__vpath_adj = case $$p in \
-    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
-    *) f=$$p;; \
-  esac;
-am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
-am__install_max = 40
-am__nobase_strip_setup = \
-  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
-am__nobase_strip = \
-  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
-am__nobase_list = $(am__nobase_strip_setup); \
-  for p in $$list; do echo "$$p $$p"; done | \
-  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
-  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
-    if (++n[$$2] == $(am__install_max)) \
-      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
-    END { for (dir in files) print dir, files[dir] }'
-am__base_list = \
-  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
-  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
-am__uninstall_files_from_dir = { \
-  test -z "$$files" \
-    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
-    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
-         $(am__cd) "$$dir" && rm -f $$files; }; \
-  }
-SCRIPTS = $(dist_bin_SCRIPTS)
-AM_V_P = $(am__v_P_@AM_V@)
-am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
-am__v_P_0 = false
-am__v_P_1 = :
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN     " $@;
-am__v_GEN_1 = 
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
-am__v_at_1 = 
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
-depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__depfiles_maybe = depfiles
-am__mv = mv -f
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
-	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
-	$(AM_CFLAGS) $(CFLAGS)
-AM_V_CC = $(am__v_CC_@AM_V@)
-am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
-am__v_CC_0 = @echo "  CC      " $@;
-am__v_CC_1 = 
-CCLD = $(CC)
-LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(AM_LDFLAGS) $(LDFLAGS) -o $@
-AM_V_CCLD = $(am__v_CCLD_@AM_V@)
-am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
-am__v_CCLD_0 = @echo "  CCLD    " $@;
-am__v_CCLD_1 = 
-SOURCES = $(gnome_session_check_accelerated_SOURCES) \
-	$(gnome_session_check_accelerated_helper_SOURCES) \
-	$(gnome_session_inhibit_SOURCES) $(gnome_session_quit_SOURCES) \
-	$(gnome_session_selector_SOURCES)
-DIST_SOURCES = $(gnome_session_check_accelerated_SOURCES) \
-	$(gnome_session_check_accelerated_helper_SOURCES) \
-	$(gnome_session_inhibit_SOURCES) $(gnome_session_quit_SOURCES) \
-	$(am__gnome_session_selector_SOURCES_DIST)
-am__can_run_installinfo = \
-  case $$AM_UPDATE_INFO_DIR in \
-    n|no|NO) false;; \
-    *) (install-info --version) >/dev/null 2>&1;; \
-  esac
-am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
-# Read a list of newline-separated strings from the standard input,
-# and print each of them once, without duplicates.  Input order is
-# *not* preserved.
-am__uniquify_input = $(AWK) '\
-  BEGIN { nonempty = 0; } \
-  { items[$$0] = 1; nonempty = 1; } \
-  END { if (nonempty) { for (i in items) print i; }; } \
-'
-# Make sure the list of sources is unique.  This is necessary because,
-# e.g., the same source file might be shared among _SOURCES variables
-# for different programs/libraries.
-am__define_uniq_tagged_files = \
-  list='$(am__tagged_files)'; \
-  unique=`for i in $$list; do \
-    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-  done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = @ACLOCAL@
-ALL_LINGUAS = @ALL_LINGUAS@
-AMTAR = @AMTAR@
-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
-AR = @AR@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CATALOGS = @CATALOGS@
-CATOBJEXT = @CATOBJEXT@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFLAGS = @CFLAGS@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DATADIRNAME = @DATADIRNAME@
-DBUS_GLIB_CFLAGS = @DBUS_GLIB_CFLAGS@
-DBUS_GLIB_LIBS = @DBUS_GLIB_LIBS@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DISABLE_DEPRECATED = @DISABLE_DEPRECATED@
-DISABLE_DEPRECATED_CFLAGS = @DISABLE_DEPRECATED_CFLAGS@
-DLLTOOL = @DLLTOOL@
-DSYMUTIL = @DSYMUTIL@
-DUMPBIN = @DUMPBIN@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGG_SMCLIENT_CFLAGS = @EGG_SMCLIENT_CFLAGS@
-EGG_SMCLIENT_LIBS = @EGG_SMCLIENT_LIBS@
-EGREP = @EGREP@
-EXECINFO_LIBS = @EXECINFO_LIBS@
-EXEEXT = @EXEEXT@
-FGREP = @FGREP@
-GCONF_CFLAGS = @GCONF_CFLAGS@
-GCONF_LIBS = @GCONF_LIBS@
-GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
-GIOUNIX_CFLAGS = @GIOUNIX_CFLAGS@
-GIOUNIX_LIBS = @GIOUNIX_LIBS@
-GIO_CFLAGS = @GIO_CFLAGS@
-GIO_LIBS = @GIO_LIBS@
-GLIB_COMPILE_SCHEMAS = @GLIB_COMPILE_SCHEMAS@
-GLIB_GENMARSHAL = @GLIB_GENMARSHAL@
-GL_TEST_CFLAGS = @GL_TEST_CFLAGS@
-GL_TEST_LIBS = @GL_TEST_LIBS@
-GMOFILES = @GMOFILES@
-GMSGFMT = @GMSGFMT@
-GNOME_SESSION_CFLAGS = @GNOME_SESSION_CFLAGS@
-GNOME_SESSION_LIBS = @GNOME_SESSION_LIBS@
-GREP = @GREP@
-GSETTINGS_DISABLE_SCHEMAS_COMPILE = @GSETTINGS_DISABLE_SCHEMAS_COMPILE@
-GTK3_CFLAGS = @GTK3_CFLAGS@
-GTK3_LIBS = @GTK3_LIBS@
-HAVE_XRENDER = @HAVE_XRENDER@
-HAVE_XTEST = @HAVE_XTEST@
-ICE_CFLAGS = @ICE_CFLAGS@
-ICE_LIBS = @ICE_LIBS@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-INSTOBJEXT = @INSTOBJEXT@
-INTLLIBS = @INTLLIBS@
-INTLTOOL_EXTRACT = @INTLTOOL_EXTRACT@
-INTLTOOL_MERGE = @INTLTOOL_MERGE@
-INTLTOOL_PERL = @INTLTOOL_PERL@
-INTLTOOL_UPDATE = @INTLTOOL_UPDATE@
-INTLTOOL_V_MERGE = @INTLTOOL_V_MERGE@
-INTLTOOL_V_MERGE_OPTIONS = @INTLTOOL_V_MERGE_OPTIONS@
-INTLTOOL__v_MERGE_ = @INTLTOOL__v_MERGE_@
-INTLTOOL__v_MERGE_0 = @INTLTOOL__v_MERGE_0@
-LD = @LD@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LIPO = @LIPO@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAINT = @MAINT@
-MAKEINFO = @MAKEINFO@
-MANIFEST_TOOL = @MANIFEST_TOOL@
-MKDIR_P = @MKDIR_P@
-MKINSTALLDIRS = @MKINSTALLDIRS@
-MSGFMT = @MSGFMT@
-MSGFMT_OPTS = @MSGFMT_OPTS@
-MSGMERGE = @MSGMERGE@
-NM = @NM@
-NMEDIT = @NMEDIT@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-OTOOL = @OTOOL@
-OTOOL64 = @OTOOL64@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_URL = @PACKAGE_URL@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PKG_CONFIG = @PKG_CONFIG@
-PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
-PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
-POFILES = @POFILES@
-POSUB = @POSUB@
-PO_IN_DATADIR_FALSE = @PO_IN_DATADIR_FALSE@
-PO_IN_DATADIR_TRUE = @PO_IN_DATADIR_TRUE@
-RANLIB = @RANLIB@
-SED = @SED@
-SESSION_PROPERTIES_CFLAGS = @SESSION_PROPERTIES_CFLAGS@
-SESSION_PROPERTIES_LIBS = @SESSION_PROPERTIES_LIBS@
-SESSION_SELECTOR_CFLAGS = @SESSION_SELECTOR_CFLAGS@
-SESSION_SELECTOR_LIBS = @SESSION_SELECTOR_LIBS@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-SM_CFLAGS = @SM_CFLAGS@
-SM_LIBS = @SM_LIBS@
-STRIP = @STRIP@
-SYSTEMD_CFLAGS = @SYSTEMD_CFLAGS@
-SYSTEMD_LIBS = @SYSTEMD_LIBS@
-USE_NLS = @USE_NLS@
-VERSION = @VERSION@
-WARN_CFLAGS = @WARN_CFLAGS@
-X11_CFLAGS = @X11_CFLAGS@
-X11_LIBS = @X11_LIBS@
-XEXT_CFLAGS = @XEXT_CFLAGS@
-XEXT_LIBS = @XEXT_LIBS@
-XGETTEXT = @XGETTEXT@
-XMLTO = @XMLTO@
-XRENDER_CFLAGS = @XRENDER_CFLAGS@
-XRENDER_LIBS = @XRENDER_LIBS@
-XSLTPROC = @XSLTPROC@
-XTEST_CFLAGS = @XTEST_CFLAGS@
-XTEST_LIBS = @XTEST_LIBS@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_AR = @ac_ct_AR@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-gsettingsschemadir = @gsettingsschemadir@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-intltool__v_merge_options_ = @intltool__v_merge_options_@
-intltool__v_merge_options_0 = @intltool__v_merge_options_0@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target_alias = @target_alias@
-top_build_prefix = @top_build_prefix@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-@BUILD_SESSION_SELECTOR_TRUE@dist_bin_SCRIPTS = gnome-session-custom-session
-AM_CPPFLAGS = 
-AM_CFLAGS = $(WARN_CFLAGS)
-gnome_session_quit_SOURCES = \
-	gnome-session-quit.c
-
-gnome_session_quit_CPPFLAGS = \
-	$(AM_CPPFLAGS)				\
-	$(GNOME_SESSION_CFLAGS)			\
-	$(DBUS_GLIB_CFLAGS)			\
-	$(GCONF_FLAGS)				\
-	-DLOCALE_DIR=\""$(datadir)/locale"\"	\
-	$(DISABLE_DEPRECATED_CFLAGS)
-
-gnome_session_quit_LDADD = \
-	$(SM_LIBS)				\
-	$(ICE_LIBS)				\
-	$(GNOME_SESSION_LIBS)			\
-	$(DBUS_GLIB_LIBS)			\
-	$(GCONF_LIBS)
-
-gnome_session_inhibit_SOURCES = \
-	gnome-session-inhibit.c
-
-gnome_session_inhibit_CPPFLAGS = \
-	-I$(top_srcdir)/			\
-	$(AM_CPPFLAGS)				\
-	$(GNOME_SESSION_CFLAGS)			\
-	-DLOCALE_DIR=\""$(datadir)/locale"\"	\
-	$(DISABLE_DEPRECATED_CFLAGS)
-
-gnome_session_inhibit_LDADD = \
-	$(GNOME_SESSION_LIBS)
-
-gnome_session_check_accelerated_helper_SOURCES = \
-	gnome-session-check-accelerated-common.h		\
-	gnome-session-check-accelerated-helper.c
-
-gnome_session_check_accelerated_helper_CPPFLAGS = \
-	-DPKGDATADIR=\""$(pkgdatadir)"\"		\
-	$(GL_TEST_CFLAGS)
-
-gnome_session_check_accelerated_helper_LDADD = \
-	$(GL_TEST_LIBS)				\
-	$(X11_LIBS)
-
-gnome_session_check_accelerated_SOURCES = \
-	gnome-session-check-accelerated-common.h	\
-	gnome-session-check-accelerated.c
-
-gnome_session_check_accelerated_CPPFLAGS = \
-	-DLIBEXECDIR=\""$(libexecdir)"\"	\
-	$(AM_CPPFLAGS)			        \
-	$(GTK3_CFLAGS)
-
-gnome_session_check_accelerated_LDADD = \
-	$(GTK3_LIBS)				\
-	$(X11_LIBS)
-
-@BUILD_SESSION_SELECTOR_TRUE@gnome_session_selector_CPPFLAGS = \
-@BUILD_SESSION_SELECTOR_TRUE@	$(AM_CPPFLAGS)				\
-@BUILD_SESSION_SELECTOR_TRUE@	$(GNOME_SESSION_CFLAGS)			\
-@BUILD_SESSION_SELECTOR_TRUE@	$(DBUS_GLIB_CFLAGS)			\
-@BUILD_SESSION_SELECTOR_TRUE@	-DGTKBUILDER_DIR=\""$(pkgdatadir)"\"	\
-@BUILD_SESSION_SELECTOR_TRUE@	-DLOCALE_DIR=\""$(datadir)/locale"\"	\
-@BUILD_SESSION_SELECTOR_TRUE@	$(DISABLE_DEPRECATED_CFLAGS)
-
-@BUILD_SESSION_SELECTOR_TRUE@gnome_session_selector_LDADD = \
-@BUILD_SESSION_SELECTOR_TRUE@	$(SESSION_SELECTOR_LIBS)
-
-@BUILD_SESSION_SELECTOR_TRUE@gnome_session_selector_SOURCES = \
-@BUILD_SESSION_SELECTOR_TRUE@	gnome-session-selector.c
-
-all: all-am
-
-.SUFFIXES:
-.SUFFIXES: .c .lo .o .obj
-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
-	        && { if test -f $@; then exit 0; else break; fi; }; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu tools/Makefile'; \
-	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --gnu tools/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(am__aclocal_m4_deps):
-install-binPROGRAMS: $(bin_PROGRAMS)
-	@$(NORMAL_INSTALL)
-	@list='$(bin_PROGRAMS)'; test -n "$(bindir)" || list=; \
-	if test -n "$$list"; then \
-	  echo " $(MKDIR_P) '$(DESTDIR)$(bindir)'"; \
-	  $(MKDIR_P) "$(DESTDIR)$(bindir)" || exit 1; \
-	fi; \
-	for p in $$list; do echo "$$p $$p"; done | \
-	sed 's/$(EXEEXT)$$//' | \
-	while read p p1; do if test -f $$p \
-	 || test -f $$p1 \
-	  ; then echo "$$p"; echo "$$p"; else :; fi; \
-	done | \
-	sed -e 'p;s,.*/,,;n;h' \
-	    -e 's|.*|.|' \
-	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
-	sed 'N;N;N;s,\n, ,g' | \
-	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \
-	  { d=$$3; if (dirs[d] != 1) { print "d", d; dirs[d] = 1 } \
-	    if ($$2 == $$4) files[d] = files[d] " " $$1; \
-	    else { print "f", $$3 "/" $$4, $$1; } } \
-	  END { for (d in files) print "f", d, files[d] }' | \
-	while read type dir files; do \
-	    if test "$$dir" = .; then dir=; else dir=/$$dir; fi; \
-	    test -z "$$files" || { \
-	    echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files '$(DESTDIR)$(bindir)$$dir'"; \
-	    $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files "$(DESTDIR)$(bindir)$$dir" || exit $$?; \
-	    } \
-	; done
-
-uninstall-binPROGRAMS:
-	@$(NORMAL_UNINSTALL)
-	@list='$(bin_PROGRAMS)'; test -n "$(bindir)" || list=; \
-	files=`for p in $$list; do echo "$$p"; done | \
-	  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \
-	      -e 's/$$/$(EXEEXT)/' \
-	`; \
-	test -n "$$list" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(bindir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(bindir)" && rm -f $$files
-
-clean-binPROGRAMS:
-	@list='$(bin_PROGRAMS)'; test -n "$$list" || exit 0; \
-	echo " rm -f" $$list; \
-	rm -f $$list || exit $$?; \
-	test -n "$(EXEEXT)" || exit 0; \
-	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
-	echo " rm -f" $$list; \
-	rm -f $$list
-install-libexecPROGRAMS: $(libexec_PROGRAMS)
-	@$(NORMAL_INSTALL)
-	@list='$(libexec_PROGRAMS)'; test -n "$(libexecdir)" || list=; \
-	if test -n "$$list"; then \
-	  echo " $(MKDIR_P) '$(DESTDIR)$(libexecdir)'"; \
-	  $(MKDIR_P) "$(DESTDIR)$(libexecdir)" || exit 1; \
-	fi; \
-	for p in $$list; do echo "$$p $$p"; done | \
-	sed 's/$(EXEEXT)$$//' | \
-	while read p p1; do if test -f $$p \
-	 || test -f $$p1 \
-	  ; then echo "$$p"; echo "$$p"; else :; fi; \
-	done | \
-	sed -e 'p;s,.*/,,;n;h' \
-	    -e 's|.*|.|' \
-	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
-	sed 'N;N;N;s,\n, ,g' | \
-	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \
-	  { d=$$3; if (dirs[d] != 1) { print "d", d; dirs[d] = 1 } \
-	    if ($$2 == $$4) files[d] = files[d] " " $$1; \
-	    else { print "f", $$3 "/" $$4, $$1; } } \
-	  END { for (d in files) print "f", d, files[d] }' | \
-	while read type dir files; do \
-	    if test "$$dir" = .; then dir=; else dir=/$$dir; fi; \
-	    test -z "$$files" || { \
-	    echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files '$(DESTDIR)$(libexecdir)$$dir'"; \
-	    $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files "$(DESTDIR)$(libexecdir)$$dir" || exit $$?; \
-	    } \
-	; done
-
-uninstall-libexecPROGRAMS:
-	@$(NORMAL_UNINSTALL)
-	@list='$(libexec_PROGRAMS)'; test -n "$(libexecdir)" || list=; \
-	files=`for p in $$list; do echo "$$p"; done | \
-	  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \
-	      -e 's/$$/$(EXEEXT)/' \
-	`; \
-	test -n "$$list" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(libexecdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(libexecdir)" && rm -f $$files
-
-clean-libexecPROGRAMS:
-	@list='$(libexec_PROGRAMS)'; test -n "$$list" || exit 0; \
-	echo " rm -f" $$list; \
-	rm -f $$list || exit $$?; \
-	test -n "$(EXEEXT)" || exit 0; \
-	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
-	echo " rm -f" $$list; \
-	rm -f $$list
-
-gnome-session-check-accelerated$(EXEEXT): $(gnome_session_check_accelerated_OBJECTS) $(gnome_session_check_accelerated_DEPENDENCIES) $(EXTRA_gnome_session_check_accelerated_DEPENDENCIES) 
-	@rm -f gnome-session-check-accelerated$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(gnome_session_check_accelerated_OBJECTS) $(gnome_session_check_accelerated_LDADD) $(LIBS)
-
-gnome-session-check-accelerated-helper$(EXEEXT): $(gnome_session_check_accelerated_helper_OBJECTS) $(gnome_session_check_accelerated_helper_DEPENDENCIES) $(EXTRA_gnome_session_check_accelerated_helper_DEPENDENCIES) 
-	@rm -f gnome-session-check-accelerated-helper$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(gnome_session_check_accelerated_helper_OBJECTS) $(gnome_session_check_accelerated_helper_LDADD) $(LIBS)
-
-gnome-session-inhibit$(EXEEXT): $(gnome_session_inhibit_OBJECTS) $(gnome_session_inhibit_DEPENDENCIES) $(EXTRA_gnome_session_inhibit_DEPENDENCIES) 
-	@rm -f gnome-session-inhibit$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(gnome_session_inhibit_OBJECTS) $(gnome_session_inhibit_LDADD) $(LIBS)
-
-gnome-session-quit$(EXEEXT): $(gnome_session_quit_OBJECTS) $(gnome_session_quit_DEPENDENCIES) $(EXTRA_gnome_session_quit_DEPENDENCIES) 
-	@rm -f gnome-session-quit$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(gnome_session_quit_OBJECTS) $(gnome_session_quit_LDADD) $(LIBS)
-
-gnome-session-selector$(EXEEXT): $(gnome_session_selector_OBJECTS) $(gnome_session_selector_DEPENDENCIES) $(EXTRA_gnome_session_selector_DEPENDENCIES) 
-	@rm -f gnome-session-selector$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(gnome_session_selector_OBJECTS) $(gnome_session_selector_LDADD) $(LIBS)
-install-dist_binSCRIPTS: $(dist_bin_SCRIPTS)
-	@$(NORMAL_INSTALL)
-	@list='$(dist_bin_SCRIPTS)'; test -n "$(bindir)" || list=; \
-	if test -n "$$list"; then \
-	  echo " $(MKDIR_P) '$(DESTDIR)$(bindir)'"; \
-	  $(MKDIR_P) "$(DESTDIR)$(bindir)" || exit 1; \
-	fi; \
-	for p in $$list; do \
-	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
-	  if test -f "$$d$$p"; then echo "$$d$$p"; echo "$$p"; else :; fi; \
-	done | \
-	sed -e 'p;s,.*/,,;n' \
-	    -e 'h;s|.*|.|' \
-	    -e 'p;x;s,.*/,,;$(transform)' | sed 'N;N;N;s,\n, ,g' | \
-	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1; } \
-	  { d=$$3; if (dirs[d] != 1) { print "d", d; dirs[d] = 1 } \
-	    if ($$2 == $$4) { files[d] = files[d] " " $$1; \
-	      if (++n[d] == $(am__install_max)) { \
-		print "f", d, files[d]; n[d] = 0; files[d] = "" } } \
-	    else { print "f", d "/" $$4, $$1 } } \
-	  END { for (d in files) print "f", d, files[d] }' | \
-	while read type dir files; do \
-	     if test "$$dir" = .; then dir=; else dir=/$$dir; fi; \
-	     test -z "$$files" || { \
-	       echo " $(INSTALL_SCRIPT) $$files '$(DESTDIR)$(bindir)$$dir'"; \
-	       $(INSTALL_SCRIPT) $$files "$(DESTDIR)$(bindir)$$dir" || exit $$?; \
-	     } \
-	; done
-
-uninstall-dist_binSCRIPTS:
-	@$(NORMAL_UNINSTALL)
-	@list='$(dist_bin_SCRIPTS)'; test -n "$(bindir)" || exit 0; \
-	files=`for p in $$list; do echo "$$p"; done | \
-	       sed -e 's,.*/,,;$(transform)'`; \
-	dir='$(DESTDIR)$(bindir)'; $(am__uninstall_files_from_dir)
-
-mostlyclean-compile:
-	-rm -f *.$(OBJEXT)
-
-distclean-compile:
-	-rm -f *.tab.c
-
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_session_check_accelerated-gnome-session-check-accelerated.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_session_inhibit-gnome-session-inhibit.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_session_quit-gnome-session-quit.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_session_selector-gnome-session-selector.Po@am__quote@
-
-.c.o:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c $<
-
-.c.obj:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c `$(CYGPATH_W) '$<'`
-
-.c.lo:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o $@ $<
-
-gnome_session_check_accelerated-gnome-session-check-accelerated.o: gnome-session-check-accelerated.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_check_accelerated_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT gnome_session_check_accelerated-gnome-session-check-accelerated.o -MD -MP -MF $(DEPDIR)/gnome_session_check_accelerated-gnome-session-check-accelerated.Tpo -c -o gnome_session_check_accelerated-gnome-session-check-accelerated.o `test -f 'gnome-session-check-accelerated.c' || echo '$(srcdir)/'`gnome-session-check-accelerated.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/gnome_session_check_accelerated-gnome-session-check-accelerated.Tpo $(DEPDIR)/gnome_session_check_accelerated-gnome-session-check-accelerated.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='gnome-session-check-accelerated.c' object='gnome_session_check_accelerated-gnome-session-check-accelerated.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_check_accelerated_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o gnome_session_check_accelerated-gnome-session-check-accelerated.o `test -f 'gnome-session-check-accelerated.c' || echo '$(srcdir)/'`gnome-session-check-accelerated.c
-
-gnome_session_check_accelerated-gnome-session-check-accelerated.obj: gnome-session-check-accelerated.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_check_accelerated_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT gnome_session_check_accelerated-gnome-session-check-accelerated.obj -MD -MP -MF $(DEPDIR)/gnome_session_check_accelerated-gnome-session-check-accelerated.Tpo -c -o gnome_session_check_accelerated-gnome-session-check-accelerated.obj `if test -f 'gnome-session-check-accelerated.c'; then $(CYGPATH_W) 'gnome-session-check-accelerated.c'; else $(CYGPATH_W) '$(srcdir)/gnome-session-check-accelerated.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/gnome_session_check_accelerated-gnome-session-check-accelerated.Tpo $(DEPDIR)/gnome_session_check_accelerated-gnome-session-check-accelerated.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='gnome-session-check-accelerated.c' object='gnome_session_check_accelerated-gnome-session-check-accelerated.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_check_accelerated_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o gnome_session_check_accelerated-gnome-session-check-accelerated.obj `if test -f 'gnome-session-check-accelerated.c'; then $(CYGPATH_W) 'gnome-session-check-accelerated.c'; else $(CYGPATH_W) '$(srcdir)/gnome-session-check-accelerated.c'; fi`
-
-gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.o: gnome-session-check-accelerated-helper.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_check_accelerated_helper_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.o -MD -MP -MF $(DEPDIR)/gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.Tpo -c -o gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.o `test -f 'gnome-session-check-accelerated-helper.c' || echo '$(srcdir)/'`gnome-session-check-accelerated-helper.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.Tpo $(DEPDIR)/gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='gnome-session-check-accelerated-helper.c' object='gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_check_accelerated_helper_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.o `test -f 'gnome-session-check-accelerated-helper.c' || echo '$(srcdir)/'`gnome-session-check-accelerated-helper.c
-
-gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.obj: gnome-session-check-accelerated-helper.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_check_accelerated_helper_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.obj -MD -MP -MF $(DEPDIR)/gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.Tpo -c -o gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.obj `if test -f 'gnome-session-check-accelerated-helper.c'; then $(CYGPATH_W) 'gnome-session-check-accelerated-helper.c'; else $(CYGPATH_W) '$(srcdir)/gnome-session-check-accelerated-helper.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.Tpo $(DEPDIR)/gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='gnome-session-check-accelerated-helper.c' object='gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_check_accelerated_helper_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o gnome_session_check_accelerated_helper-gnome-session-check-accelerated-helper.obj `if test -f 'gnome-session-check-accelerated-helper.c'; then $(CYGPATH_W) 'gnome-session-check-accelerated-helper.c'; else $(CYGPATH_W) '$(srcdir)/gnome-session-check-accelerated-helper.c'; fi`
-
-gnome_session_inhibit-gnome-session-inhibit.o: gnome-session-inhibit.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_inhibit_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT gnome_session_inhibit-gnome-session-inhibit.o -MD -MP -MF $(DEPDIR)/gnome_session_inhibit-gnome-session-inhibit.Tpo -c -o gnome_session_inhibit-gnome-session-inhibit.o `test -f 'gnome-session-inhibit.c' || echo '$(srcdir)/'`gnome-session-inhibit.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/gnome_session_inhibit-gnome-session-inhibit.Tpo $(DEPDIR)/gnome_session_inhibit-gnome-session-inhibit.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='gnome-session-inhibit.c' object='gnome_session_inhibit-gnome-session-inhibit.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_inhibit_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o gnome_session_inhibit-gnome-session-inhibit.o `test -f 'gnome-session-inhibit.c' || echo '$(srcdir)/'`gnome-session-inhibit.c
-
-gnome_session_inhibit-gnome-session-inhibit.obj: gnome-session-inhibit.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_inhibit_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT gnome_session_inhibit-gnome-session-inhibit.obj -MD -MP -MF $(DEPDIR)/gnome_session_inhibit-gnome-session-inhibit.Tpo -c -o gnome_session_inhibit-gnome-session-inhibit.obj `if test -f 'gnome-session-inhibit.c'; then $(CYGPATH_W) 'gnome-session-inhibit.c'; else $(CYGPATH_W) '$(srcdir)/gnome-session-inhibit.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/gnome_session_inhibit-gnome-session-inhibit.Tpo $(DEPDIR)/gnome_session_inhibit-gnome-session-inhibit.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='gnome-session-inhibit.c' object='gnome_session_inhibit-gnome-session-inhibit.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_inhibit_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o gnome_session_inhibit-gnome-session-inhibit.obj `if test -f 'gnome-session-inhibit.c'; then $(CYGPATH_W) 'gnome-session-inhibit.c'; else $(CYGPATH_W) '$(srcdir)/gnome-session-inhibit.c'; fi`
-
-gnome_session_quit-gnome-session-quit.o: gnome-session-quit.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_quit_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT gnome_session_quit-gnome-session-quit.o -MD -MP -MF $(DEPDIR)/gnome_session_quit-gnome-session-quit.Tpo -c -o gnome_session_quit-gnome-session-quit.o `test -f 'gnome-session-quit.c' || echo '$(srcdir)/'`gnome-session-quit.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/gnome_session_quit-gnome-session-quit.Tpo $(DEPDIR)/gnome_session_quit-gnome-session-quit.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='gnome-session-quit.c' object='gnome_session_quit-gnome-session-quit.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_quit_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o gnome_session_quit-gnome-session-quit.o `test -f 'gnome-session-quit.c' || echo '$(srcdir)/'`gnome-session-quit.c
-
-gnome_session_quit-gnome-session-quit.obj: gnome-session-quit.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_quit_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT gnome_session_quit-gnome-session-quit.obj -MD -MP -MF $(DEPDIR)/gnome_session_quit-gnome-session-quit.Tpo -c -o gnome_session_quit-gnome-session-quit.obj `if test -f 'gnome-session-quit.c'; then $(CYGPATH_W) 'gnome-session-quit.c'; else $(CYGPATH_W) '$(srcdir)/gnome-session-quit.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/gnome_session_quit-gnome-session-quit.Tpo $(DEPDIR)/gnome_session_quit-gnome-session-quit.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='gnome-session-quit.c' object='gnome_session_quit-gnome-session-quit.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_quit_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o gnome_session_quit-gnome-session-quit.obj `if test -f 'gnome-session-quit.c'; then $(CYGPATH_W) 'gnome-session-quit.c'; else $(CYGPATH_W) '$(srcdir)/gnome-session-quit.c'; fi`
-
-gnome_session_selector-gnome-session-selector.o: gnome-session-selector.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_selector_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT gnome_session_selector-gnome-session-selector.o -MD -MP -MF $(DEPDIR)/gnome_session_selector-gnome-session-selector.Tpo -c -o gnome_session_selector-gnome-session-selector.o `test -f 'gnome-session-selector.c' || echo '$(srcdir)/'`gnome-session-selector.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/gnome_session_selector-gnome-session-selector.Tpo $(DEPDIR)/gnome_session_selector-gnome-session-selector.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='gnome-session-selector.c' object='gnome_session_selector-gnome-session-selector.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_selector_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o gnome_session_selector-gnome-session-selector.o `test -f 'gnome-session-selector.c' || echo '$(srcdir)/'`gnome-session-selector.c
-
-gnome_session_selector-gnome-session-selector.obj: gnome-session-selector.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_selector_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT gnome_session_selector-gnome-session-selector.obj -MD -MP -MF $(DEPDIR)/gnome_session_selector-gnome-session-selector.Tpo -c -o gnome_session_selector-gnome-session-selector.obj `if test -f 'gnome-session-selector.c'; then $(CYGPATH_W) 'gnome-session-selector.c'; else $(CYGPATH_W) '$(srcdir)/gnome-session-selector.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/gnome_session_selector-gnome-session-selector.Tpo $(DEPDIR)/gnome_session_selector-gnome-session-selector.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='gnome-session-selector.c' object='gnome_session_selector-gnome-session-selector.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gnome_session_selector_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o gnome_session_selector-gnome-session-selector.obj `if test -f 'gnome-session-selector.c'; then $(CYGPATH_W) 'gnome-session-selector.c'; else $(CYGPATH_W) '$(srcdir)/gnome-session-selector.c'; fi`
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-ID: $(am__tagged_files)
-	$(am__define_uniq_tagged_files); mkid -fID $$unique
-tags: tags-am
-TAGS: tags
-
-tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
-	set x; \
-	here=`pwd`; \
-	$(am__define_uniq_tagged_files); \
-	shift; \
-	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  if test $$# -gt 0; then \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      "$$@" $$unique; \
-	  else \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      $$unique; \
-	  fi; \
-	fi
-ctags: ctags-am
-
-CTAGS: ctags
-ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
-	$(am__define_uniq_tagged_files); \
-	test -z "$(CTAGS_ARGS)$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && $(am__cd) $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) "$$here"
-cscopelist: cscopelist-am
-
-cscopelist-am: $(am__tagged_files)
-	list='$(am__tagged_files)'; \
-	case "$(srcdir)" in \
-	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
-	  *) sdir=$(subdir)/$(srcdir) ;; \
-	esac; \
-	for i in $$list; do \
-	  if test -f "$$i"; then \
-	    echo "$(subdir)/$$i"; \
-	  else \
-	    echo "$$sdir/$$i"; \
-	  fi; \
-	done >> $(top_builddir)/cscope.files
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
-	    if test -d "$(distdir)/$$file"; then \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
-	  else \
-	    test -f "$(distdir)/$$file" \
-	    || cp -p $$d/$$file "$(distdir)/$$file" \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-am
-all-am: Makefile $(PROGRAMS) $(SCRIPTS)
-installdirs:
-	for dir in "$(DESTDIR)$(bindir)" "$(DESTDIR)$(libexecdir)" "$(DESTDIR)$(bindir)"; do \
-	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
-	done
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	if test -z '$(STRIP)'; then \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	      install; \
-	else \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
-	fi
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am
-
-clean-am: clean-binPROGRAMS clean-generic clean-libexecPROGRAMS \
-	clean-libtool mostlyclean-am
-
-distclean: distclean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-tags
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-html-am:
-
-info: info-am
-
-info-am:
-
-install-data-am:
-
-install-dvi: install-dvi-am
-
-install-dvi-am:
-
-install-exec-am: install-binPROGRAMS install-dist_binSCRIPTS \
-	install-libexecPROGRAMS
-
-install-html: install-html-am
-
-install-html-am:
-
-install-info: install-info-am
-
-install-info-am:
-
-install-man:
-
-install-pdf: install-pdf-am
-
-install-pdf-am:
-
-install-ps: install-ps-am
-
-install-ps-am:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am: uninstall-binPROGRAMS uninstall-dist_binSCRIPTS \
-	uninstall-libexecPROGRAMS
-
-.MAKE: install-am install-strip
-
-.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean \
-	clean-binPROGRAMS clean-generic clean-libexecPROGRAMS \
-	clean-libtool cscopelist-am ctags ctags-am distclean \
-	distclean-compile distclean-generic distclean-libtool \
-	distclean-tags distdir dvi dvi-am html html-am info info-am \
-	install install-am install-binPROGRAMS install-data \
-	install-data-am install-dist_binSCRIPTS install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am \
-	install-libexecPROGRAMS install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	tags tags-am uninstall uninstall-am uninstall-binPROGRAMS \
-	uninstall-dist_binSCRIPTS uninstall-libexecPROGRAMS
-
-
--include $(top_srcdir)/git.mk
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
diff --git a/tools/gnome-session-check-accelerated-common.h b/tools/gnome-session-check-accelerated-common.h
deleted file mode 100644
index 59631d9..0000000
--- a/tools/gnome-session-check-accelerated-common.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/* -*- mode:c; c-basic-offset: 8; indent-tabs-mode: nil; -*- */
-/* Tool to set the property _GNOME_SESSION_ACCELERATED on the root window */
-/*
- * Copyright (C) 2013 SUSE LINUX Products GmbH, Nuernberg, Germany.
- *
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:
- *   Frederic Crozat <fcrozat@suse.com>
- */
-
-/* Exit value for helper */
-#define HELPER_ACCEL 0
-#define HELPER_NO_ACCEL 1
-#define HELPER_SOFTWARE_RENDERING 2
-
diff --git a/tools/gnome-session-check-accelerated-helper.c b/tools/gnome-session-check-accelerated-helper.c
deleted file mode 100644
index bdbbe77..0000000
--- a/tools/gnome-session-check-accelerated-helper.c
+++ /dev/null
@@ -1,463 +0,0 @@
-/* gcc -o gnome-session-accelerated `pkg-config --cflags --libs xcomposite gl` -Wall gnome-session-is-accelerated.c */
-
-/*
- * Copyright (C) 2010      Novell, Inc.
- * Copyright (C) 2006-2009 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:
- *   Vincent Untz <vuntz@gnome.org>
- *
- * Most of the code comes from desktop-effects [1], released under GPLv2+.
- * desktop-effects was written by:
- *   Soren Sandmann <sandmann@redhat.com>
- *
- * [1] http://git.fedorahosted.org/git/?p=desktop-effects.git;a=blob_plain;f=desktop-effects.c;hb=HEAD
- */
-
-/*
- * Here's the rationale behind this helper, quoting Owen, in his mail to the
- * release team:
- * (http://mail.gnome.org/archives/release-team/2010-June/msg00079.html)
- *
- * """
- * There are some limits to what we can do here automatically without
- * knowing anything about the driver situation on the system. The basic
- * problem is that there are all sorts of suck:
- *
- *  * No GL at all. This typically only happens if a system is
- *    misconfigured.
- *
- *  * Only software GL. This one is easy to detect. We have code in
- *    the Fedora desktop-effects tool, etc.
- *
- *  * GL that isn't featureful enough. (Tiny texture size limits, no
- *    texture-from-pixmap, etc.) Possible to detect with more work, but
- *    largely a fringe case.
- *
- *  * Buggy GL. This isn't possible to detect. Except for the case where
- *    all GL programs crash. For that reason, we probably don't want
- *    gnome-session to directly try and do any GL detection; better to
- *    use a helper binary.
- *
- *  * Horribly slow hardware GL. We could theoretically develop some sort
- *    of benchmark, but it's a tricky area. And how slow is too slow?
- * """
- *
- * Some other tools are doing similar checks:
- *  - desktop-effects (Fedora Config Tool) [1]
- *  - drak3d (Mandriva Config Tool) [2]
- *  - compiz-manager (Compiz wrapper) [3]
- *
- * [1] http://git.fedorahosted.org/git/?p=desktop-effects.git;a=blob_plain;f=desktop-effects.c;hb=HEAD
- * [2] http://svn.mandriva.com/cgi-bin/viewvc.cgi/soft/drak3d/trunk/lib/Xconfig/glx.pm?view=markup
- * [3] http://git.compiz.org/fusion/misc/compiz-manager/tree/compiz-manager
- */
-
-/* for strcasestr */
-#define _GNU_SOURCE
-
-#include <ctype.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <glib.h>
-
-#include <regex.h>
-
-#include <X11/Xlib.h>
-#include <X11/Xatom.h>
-#include <X11/extensions/Xcomposite.h>
-#include <GL/gl.h>
-#include <GL/glx.h>
-
-#include "gnome-session-check-accelerated-common.h"
-
-#define SIZE_UNSET 0
-#define SIZE_ERROR -1
-static int max_texture_size = SIZE_UNSET;
-static int max_renderbuffer_size = SIZE_UNSET;
-static gboolean has_llvmpipe = FALSE;
-
-static inline void
-_print_error (const char *str)
-{
-        fprintf (stderr, "gnome-session-is-accelerated: %s\n", str);
-}
-
-#define CMDLINE_UNSET -1
-#define CMDLINE_NON_FALLBACK_FORCED 0
-#define CMDLINE_FALLBACK_FORCED 1
-
-static int
-_parse_kcmdline (void)
-{
-        int ret = CMDLINE_UNSET;
-        GRegex *regex;
-        GMatchInfo *match;
-        char *contents;
-        char *word;
-        const char *arg;
-
-        if (!g_file_get_contents ("/proc/cmdline", &contents, NULL, NULL))
-                return ret;
-
-        regex = g_regex_new ("gnome.fallback=(\\S+)", 0, G_REGEX_MATCH_NOTEMPTY, NULL);
-        if (!g_regex_match (regex, contents, G_REGEX_MATCH_NOTEMPTY, &match))
-                goto out;
-
-        word = g_match_info_fetch (match, 0);
-        g_debug ("Found command-line match '%s'", word);
-        arg = word + strlen ("gnome.fallback=");
-        if (*arg != '0' && *arg != '1')
-                fprintf (stderr, "gnome-session-is-accelerated: Invalid value '%s' for gnome.fallback passed in kernel command line.\n", arg);
-        else
-                ret = atoi (arg);
-        g_free (word);
-
-out:
-        g_match_info_free (match);
-        g_regex_unref (regex);
-        g_free (contents);
-
-        g_debug ("Command-line parsed to %d", ret);
-
-        return ret;
-}
-
-static gboolean
-_has_composite (Display *display)
-{
-        int dummy1, dummy2;
-
-        return XCompositeQueryExtension (display, &dummy1, &dummy2);
-}
-
-static gboolean
-_is_comment (const char *line)
-{
-        while (*line && isspace(*line))
-                line++;
-
-        if (*line == '#' || *line == '\0')
-                return TRUE;
-        return FALSE;
-}
-
-static gboolean
-_is_gl_renderer_blacklisted (const char *renderer)
-{
-        FILE *blacklist;
-        char *line = NULL;
-        size_t line_len = 0;
-        gboolean ret = TRUE;
-
-        blacklist = fopen(PKGDATADIR "/hardware-compatibility", "r");
-        if (blacklist == NULL)
-                goto out;
-
-        while (getline (&line, &line_len, blacklist) != -1) {
-                int whitelist = 0;
-                const char *re_str;
-                regex_t re;
-                int status;
-
-                if (line == NULL)
-                        break;
-
-                /* Drop trailing \n */
-                line[strlen(line) - 1] = '\0';
-
-                if (_is_comment (line)) {
-                        free (line);
-                        line = NULL;
-                        continue;
-                }
-
-                if (line[0] == '+')
-                        whitelist = 1;
-                else if (line[0] == '-')
-                        whitelist = 0;
-                else {
-                        _print_error ("Invalid syntax in this line for hardware compatibility:");
-                        _print_error (line);
-                        free (line);
-                        line = NULL;
-                        continue;
-                }
-
-                re_str = line + 1;
-
-                if (regcomp (&re, re_str, REG_EXTENDED|REG_ICASE|REG_NOSUB) != 0) {
-                        _print_error ("Cannot use this regular expression for hardware compatibility:");
-                        _print_error (re_str);
-                } else {
-                        status = regexec (&re, renderer, 0, NULL, 0);
-                        regfree(&re);
-
-                        if (status == 0) {
-                                if (whitelist)
-                                        ret = FALSE;
-                                goto out;
-                        }
-                }
-
-                free (line);
-                line = NULL;
-        }
-
-        ret = FALSE;
-
-out:
-        if (line != NULL)
-                free (line);
-
-        if (blacklist != NULL)
-                fclose (blacklist);
-
-        return ret;
-}
-
-static gboolean
-_has_hardware_gl (Display *display)
-{
-        int screen;
-        Window root;
-        XVisualInfo *visual = NULL;
-        GLXContext context = NULL;
-        XSetWindowAttributes cwa = { 0 };
-        Window window = None;
-        const char *renderer;
-        gboolean ret = FALSE;
-
-        int attrlist[] = {
-                GLX_RGBA,
-                GLX_RED_SIZE, 1,
-                GLX_GREEN_SIZE, 1,
-                GLX_BLUE_SIZE, 1,
-                GLX_DOUBLEBUFFER,
-                None
-        };
-
-        screen = DefaultScreen (display);
-        root = RootWindow (display, screen);
-
-        visual = glXChooseVisual (display, screen, attrlist);
-        if (!visual)
-                goto out;
-
-        context = glXCreateContext (display, visual, NULL, True);
-        if (!context)
-                goto out;
-
-        cwa.colormap = XCreateColormap (display, root,
-                                        visual->visual, AllocNone);
-        cwa.background_pixel = 0;
-        cwa.border_pixel = 0;
-        window = XCreateWindow (display, root,
-                                0, 0, 1, 1, 0,
-                                visual->depth, InputOutput, visual->visual,
-                                CWColormap | CWBackPixel | CWBorderPixel,
-                                &cwa);
-
-        if (!glXMakeCurrent (display, window, context))
-                goto out;
-
-        renderer = (const char *) glGetString (GL_RENDERER);
-        if (_is_gl_renderer_blacklisted (renderer))
-                goto out;
-        if (renderer && strcasestr (renderer, "llvmpipe"))
-		has_llvmpipe = TRUE;
-
-        /* we need to get the max texture and renderbuffer sizes while we have
-         * a context, but we'll check their values later */
-
-        glGetIntegerv (GL_MAX_TEXTURE_SIZE, &max_texture_size);
-        if (glGetError() != GL_NO_ERROR)
-                max_texture_size = SIZE_ERROR;
-
-        glGetIntegerv (GL_MAX_RENDERBUFFER_SIZE_EXT, &max_renderbuffer_size);
-        if (glGetError() != GL_NO_ERROR)
-                max_renderbuffer_size = SIZE_ERROR;
-
-        ret = TRUE;
-
-out:
-        glXMakeCurrent (display, None, None);
-        if (context)
-                glXDestroyContext (display, context);
-        if (window)
-                XDestroyWindow (display, window);
-        if (cwa.colormap)
-                XFreeColormap (display, cwa.colormap);
-
-        return ret;
-}
-
-static gboolean
-_has_extension (const char *extension_list,
-                const char *extension)
-{
-        char **extensions;
-        guint i;
-        gboolean ret;
-
-        g_return_val_if_fail (extension != NULL, TRUE);
-
-        /* Extension_list is one big string, containing extensions
-         * separated by spaces. */
-        if (extension_list == NULL)
-                return FALSE;
-
-        ret = FALSE;
-
-        extensions = g_strsplit (extension_list, " ", -1);
-        if (extensions == NULL)
-                return FALSE;
-
-        for (i = 0; extensions[i] != NULL; i++) {
-                if (g_str_equal (extensions[i], extension)) {
-                        ret = TRUE;
-                        break;
-                }
-        }
-
-        g_strfreev (extensions);
-
-        return ret;
-}
-
-static gboolean
-_has_texture_from_pixmap (Display *display)
-{
-        int screen;
-        const char *server_extensions;
-        const char *client_extensions;
-        gboolean ret = FALSE;
-
-        screen = DefaultScreen (display);
-
-        server_extensions = glXQueryServerString (display, screen,
-                                                  GLX_EXTENSIONS);
-        if (!_has_extension (server_extensions,
-                            "GLX_EXT_texture_from_pixmap"))
-                goto out;
-
-        client_extensions = glXGetClientString (display, GLX_EXTENSIONS);
-        if (!_has_extension (client_extensions,
-                            "GLX_EXT_texture_from_pixmap"))
-                goto out;
-
-        ret = TRUE;
-
-out:
-        return ret;
-}
-
-static void
-_set_max_screen_size_property (Display *display, int screen, int size)
-{
-        Atom max_screen_size_atom;
-
-        max_screen_size_atom = XInternAtom (display, "_GNOME_MAX_SCREEN_SIZE",
-                                            False);
-
-        /* Will be read by gnome-settings-daemon and
-         * gnome-control-center to avoid display configurations where 3D
-         * is not available (and would break gnome-shell) */
-        XChangeProperty (display, RootWindow(display, screen),
-                         max_screen_size_atom,
-                         XA_CARDINAL, 32, PropModeReplace,
-                         (unsigned char *)&size, 1);
-
-        XSync(display, False);
-}
-
-static gboolean
-_is_max_texture_size_big_enough (Display *display)
-{
-        int screen, size;
-
-        screen = DefaultScreen (display);
-        size = MIN(max_renderbuffer_size, max_texture_size);
-        if (size < DisplayWidth (display, screen) ||
-            size < DisplayHeight (display, screen))
-                return FALSE;
-
-        _set_max_screen_size_property (display, screen, size);
-
-        return TRUE;
-}
-
-int
-main (int argc, char **argv)
-{
-        int      kcmdline_parsed;
-        Display *display = NULL;
-        int      ret = HELPER_NO_ACCEL;
-
-        kcmdline_parsed = _parse_kcmdline ();
-        if (kcmdline_parsed > CMDLINE_UNSET) {
-                if (kcmdline_parsed == CMDLINE_NON_FALLBACK_FORCED) {
-                        _print_error ("Non-fallback mode forced by kernel command line.");
-                        ret = HELPER_ACCEL;
-                        goto out;
-                } else if (kcmdline_parsed == CMDLINE_FALLBACK_FORCED) {
-                        _print_error ("Fallback mode forced by kernel command line.");
-                        goto out;
-                }
-        }
-
-        display = XOpenDisplay (NULL);
-        if (!display) {
-                _print_error ("No X display.");
-                goto out;
-        }
-
-        if (!_has_composite (display)) {
-                _print_error ("No composite extension.");
-                goto out;
-        }
-
-        if (!_has_hardware_gl (display)) {
-                _print_error ("No hardware 3D support.");
-                goto out;
-        }
-
-        if (!_has_texture_from_pixmap (display)) {
-                _print_error ("No GLX_EXT_texture_from_pixmap support.");
-                goto out;
-        }
-
-        if (!_is_max_texture_size_big_enough (display)) {
-                _print_error ("GL_MAX_{TEXTURE,RENDERBUFFER}_SIZE is too small.");
-                goto out;
-        }
-
-        if (has_llvmpipe) {
-                _print_error ("llvmpipe detected.");
-                ret = HELPER_SOFTWARE_RENDERING;
-                goto out;
-        }
-
-        ret = HELPER_ACCEL;
-
-out:
-        if (display)
-                XCloseDisplay (display);
-
-        return ret;
-}
diff --git a/tools/gnome-session-check-accelerated.c b/tools/gnome-session-check-accelerated.c
deleted file mode 100644
index cae2422..0000000
--- a/tools/gnome-session-check-accelerated.c
+++ /dev/null
@@ -1,195 +0,0 @@
-/* -*- mode:c; c-basic-offset: 8; indent-tabs-mode: nil; -*- */
-/* Tool to set the property _GNOME_SESSION_ACCELERATED on the root window */
-/*
- * Copyright (C) 2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:
- *   Colin Walters <walters@verbum.org>
- */
-
-#include <string.h>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include <gtk/gtk.h>
-#include <gdk/gdkx.h>
-#include <X11/Xatom.h>
-#include <sys/wait.h>
-
-#include "gnome-session-check-accelerated-common.h"
-
-/* Wait up to this long for a running check to finish */
-#define PROPERTY_CHANGE_TIMEOUT 5000
-
-/* Values used for the _GNOME_SESSION_ACCELERATED root window property */
-#define NO_ACCEL            0
-#define HAVE_ACCEL          1
-#define ACCEL_CHECK_RUNNING 2
-
-static Atom is_accelerated_atom;
-static Atom is_software_rendering_atom;
-static gboolean property_changed;
-
-static void
-exit_1_message (const char *msg) G_GNUC_NORETURN;
-
-static void
-exit_1_message (const char *msg)
-{
-  g_printerr ("%s", msg);
-  exit (1);
-}
-
-static gboolean
-on_property_notify_timeout (gpointer data)
-{
-        gtk_main_quit ();
-        return FALSE;
-}
-
-static GdkFilterReturn
-property_notify_filter (GdkXEvent *xevent,
-                        GdkEvent  *event,
-                        gpointer   data)
-{
-        XPropertyEvent *ev = xevent;
-
-        if (ev->type == PropertyNotify && ev->atom == is_accelerated_atom) {
-                property_changed = TRUE;
-                gtk_main_quit ();
-        }
-
-        return GDK_FILTER_CONTINUE;
-}
-
-static gboolean
-wait_for_property_notify (void)
-{
-        GdkDisplay *display;
-        GdkScreen *screen;
-        GdkWindow *root;
-        Window rootwin;
-
-        property_changed = FALSE;
-
-        display = gdk_display_get_default ();
-        screen = gdk_display_get_default_screen (display);
-        root = gdk_screen_get_root_window (screen);
-        rootwin = gdk_x11_window_get_xid (root);
-
-        XSelectInput (GDK_DISPLAY_XDISPLAY (display), rootwin, PropertyChangeMask);
-        gdk_window_add_filter (root, property_notify_filter, NULL);
-        g_timeout_add (PROPERTY_CHANGE_TIMEOUT, on_property_notify_timeout, NULL);
-
-        gtk_main ();
-
-        return property_changed;
-}
-
-int
-main (int argc, char **argv)
-{
-        GdkDisplay *display = NULL;
-        int estatus;
-        char *child_argv[] = { LIBEXECDIR "/gnome-session-check-accelerated-helper", NULL };
-        Window rootwin;
-        glong is_accelerated, is_software_rendering;
-        GError *error = NULL;
-
-        gtk_init (NULL, NULL);
-
-        display = gdk_display_get_default ();
-        rootwin = gdk_x11_get_default_root_xwindow ();
-
-        is_accelerated_atom = gdk_x11_get_xatom_by_name_for_display (display, "_GNOME_SESSION_ACCELERATED");
-        is_software_rendering_atom = gdk_x11_get_xatom_by_name_for_display (display, "_GNOME_IS_SOFTWARE_RENDERING");
-
-        {
-                Atom type;
-                gint format;
-                gulong nitems;
-                gulong bytes_after;
-                guchar *data;
-
- read:
-                gdk_x11_display_error_trap_push (display);
-                XGetWindowProperty (GDK_DISPLAY_XDISPLAY (display), rootwin,
-                                    is_accelerated_atom,
-                                    0, G_MAXLONG, False, XA_CARDINAL, &type, &format, &nitems,
-                                    &bytes_after, &data);
-                gdk_x11_display_error_trap_pop_ignored (display);
-
-                if (type == XA_CARDINAL) {
-                        glong *is_accelerated_ptr = (glong*) data;
-
-                        if (*is_accelerated_ptr == ACCEL_CHECK_RUNNING) {
-                                /* Test in progress, wait */
-                                if (wait_for_property_notify ())
-                                        goto read;
-                                /* else fall through and do the check ourselves */
-
-                        } else {
-                                return (*is_accelerated_ptr == 0 ? 1 : 0);
-                        }
-                }
-        }
-
-        /* We don't have the property or it's the wrong type.
-         * Try to compute it now.
-         */
-
-        /* First indicate that a test is in progress */
-        is_accelerated = ACCEL_CHECK_RUNNING;
-        XChangeProperty (GDK_DISPLAY_XDISPLAY (display),
-                         rootwin,
-                         is_accelerated_atom,
-                         XA_CARDINAL, 32, PropModeReplace, (guchar *) &is_accelerated, 1);
-
-        gdk_display_sync (display);
-
-        estatus = 1;
-        if (!g_spawn_sync (NULL, (char**)child_argv, NULL, 0,
-                           NULL, NULL, NULL, NULL, &estatus, &error)) {
-                is_accelerated = FALSE;
-                is_software_rendering = FALSE;
-                g_printerr ("gnome-session-check-accelerated: Failed to run helper: %s\n", error->message);
-                g_clear_error (&error);
-        } else {
-                is_accelerated = (WEXITSTATUS(estatus) == HELPER_ACCEL) || (WEXITSTATUS(estatus) == HELPER_SOFTWARE_RENDERING);
-                is_software_rendering = (WEXITSTATUS(estatus) == HELPER_SOFTWARE_RENDERING);
-                if (!is_accelerated)
-                        g_printerr ("gnome-session-check-accelerated: Helper exited with code %d\n", estatus);
-        }
-
-	if (is_accelerated) {
-		XChangeProperty (GDK_DISPLAY_XDISPLAY (display),
-				rootwin,
-				is_accelerated_atom,
-				XA_CARDINAL, 32, PropModeReplace, (guchar *) &is_accelerated, 1);
-	}
-
-	if (is_software_rendering) {
-		XChangeProperty (GDK_DISPLAY_XDISPLAY (display),
-				rootwin,
-				is_software_rendering_atom,
-				XA_CARDINAL, 32, PropModeReplace, (guchar *) &is_software_rendering, 1);
-	}
-
-        gdk_display_sync (display);
-
-        return is_accelerated ? 0 : 1;
-}
diff --git a/tools/gnome-session-custom-session b/tools/gnome-session-custom-session
deleted file mode 100644
index 07fdb0c..0000000
--- a/tools/gnome-session-custom-session
+++ /dev/null
@@ -1,4 +0,0 @@
-#! /bin/sh
-
-gnome-session-selector
-exec gnome-session
diff --git a/tools/gnome-session-inhibit.c b/tools/gnome-session-inhibit.c
deleted file mode 100644
index ff9d7d7..0000000
--- a/tools/gnome-session-inhibit.c
+++ /dev/null
@@ -1,261 +0,0 @@
-/*
- * Copyright (C) 2012 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#include "config.h"
-
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdint.h>
-#include <locale.h>
-
-#include <glib.h>
-#include <glib/gi18n.h>
-#include <gio/gio.h>
-
-#include "gnome-session/gsm-inhibitor-flag.h"
-
-static GsmInhibitorFlag parse_flags (const gchar *arg)
-{
-  GsmInhibitorFlag flags;
-  gchar **args;
-  gint i;
-
-  flags = 0;
-
-  args = g_strsplit (arg, ":", 0);
-  for (i = 0; args[i]; i++)
-    {
-      if (strcmp (args[i], "logout") == 0)
-        flags |= GSM_INHIBITOR_FLAG_LOGOUT;
-      else if (strcmp (args[i], "switch-user") == 0)
-        flags |= GSM_INHIBITOR_FLAG_SWITCH_USER;
-      else if (strcmp (args[i], "suspend") == 0)
-        flags |= GSM_INHIBITOR_FLAG_SUSPEND;
-      else if (strcmp (args[i], "idle") == 0)
-        flags |= GSM_INHIBITOR_FLAG_IDLE;
-      else if (strcmp (args[i], "automount") == 0)
-        flags |= GSM_INHIBITOR_FLAG_AUTOMOUNT;
-      else
-        g_print ("Ignoring inhibit argument: %s\n", args[i]);
-    }
-
-  g_strfreev (args);
-
-  return flags;
-}
-
-static gboolean inhibit (const gchar       *app_id,
-                         const gchar       *reason,
-                         GsmInhibitorFlag flags)
-{
-  GDBusConnection *bus;
-  GVariant *ret;
-  GError *error = NULL;
-
-  bus = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, &error);
-
-  if (bus == NULL)
-    {
-      g_warning ("Failed to connect to session bus: %s", error->message);
-      g_error_free (error);
-      return FALSE;
-    }
-
-  ret = g_dbus_connection_call_sync (bus,
-                               "org.gnome.SessionManager",
-                               "/org/gnome/SessionManager",
-                               "org.gnome.SessionManager",
-                               "Inhibit",
-                               g_variant_new ("(susu)",
-                                              app_id, 0, reason, flags),
-                               G_VARIANT_TYPE ("(u)"),
-                               0,
-                               G_MAXINT,
-                               NULL,
-                               &error);
-
-  if (ret == NULL)
-    {
-      g_warning ("Failed to call Inhibit: %s\n", error->message);
-      g_error_free (error);
-      return FALSE;
-    }
-
-  g_variant_unref (ret);
-
-  return TRUE;
-}
-
-static void usage (void)
-{
-  g_print (_("%s [OPTION...] COMMAND\n"
-             "\n"
-             "Execute COMMAND while inhibiting some session functionality.\n"
-             "\n"
-             "  -h, --help        Show this help\n"
-             "  --version         Show program version\n"
-             "  --app-id ID       The application id to use\n"
-             "                    when inhibiting (optional)\n"
-             "  --reason REASON   The reason for inhibiting (optional)\n"
-             "  --inhibit ARG     Things to inhibit, colon-separated list of:\n"
-             "                    logout, switch-user, suspend, idle, automount\n"
-             "  --inhibit-only    Do not launch COMMAND and wait forever instead\n"
-             "\n"
-             "If no --inhibit option is specified, idle is assumed.\n"),
-           g_get_prgname ());
-}
-
-static void version (void)
-{
-  g_print ("%s %s\n", g_get_prgname (), PACKAGE_VERSION);
-}
-
-static void
-wait_for_child_app (char **argv)
-{
-  pid_t pid;
-  int status;
-
-  pid = fork ();
-  if (pid < 0)
-    {
-      g_print ("fork failed\n");
-      exit (1);
-    }
-
-  if (pid == 0)
-    {
-      execvp (*argv, argv + 1);
-      g_print (_("Failed to execute %s\n"), *argv);
-      exit (1);
-    }
-
-  do
-    {
-      if (waitpid (pid, &status, 0) == -1)
-        {
-          g_print ("waitpid failed\n");
-          exit (1);
-        }
-
-      if (WIFEXITED (status))
-        exit (WEXITSTATUS (status));
-
-    } while (!WIFEXITED (status) && ! WIFSIGNALED(status));
-}
-
-static void
-wait_forever (void)
-{
-  g_print ("Inhibiting until Ctrl+C is pressed...\n");
-  while (1)
-    sleep (UINT32_MAX);
-}
-
-int main (int argc, char *argv[])
-{
-  gchar *prgname;
-  GsmInhibitorFlag inhibit_flags = 0;
-  gboolean show_help = FALSE;
-  gboolean show_version = FALSE;
-  gboolean no_launch = FALSE;
-  gint i;
-  const gchar *app_id = "unknown";
-  const gchar *reason = "not specified";
-
-  prgname = g_path_get_basename (argv[0]);
-  g_set_prgname (prgname);
-  g_free (prgname);
-
-  setlocale (LC_ALL, "");
-  bindtextdomain (GETTEXT_PACKAGE, LOCALE_DIR);
-  bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
-  textdomain (GETTEXT_PACKAGE);
-
-  for (i = 1; i < argc; i++)
-    {
-      if (strcmp (argv[i], "--help") == 0 ||
-          strcmp (argv[i], "-h") == 0)
-        show_help = TRUE;
-      else if (strcmp (argv[i], "--version") == 0)
-        show_version = TRUE;
-      else if (strcmp (argv[i], "--inhibit-only") == 0)
-        no_launch = TRUE;
-      else if (strcmp (argv[i], "--app-id") == 0)
-        {
-          i++;
-          if (i == argc)
-            {
-              g_print (_("%s requires an argument\n"), argv[i]);
-              exit (1);
-            }
-          app_id = argv[i];
-        }
-      else if (strcmp (argv[i], "--reason") == 0)
-        {
-          i++;
-          if (i == argc)
-            {
-              g_print (_("%s requires an argument\n"), argv[i]);
-              exit (1);
-            }
-          reason = argv[i];
-        }
-      else if (strcmp (argv[i], "--inhibit") == 0)
-        {
-          i++;
-          if (i == argc)
-            {
-              g_print (_("%s requires an argument\n"), argv[i]);
-              exit (1);
-            }
-          inhibit_flags |= parse_flags (argv[i]);
-        }
-      else
-        break;
-    }
-
-  if (show_version)
-    {
-      version ();
-      return 0;
-    }
-
-  if (show_help || (i == argc && !no_launch))
-    {
-      usage ();
-      return 0;
-    }
-
-  if (inhibit_flags == 0)
-    inhibit_flags = GSM_INHIBITOR_FLAG_IDLE;
-
-  if (inhibit (app_id, reason, inhibit_flags) == FALSE)
-    return 1;
-
-  if (!no_launch)
-    wait_for_child_app (argv + i);
-  else
-    wait_forever ();
-
-  return 0;
-}
diff --git a/tools/gnome-session-quit.c b/tools/gnome-session-quit.c
deleted file mode 100644
index b211584..0000000
--- a/tools/gnome-session-quit.c
+++ /dev/null
@@ -1,221 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- * save-session.c - Small program to talk to session manager.
-
-   Copyright (C) 1998 Tom Tromey
-   Copyright (C) 2008 Red Hat, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-   02111-1307, USA.
-*/
-
-#include <config.h>
-
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-
-#include <glib.h>
-#include <glib/gi18n.h>
-
-#include <dbus/dbus-glib.h>
-#include <dbus/dbus-glib-lowlevel.h>
-
-#define GSM_SERVICE_DBUS   "org.gnome.SessionManager"
-#define GSM_PATH_DBUS      "/org/gnome/SessionManager"
-#define GSM_INTERFACE_DBUS "org.gnome.SessionManager"
-
-enum {
-        GSM_LOGOUT_MODE_NORMAL = 0,
-        GSM_LOGOUT_MODE_NO_CONFIRMATION,
-        GSM_LOGOUT_MODE_FORCE
-};
-
-static gboolean opt_logout = FALSE;
-static gboolean opt_power_off = FALSE;
-static gboolean opt_reboot = FALSE;
-static gboolean opt_no_prompt = FALSE;
-static gboolean opt_force = FALSE;
-
-static GOptionEntry options[] = {
-        {"logout", '\0', 0, G_OPTION_ARG_NONE, &opt_logout, N_("Log out"), NULL},
-        {"power-off", '\0', 0, G_OPTION_ARG_NONE, &opt_power_off, N_("Power off"), NULL},
-        {"reboot", '\0', 0, G_OPTION_ARG_NONE, &opt_reboot, N_("Reboot"), NULL},
-        {"force", '\0', 0, G_OPTION_ARG_NONE, &opt_force, N_("Ignoring any existing inhibitors"), NULL},
-        {"no-prompt", '\0', 0, G_OPTION_ARG_NONE, &opt_no_prompt, N_("Don't prompt for user confirmation"), NULL},
-        {NULL}
-};
-
-static void
-display_error (const char *message)
-{
-        g_printerr ("%s\n", message);
-}
-
-static DBusGConnection *
-get_session_bus (void)
-{
-        DBusGConnection *bus;
-        GError *error = NULL;
-
-        bus = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
-
-        if (bus == NULL) {
-                g_warning ("Couldn't connect to session bus: %s", error->message);
-                g_error_free (error);
-        }
-
-        return bus;
-}
-
-static DBusGProxy *
-get_sm_proxy (void)
-{
-        DBusGConnection *connection;
-        DBusGProxy      *sm_proxy;
-
-        connection = get_session_bus ();
-        if (connection == NULL) {
-                display_error (_("Could not connect to the session manager"));
-                return NULL;
-        }
-
-        sm_proxy = dbus_g_proxy_new_for_name (connection,
-                                               GSM_SERVICE_DBUS,
-                                               GSM_PATH_DBUS,
-                                               GSM_INTERFACE_DBUS);
-
-        if (sm_proxy == NULL) {
-                display_error (_("Could not connect to the session manager"));
-                return NULL;
-        }
-
-        return sm_proxy;
-}
-
-static void
-do_logout (unsigned int mode)
-{
-        DBusGProxy *sm_proxy;
-        GError     *error;
-        gboolean    res;
-
-        sm_proxy = get_sm_proxy ();
-        if (sm_proxy == NULL) {
-                return;
-        }
-
-        error = NULL;
-        res = dbus_g_proxy_call (sm_proxy,
-                                 "Logout",
-                                 &error,
-                                 G_TYPE_UINT, mode,
-                                 G_TYPE_INVALID,
-                                 G_TYPE_INVALID);
-
-        if (!res) {
-                if (error != NULL) {
-                        g_warning ("Failed to call logout: %s",
-                                   error->message);
-                        g_error_free (error);
-                } else {
-                        g_warning ("Failed to call logout");
-                }
-        }
-
-        g_clear_object (&sm_proxy);
-}
-
-static void
-do_power_off (const char *action)
-{
-        DBusGProxy *sm_proxy;
-        GError     *error;
-        gboolean    res;
-
-        sm_proxy = get_sm_proxy ();
-        if (sm_proxy == NULL) {
-                return;
-        }
-
-        error = NULL;
-        res = dbus_g_proxy_call (sm_proxy,
-                                 action,
-                                 &error,
-                                 G_TYPE_INVALID,
-                                 G_TYPE_INVALID);
-
-        if (!res) {
-                if (error != NULL) {
-                        g_warning ("Failed to call %s: %s",
-                                   action, error->message);
-                        g_error_free (error);
-                } else {
-                        g_warning ("Failed to call %s", action);
-                }
-        }
-
-        g_clear_object (&sm_proxy);
-}
-
-int
-main (int argc, char *argv[])
-{
-        GError *error;
-        int     conflicting_options;
-        GOptionContext *ctx;
-
-        /* Initialize the i18n stuff */
-        bindtextdomain (GETTEXT_PACKAGE, LOCALE_DIR);
-        bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
-        textdomain (GETTEXT_PACKAGE);
-
-        error = NULL;
-        ctx = g_option_context_new ("");
-        g_option_context_add_main_entries (ctx, options, GETTEXT_PACKAGE);
-        if (! g_option_context_parse (ctx, &argc, &argv, &error)) {
-                g_warning ("Unable to start: %s", error->message);
-                g_error_free (error);
-                exit (1);
-        }
-        g_option_context_free (ctx);
-
-        conflicting_options = 0;
-        if (opt_logout)
-                conflicting_options++;
-        if (opt_power_off)
-                conflicting_options++;
-        if (opt_reboot)
-                conflicting_options++;
-        if (conflicting_options > 1)
-                display_error (_("Program called with conflicting options"));
-
-        if (opt_power_off) {
-                do_power_off ("Shutdown");
-        } else if (opt_reboot) {
-                do_power_off ("Reboot");
-        } else {
-                /* default to logout */
-
-                if (opt_force)
-                        do_logout (GSM_LOGOUT_MODE_FORCE);
-                else if (opt_no_prompt)
-                        do_logout (GSM_LOGOUT_MODE_NO_CONFIRMATION);
-                else
-                        do_logout (GSM_LOGOUT_MODE_NORMAL);
-        }
-
-        return 0;
-}
diff --git a/tools/gnome-session-selector.c b/tools/gnome-session-selector.c
deleted file mode 100644
index dad88b4..0000000
--- a/tools/gnome-session-selector.c
+++ /dev/null
@@ -1,699 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright 2010, 2013  Red Hat, Inc,
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Written by: Matthias Clasen <mclasen@redhat.com>
- */
-
-#include "config.h"
-
-#include <fcntl.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-
-#include <glib.h>
-#include <gtk/gtk.h>
-#include <gio/gio.h>
-
-#include <glib/gi18n.h>
-#include <glib/gstdio.h>
-
-#define GSM_MANAGER_SCHEMA        "org.gnome.SessionManager"
-#define KEY_AUTOSAVE_ONE_SHOT     "auto-save-session-one-shot"
-
-static GtkBuilder *builder;
-static GtkWidget *session_list;
-static GtkListStore *store;
-static GtkTreeModelSort *sort_model;
-
-static void select_session (const char *name);
-
-static char *
-get_session_path (const char *name)
-{
-        return g_build_filename (g_get_user_config_dir (), "gnome-session", name, NULL);
-}
-
-static char *
-find_new_session_name (void)
-{
-        char *name;
-        char *path;
-        int i;
-
-        for (i = 1; i < 20; i++) {
-                name = g_strdup_printf (_("Session %d"), i);
-                path = get_session_path (name);
-                if (!g_file_test (path, G_FILE_TEST_EXISTS)) {
-                        g_free (path);
-                        return name;
-                }
-                g_free (path);
-                g_free (name);
-        }
-
-        return NULL;
-}
-
-static gboolean
-is_valid_session_name (const char *name)
-{
-        GtkTreeIter iter;
-        char *n;
-        const char *info_text;
-        char *warning_text;
-        gboolean user_tried_dot;
-        gboolean user_tried_slash;
-        GtkWidget *info_bar;
-        GtkWidget *label;
-
-        if (name[0] == 0) {
-                return FALSE;
-        }
-
-        if (name[0] == '.') {
-            user_tried_dot = TRUE;
-        } else {
-            user_tried_dot = FALSE;
-        }
-
-        if (strchr (name, '/') != NULL) {
-            user_tried_slash = TRUE;
-        } else {
-            user_tried_slash = FALSE;
-        }
-
-        info_text = _("Please select a custom session to run");
-        warning_text = NULL;
-        if (user_tried_dot && user_tried_slash) {
-            warning_text = g_strdup_printf ("%s\n<small><b>Note:</b> <i>%s</i></small>",
-                                            info_text,
-                                            _("Session names are not allowed to start with ‘.’ or contain ‘/’ characters"));
-        } else if (user_tried_dot) {
-            warning_text = g_strdup_printf ("%s\n<small><b>Note:</b> <i>%s</i></small>",
-                                            info_text,
-                                            _("Session names are not allowed to start with ‘.’"));
-        } else if (user_tried_slash) {
-            warning_text = g_strdup_printf ("%s\n<small><b>Note:</b> <i>%s</i></small>",
-                                            info_text,
-                                            _("Session names are not allowed to contain ‘/’ characters"));
-        }
-
-        gtk_tree_model_get_iter_first (GTK_TREE_MODEL (store), &iter);
-        do {
-                gtk_tree_model_get (GTK_TREE_MODEL (store), &iter, 0, &n, -1);
-                if (strcmp (n, name) == 0) {
-                        char *message;
-                        message = g_strdup_printf (_("A session named ‘%s’ already exists"), name);
-                        warning_text = g_strdup_printf ("%s\n<small><b>Note:</b> <i>%s</i></small>", info_text, message);
-                        g_free (message);
-                        g_free (n);
-                        break;
-                }
-                g_free (n);
-        } while (gtk_tree_model_iter_next (GTK_TREE_MODEL (store), &iter));
-
-        info_bar = (GtkWidget *) gtk_builder_get_object (builder, "info-bar");
-        label = (GtkWidget*) gtk_builder_get_object (builder, "info-label");
-
-        if (warning_text != NULL) {
-            gtk_info_bar_set_message_type (GTK_INFO_BAR (info_bar), GTK_MESSAGE_WARNING);
-            gtk_label_set_markup (GTK_LABEL (label), warning_text);
-            g_free (warning_text);
-            return FALSE;
-        }
-
-        gtk_info_bar_set_message_type (GTK_INFO_BAR (info_bar), GTK_MESSAGE_OTHER);
-        gtk_label_set_markup (GTK_LABEL (label), info_text);
-
-        return TRUE;
-}
-
-static void
-populate_session_list (GtkWidget *session_list)
-{
-        GtkTreeIter iter;
-        char *path;
-        const char *name;
-        GDir *dir;
-        GError *error;
-        char *saved_session;
-        char *default_session;
-        char *default_name;
-        char last_session[PATH_MAX] = "";
-
-        saved_session = get_session_path ("saved-session");
-
-        if (!g_file_test (saved_session, G_FILE_TEST_IS_SYMLINK)) {
-                default_name = find_new_session_name ();
-                default_session = get_session_path (default_name);
-                rename (saved_session, default_session);
-                if (symlink (default_name, saved_session) < 0)
-                        g_warning ("Failed to convert saved-session to symlink");
-                g_free (default_name);
-                g_free (default_session);
-        }
-
-        path = g_build_filename (g_get_user_config_dir (), "gnome-session", NULL);
-        error = NULL;
-        dir = g_dir_open (path, 0, &error);
-        if (dir == NULL) {
-                g_warning ("Failed to open %s: %s", path, error->message);
-                g_error_free (error);
-                goto out;
-        }
-
-        default_name = NULL;
-        if (readlink (saved_session, last_session, PATH_MAX - 1) > 0) {
-                default_name = g_path_get_basename (last_session);
-        }
-
-        while ((name = g_dir_read_name (dir)) != NULL) {
-                if (strcmp (name, "saved-session") == 0)
-                        continue;
-
-                gtk_list_store_insert_with_values (store, &iter, 100, 0, name, -1);
-
-                if (g_strcmp0 (default_name, name) == 0) {
-                        GtkTreeSelection *selection;
-                        GtkTreeIter child_iter;
-
-                        gtk_tree_model_sort_convert_child_iter_to_iter (GTK_TREE_MODEL_SORT (sort_model), &child_iter, &iter);
-                        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (session_list));
-                        gtk_tree_selection_select_iter (selection, &child_iter);
-                }
-        }
-
-        g_free (default_name);
-        g_dir_close (dir);
-
- out:
-        g_free (saved_session);
-        g_free (path);
-}
-
-static char *
-get_selected_session (void)
-{
-        GtkTreeSelection *selection;
-        GtkTreeModel *model;
-        GtkTreeIter iter;
-        gchar *name;
-
-        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (session_list));
-        if (gtk_tree_selection_get_selected (selection, &model, &iter)) {
-                gtk_tree_model_get (model, &iter, 0, &name, -1);
-                return name;
-        }
-
-        return NULL;
-}
-
-static void
-remove_session (const char *name)
-{
-        char *path1, *path2;
-        char *n, *path;
-        const char *d;
-        GDir *dir;
-        GError *error;
-
-        path1 = get_session_path ("saved-session");
-        path2 = get_session_path (name);
-
-        error = NULL;
-        n = g_file_read_link (path1, &error);
-        if (n == NULL) {
-                g_warning ("Failed to read link: %s", error->message);
-                g_error_free (error);
-        }
-        else if (strcmp (n, name) == 0) {
-                unlink (path1);
-        }
-        g_free (n);
-
-        dir = g_dir_open (path2, 0, NULL);
-        while ((d = g_dir_read_name (dir)) != NULL) {
-                path = g_build_filename (path2, d, NULL);
-                unlink (path);
-                g_free (path);
-        }
-        g_dir_close (dir);
-
-        remove (path2);
-
-        g_free (path1);
-        g_free (path2);
-}
-
-static void
-on_remove_session_clicked (GtkButton *button,
-                           gpointer   data)
-{
-        GtkTreeSelection *selection;
-        GtkTreeModel *model;
-        GtkTreeIter iter;
-        char *name;
-
-        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (session_list));
-        if (gtk_tree_selection_get_selected (selection, &model, &iter)) {
-                GtkTreeIter child_iter;
-                gtk_tree_model_get (model, &iter, 0, &name, -1);
-                remove_session (name);
-                g_free (name);
-
-                gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (model), &child_iter, &iter);
-                gtk_list_store_remove (GTK_LIST_STORE (store), &child_iter);
-
-                if (!gtk_tree_selection_get_selected (selection, NULL, NULL)) {
-                        gtk_tree_model_get_iter_first (model, &iter);
-                        gtk_tree_model_get (model, &iter, 0, &name, -1);
-                        select_session (name);
-                        g_free (name);
-                }
-        }
-}
-
-static void
-begin_rename (void)
-{
-        GtkTreePath *path;
-        GtkTreeViewColumn *column;
-        GList *cells;
-
-        gtk_widget_grab_focus (session_list);
-
-        gtk_tree_view_get_cursor (GTK_TREE_VIEW (session_list),
-                                  &path, &column);
-
-        cells = gtk_cell_layout_get_cells (GTK_CELL_LAYOUT (column));
-
-        if (cells != NULL) {
-            GtkCellRenderer *cell;
-
-            cell = (GtkCellRenderer *) cells->data;
-            g_list_free (cells);
-
-            g_object_set (cell, "editable", TRUE, NULL);
-            gtk_tree_view_set_cursor_on_cell (GTK_TREE_VIEW (session_list), path,
-                                              column, cell, TRUE);
-        }
-        gtk_tree_path_free (path);
-}
-
-static void
-on_rename_session_clicked (GtkButton *button,
-                           gpointer   data)
-{
-    begin_rename ();
-}
-
-static void
-on_continue_clicked (GtkButton *button,
-                     gpointer    data)
-{
-        char *name;
-
-        name = get_selected_session ();
-        g_free (name);
-
-        gtk_main_quit ();
-}
-
-static void
-create_session (const char *name)
-{
-        char *path;
-        GtkTreeIter iter;
-
-        path = get_session_path (name);
-
-        if (mkdir (path, 0755) < 0) {
-                g_warning ("Failed to create directory %s", path);
-        }
-        else {
-                char *marker;
-
-                gtk_list_store_insert_with_values (store, &iter, 100, 0, name, -1);
-
-                marker = g_build_filename (path, ".new-session", NULL);
-                creat (marker, 0600);
-                g_free (marker);
-        }
-
-        g_free (path);
-}
-
-static gboolean
-rename_session (const char *old_name,
-                const char *new_name)
-{
-        char *old_path, *new_path;
-        int result;
-
-        if (g_strcmp0 (old_name, new_name) == 0) {
-                return TRUE;
-        }
-
-        if (!is_valid_session_name (new_name)) {
-               return FALSE;
-        }
-
-        old_path = get_session_path (old_name);
-        new_path = get_session_path (new_name);
-
-        result = g_rename (old_path, new_path);
-
-        if (result < 0) {
-                g_warning ("Failed to rename session from '%s' to '%s': %m", old_name, new_name);
-        }
-
-        g_free (old_path);
-        g_free (new_path);
-
-        return result == 0;
-}
-
-static gboolean
-make_session_current (const char *name)
-{
-        char *path1;
-        gboolean ret = TRUE;
-
-        path1 = g_build_filename (g_get_user_config_dir (), "gnome-session", "saved-session", NULL);
-
-        unlink (path1);
-        if (symlink (name, path1) < 0) {
-                g_warning ("Failed to make session '%s' current", name);
-                ret = FALSE;
-        }
-
-        g_free (path1);
-
-        return ret;
-}
-
-static gboolean
-create_and_select_session (const char *name)
-{
-        gchar *path;
-
-        if (name[0] == 0 || name[0] == '.' || strchr (name, '/')) {
-                g_warning ("Invalid session name");
-                return FALSE;
-        }
-
-        path = g_build_filename (g_get_user_config_dir (), "gnome-session", name, NULL);
-        if (!g_file_test (path, G_FILE_TEST_IS_DIR)) {
-                if (mkdir (path, 0755) < 0) {
-                        g_warning ("Failed to create directory %s", path);
-                        g_free (path);
-                        return FALSE;
-                }
-        }
-
-        g_free (path);
-
-        return make_session_current (name);
-}
-
-static void
-select_session (const char *name)
-{
-        GtkTreeIter iter;
-        char *n;
-
-        make_session_current (name);
-
-        /* now select it in the list */
-        gtk_tree_model_get_iter_first (GTK_TREE_MODEL (sort_model), &iter);
-        do {
-                gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &iter, 0, &n, -1);
-                if (strcmp (n, name) == 0) {
-                        GtkTreePath *path;
-
-                        path = gtk_tree_model_get_path (GTK_TREE_MODEL (sort_model), &iter);
-                        gtk_tree_view_set_cursor (GTK_TREE_VIEW (session_list), path, NULL, FALSE);
-                        gtk_tree_path_free (path);
-                        g_free (n);
-                        break;
-                }
-                g_free (n);
-        } while (gtk_tree_model_iter_next (GTK_TREE_MODEL (sort_model), &iter));
-}
-
-static void
-on_new_session_clicked (GtkButton *button,
-                        gpointer   data)
-{
-        gchar *name;
-
-        name = find_new_session_name ();
-        create_session (name);
-        select_session (name);
-
-        begin_rename ();
-}
-
-static void
-on_selection_changed (GtkTreeSelection *selection,
-                      gpointer          data)
-{
-        char *name;
-
-        name = get_selected_session ();
-
-        if (name == NULL) {
-                return;
-        }
-
-        make_session_current (name);
-
-        g_free (name);
-}
-
-static void
-update_remove_button (void)
-{
-        GtkWidget *button;
-
-        button = (GtkWidget *)gtk_builder_get_object (builder, "remove-session");
-        if (gtk_tree_model_iter_n_children (GTK_TREE_MODEL (store), NULL) > 1) {
-                gtk_widget_set_sensitive (button, TRUE);
-        } else {
-                gtk_widget_set_sensitive (button, FALSE);
-        }
-}
-
-static void
-on_row_edited (GtkCellRendererText *cell,
-               const char          *path_string,
-               const char          *new_name,
-               gpointer             data)
-{
-        GtkTreePath *path;
-        GtkTreeIter  sort_iter, items_iter;
-        char        *old_name;
-        gboolean     was_renamed;
-
-        path = gtk_tree_path_new_from_string (path_string);
-        gtk_tree_model_get_iter (GTK_TREE_MODEL (sort_model), &sort_iter, path);
-
-        gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter, 0, &old_name, -1);
-
-        was_renamed = rename_session (old_name, new_name);
-
-        if (was_renamed) {
-                gtk_tree_model_sort_convert_iter_to_child_iter (sort_model, &items_iter, &sort_iter);
-
-                gtk_list_store_set (store, &items_iter, 0, g_strdup (new_name), -1);
-                g_free (old_name);
-                make_session_current (new_name);
-        } else {
-                begin_rename ();
-        }
-
-        gtk_tree_path_free (path);
-
-        g_object_set (cell, "editable", FALSE, NULL);
-}
-
-static void
-on_row_deleted (GtkTreeModel *model,
-                GtkTreePath  *path,
-                gpointer      data)
-{
-        update_remove_button ();
-}
-
-static void
-on_row_inserted (GtkTreeModel *model,
-                 GtkTreePath  *path,
-                 GtkTreeIter  *iter,
-                 gpointer      data)
-{
-        update_remove_button ();
-}
-
-static void
-on_row_activated (GtkTreeView       *tree_view,
-                  GtkTreePath       *path,
-                  GtkTreeViewColumn *column,
-                  gpointer           data)
-{
-        char *name;
-
-        name = get_selected_session ();
-        g_free (name);
-
-        gtk_main_quit ();
-}
-
-static void
-auto_save_next_session (void)
-{
-        GSettings *settings;
-
-        settings = g_settings_new (GSM_MANAGER_SCHEMA);
-        g_settings_set_boolean (settings, KEY_AUTOSAVE_ONE_SHOT, TRUE);
-        g_object_unref (settings);
-}
-
-static void
-auto_save_next_session_if_needed (void)
-{
-        char *marker;
-
-        marker = g_build_filename (g_get_user_config_dir (),
-                                   "gnome-session", "saved-session",
-                                   ".new-session", NULL);
-
-        if (g_file_test (marker, G_FILE_TEST_EXISTS)) {
-                auto_save_next_session ();
-                unlink (marker);
-        }
-        g_free (marker);
-}
-
-static int
-compare_sessions (GtkTreeModel *model,
-                  GtkTreeIter  *a,
-                  GtkTreeIter  *b,
-                  gpointer      data)
-{
-    char *name_a, *name_b;
-    int result;
-
-    gtk_tree_model_get (model, a, 0, &name_a, -1);
-    gtk_tree_model_get (model, b, 0, &name_b, -1);
-
-    result = g_utf8_collate (name_a, name_b);
-
-    g_free (name_a);
-    g_free (name_b);
-
-    return result;
-}
-
-static void
-on_map (GtkWidget *widget,
-        gpointer   data)
-{
-        gdk_window_focus (gtk_widget_get_window (widget), GDK_CURRENT_TIME);
-}
-
-int
-main (int argc, char *argv[])
-{
-        GtkWidget *window;
-        GtkWidget *widget;
-        GtkCellRenderer *cell;
-        GtkTreeViewColumn *column;
-        GtkTreeSelection *selection;
-        GError *error;
-
-        if (getenv ("SESSION_MANAGER") != NULL)
-            return 1;
-
-        gtk_init (&argc, &argv);
-        if (argc > 1) {
-                g_print ("create and select session\n");
-                if (!create_and_select_session (argv[1]))
-                        return 1;
-                else
-                        return 0;
-        }
-
-        builder = gtk_builder_new ();
-        gtk_builder_set_translation_domain (builder, GETTEXT_PACKAGE);
-
-        error = NULL;
-        if (!gtk_builder_add_from_file (builder, GTKBUILDER_DIR "/" "session-selector.ui",  &error)) {
-                g_warning ("Could not load file 'session-selector.ui': %s", error->message);
-                exit (1);
-        }
-
-        window = (GtkWidget *) gtk_builder_get_object (builder, "main-window");
-
-        store = (GtkListStore *) gtk_builder_get_object (builder, "session-store");
-        sort_model = (GtkTreeModelSort *) gtk_builder_get_object (builder, "sort-model");
-
-        gtk_tree_sortable_set_sort_func (GTK_TREE_SORTABLE (sort_model),
-                                         0, compare_sessions, NULL, NULL);
-        gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model),
-                                              0, GTK_SORT_ASCENDING);
-        g_signal_connect (store, "row-deleted", G_CALLBACK (on_row_deleted), NULL);
-        g_signal_connect (store, "row-inserted", G_CALLBACK (on_row_inserted), NULL);
-        session_list = (GtkWidget *) gtk_builder_get_object (builder, "session-list");
-
-        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (session_list));
-        gtk_tree_selection_set_mode (selection, GTK_SELECTION_SINGLE);
-
-        populate_session_list (session_list);
-
-        cell = gtk_cell_renderer_text_new ();
-        g_signal_connect (cell, "edited", G_CALLBACK (on_row_edited), NULL);
-
-        column = gtk_tree_view_column_new_with_attributes ("", cell, "text", 0, NULL);
-        gtk_tree_view_append_column (GTK_TREE_VIEW (session_list), GTK_TREE_VIEW_COLUMN (column));
-
-        g_signal_connect (session_list, "row-activated", G_CALLBACK (on_row_activated), NULL);
-
-        g_signal_connect (selection, "changed",
-                          G_CALLBACK (on_selection_changed), NULL);
-
-        widget = (GtkWidget *) gtk_builder_get_object (builder, "new-session");
-        g_signal_connect (widget, "clicked", G_CALLBACK (on_new_session_clicked), NULL);
-        widget = (GtkWidget *) gtk_builder_get_object (builder, "remove-session");
-        g_signal_connect (widget, "clicked", G_CALLBACK (on_remove_session_clicked), NULL);
-        widget = (GtkWidget *) gtk_builder_get_object (builder, "rename-session");
-        g_signal_connect (widget, "clicked", G_CALLBACK (on_rename_session_clicked), NULL);
-        widget = (GtkWidget *) gtk_builder_get_object (builder, "continue-button");
-        g_signal_connect (widget, "clicked", G_CALLBACK (on_continue_clicked), NULL);
-
-        g_signal_connect (window, "map", G_CALLBACK (on_map), NULL);
-        gtk_widget_show (window);
-
-        gtk_main ();
-
-        auto_save_next_session_if_needed ();
-
-        return 0;
-}
-- 
2.1.3

